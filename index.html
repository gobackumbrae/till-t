<!DOCTYPE html>
<html lang="en">
<head>



<!-- TT_WEBGL_CROSS_STABILIZER_v3 -->
<script>
(() => {
  'use strict';
  if (window.__ttWebglCrossStabilizerV3) return;
  window.__ttWebglCrossStabilizerV3 = true;

  const locName = new WeakMap();   // loc -> uniform name
  const locInfo = new WeakMap();   // loc -> {kind, field}
  const glState = new WeakMap();   // gl  -> state

  const EPS = 1e-7;

  function clamp(x,a,b){ return x<a?a:(x>b?b:x); }
  function dot(a,b){ return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
  function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
  function len(v){ return Math.hypot(v[0],v[1],v[2]); }
  function norm(v){ const l=len(v); return (l<EPS)?[0,1,0]:[v[0]/l,v[1]/l,v[2]/l]; }
  function neg(v){ return [-v[0],-v[1],-v[2]]; }

  function projTangentRaw(v, c) {
    const d = dot(v,c);
    const px = v[0]-c[0]*d, py = v[1]-c[1]*d, pz = v[2]-c[2]*d;
    const l = Math.hypot(px,py,pz);
    if (l < EPS) return null;
    return { v:[px/l, py/l, pz/l], rawLen:l };
  }
  function projTangent(v, c) {
    const r = projTangentRaw(v,c);
    return r ? r.v : null;
  }

  function pickFallbackUp(c) {
    // Continuous enough, and only used on true degeneracy.
    const ax=Math.abs(c[0]), ay=Math.abs(c[1]), az=Math.abs(c[2]);
    let ref = [0,1,0];
    if (ax <= ay && ax <= az) ref = [1,0,0];
    else if (az <= ax && az <= ay) ref = [0,0,1];
    return projTangent(ref, c) || projTangent([0,0,1], c) || projTangent([1,0,0], c) || [0,1,0];
  }

  function rodrigues(v, k, cosA, sinA) {
    // v*cos + (k×v)*sin + k(k·v)(1-cos)
    const kxv = cross(k, v);
    const kdv = dot(k, v);
    return [
      v[0]*cosA + kxv[0]*sinA + k[0]*kdv*(1-cosA),
      v[1]*cosA + kxv[1]*sinA + k[1]*kdv*(1-cosA),
      v[2]*cosA + kxv[2]*sinA + k[2]*kdv*(1-cosA),
    ];
  }

  function transportUp(lastC, lastU, newC) {
    const axis = cross(lastC, newC);
    const sinA = len(axis);
    const cosA = clamp(dot(lastC, newC), -1, 1);

    if (sinA < EPS) {
      return projTangent(lastU, newC) || pickFallbackUp(newC);
    }
    const k = [axis[0]/sinA, axis[1]/sinA, axis[2]/sinA];
    const rot = rodrigues(lastU, k, cosA, sinA);
    return projTangent(rot, newC) || projTangent(lastU, newC) || pickFallbackUp(newC);
  }

  function signedAngleAroundAxis(u, v, axis) {
    const s = dot(axis, cross(u, v));
    const c = clamp(dot(u, v), -1, 1);
    return Math.atan2(s, c); // [-pi, pi]
  }

  function unwrapNear(prev, a) {
    while (a - prev > Math.PI)  a -= 2*Math.PI;
    while (a - prev < -Math.PI) a += 2*Math.PI;
    return a;
  }

  function classify(name) {
    if (!name) return null;
    const n = String(name).toLowerCase();

    let field = null;
    if (n.endsWith("center")) field = "center";
    else if (n.endsWith("up")) field = "up";
    else if (n.endsWith("right")) field = "right";
    else return null;

    let kind = null;
    if (n.includes("gravity") || n.includes("grav")) kind = "grav";
    else if (n.includes("cam") || n.includes("camera") || n.includes("view")) kind = "view";
    else return null;

    return { kind, field };
  }

  function getSt(gl) {
    let st = glState.get(gl);
    if (!st) {
      st = {
        lastT: performance.now(),
        grav: { loc:{center:null,up:null,right:null}, pend:{center:null,up:null,right:null}, lastCenter:null, lastUp:null, order:null, thetaU:0, thetaF:0 },
        view: { loc:{center:null,up:null,right:null}, pend:{center:null,up:null,right:null}, lastCenter:null, lastUp:null, order:null, thetaU:0, thetaF:0 },
      };
      glState.set(gl, st);
    }
    return st;
  }

  function flushKind(gl, st, kind, origU3f) {
    const ks = st[kind];
    const pend = ks.pend;

    const anyPending = !!(pend.center || pend.up || pend.right);
    if (!anyPending && ks.lastCenter && ks.lastUp) return;

    const lc = ks.loc.center, lu = ks.loc.up, lr = ks.loc.right;
    if (!lc && !lu && !lr) { pend.center = pend.up = pend.right = null; return; }

    // Center
    let center = ks.lastCenter;
    if (pend.center) center = norm(pend.center);
    if (!center) { pend.center = pend.up = pend.right = null; return; }

    // Timing
    const now = performance.now();
    const dt = clamp((now - st.lastT)/1000, 0.001, 0.05);
    st.lastT = now;
    const follow = 1 - Math.exp(-16 * dt); // smoothing weight

    // Desired up from app + strength
    let desired = null;
    let strength = 0;
    if (pend.up) {
      const pr = projTangentRaw(pend.up, center);
      if (pr) { desired = pr.v; strength = pr.rawLen; }
    }

    // Init
    if (!ks.lastUp) {
      ks.lastUp = desired || pickFallbackUp(center);
      ks.lastCenter = center.slice();
      ks.thetaU = 0;
      ks.thetaF = 0;
    }

    // Transport previous frame (continuous everywhere)
    const transported = transportUp(ks.lastCenter || center, ks.lastUp, center);

    // Update twist angle only when desired is reliable
    // NOTE: crosshair arms are LINES, so Up and -Up are equivalent:
    // we force desired into the same hemisphere as transported to eliminate 180° ambiguity.
    const MIN_STRENGTH = 0.12;
    let thetaTarget = ks.thetaU;
    let reliable = false;

    if (desired && strength >= MIN_STRENGTH) {
      if (dot(desired, transported) < 0) desired = neg(desired); // line-equivalence: kill pi flips
      const theta = signedAngleAroundAxis(transported, desired, center); // now typically within [-pi/2, pi/2]
      thetaTarget = unwrapNear(ks.thetaU, theta);
      ks.thetaU = thetaTarget;
      reliable = true;
    }

    // Rate limit + smooth theta to avoid snapping even if target jitters
    const MAX_RATE = 10.0;            // rad/sec
    const maxStep = MAX_RATE * dt;
    let delta = thetaTarget - ks.thetaF;
    delta = clamp(delta, -maxStep, maxStep);

    if (reliable) {
      ks.thetaF += delta * follow;
    } else {
      // If unreliable, don't chase; keep current filtered theta (prevents pole jitter)
      // (Could also decay toward 0, but keeping it is more stable visually.)
      ks.thetaF = ks.thetaF;
    }

    // Apply twist about the center axis
    const cosT = Math.cos(ks.thetaF);
    const sinT = Math.sin(ks.thetaF);
    let up = rodrigues(transported, center, cosT, sinT);
    up = projTangent(up, center) || transported;

    // Continuity (line-equivalence again)
    if (dot(up, ks.lastUp) < 0) up = neg(up);

    // Right: lock handedness once
    const candA = norm(cross(up, center));
    const candB = norm(cross(center, up));

    if (!ks.order) {
      if (pend.right) {
        const dr = norm(pend.right);
        ks.order = (dot(candA, dr) >= dot(candB, dr)) ? "A" : "B";
      } else {
        ks.order = "A";
      }
    }
    const right = (ks.order === "A") ? candA : candB;

    ks.lastCenter = center.slice();
    ks.lastUp = up.slice();

    // Write uniforms
    if (lc) origU3f.call(gl, lc, center[0], center[1], center[2]);
    if (lu) origU3f.call(gl, lu, up[0],     up[1],     up[2]);
    if (lr) origU3f.call(gl, lr, right[0],  right[1],  right[2]);

    pend.center = pend.up = pend.right = null;
  }

  function patchProto(proto) {
    if (!proto || proto.__ttCrossStabV3) return;
    proto.__ttCrossStabV3 = true;

    const origGet = proto.getUniformLocation;
    proto.getUniformLocation = function(program, name) {
      const loc = origGet.call(this, program, name);
      if (loc) locName.set(loc, name);
      return loc;
    };

    const origU3f = proto.uniform3f;
    const origU3fv = proto.uniform3fv;

    proto.uniform3f = function(loc, x, y, z) {
      let info = locInfo.get(loc);
      if (!info) {
        info = classify(locName.get(loc));
        if (info) locInfo.set(loc, info);
      }
      if (!info) return origU3f.call(this, loc, x, y, z);

      const st = getSt(this);
      const ks = st[info.kind];

      // record locations
      ks.loc[info.field] = loc;

      // buffer values (don't write immediately)
      ks.pend[info.field] = [x,y,z];
      return;
    };

    if (origU3fv) {
      proto.uniform3fv = function(loc, v) {
        if (v && v.length === 3) return this.uniform3f(loc, v[0], v[1], v[2]);
        return origU3fv.call(this, loc, v);
      };
    }

    function flushAll(gl) {
      const st = getSt(gl);
      flushKind(gl, st, "grav", origU3f);
      flushKind(gl, st, "view", origU3f);
    }

    const origDA = proto.drawArrays;
    if (origDA) proto.drawArrays = function(){ flushAll(this); return origDA.apply(this, arguments); };

    const origDE = proto.drawElements;
    if (origDE) proto.drawElements = function(){ flushAll(this); return origDE.apply(this, arguments); };

    const origDAI = proto.drawArraysInstanced;
    if (origDAI) proto.drawArraysInstanced = function(){ flushAll(this); return origDAI.apply(this, arguments); };

    const origDEI = proto.drawElementsInstanced;
    if (origDEI) proto.drawElementsInstanced = function(){ flushAll(this); return origDEI.apply(this, arguments); };
  }

  patchProto(window.WebGLRenderingContext && WebGLRenderingContext.prototype);
  patchProto(window.WebGL2RenderingContext && WebGL2RenderingContext.prototype);

})();
</script>
<!-- /TT_WEBGL_CROSS_STABILIZER_v3 -->




  <meta charset="utf-8">
  <title>till-T (multi bands)</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="theme-color" content="#020617">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background:
        radial-gradient(1200px circle at 12% 18%, rgba(56, 189, 248, 0.18), transparent 55%),
        radial-gradient(1000px circle at 86% 76%, rgba(244, 114, 182, 0.18), transparent 55%),
        radial-gradient(900px circle at 62% 22%, rgba(167, 139, 250, 0.12), transparent 60%),
        radial-gradient(1200px circle at 50% 120%, rgba(34, 197, 94, 0.06), transparent 60%),
        linear-gradient(180deg, #070c1f 0%, #020617 55%, #000000 100%);
      color: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, "Segoe UI", sans-serif;
    }

    body {
      touch-action: none;
      position: relative;
    }

    /* Subtle starfield + vignette (behind the canvas; vignette above) */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='240'%20height='240'%20viewBox='0%200%20240%20240'%3E%3Crect%20width='100%25'%20height='100%25'%20fill='none'/%3E%3Ccircle%20cx='163'%20cy='28'%20r='0.4'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='70'%20cy='62'%20r='0.5'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='188'%20cy='26'%20r='1.0'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='228'%20cy='139'%20r='0.4'%20fill='white'%20fill-opacity='0.35'/%3E%3Ccircle%20cx='108'%20cy='8'%20r='0.4'%20fill='white'%20fill-opacity='0.18'/%3E%3Ccircle%20cx='55'%20cy='59'%20r='0.8'%20fill='white'%20fill-opacity='0.35'/%3E%3Ccircle%20cx='6'%20cy='143'%20r='0.5'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='166'%20cy='179'%20r='0.8'%20fill='white'%20fill-opacity='0.3'/%3E%3Ccircle%20cx='56'%20cy='114'%20r='0.8'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='207'%20cy='222'%20r='0.4'%20fill='white'%20fill-opacity='0.5'/%3E%3Ccircle%20cx='206'%20cy='40'%20r='1.0'%20fill='white'%20fill-opacity='0.3'/%3E%3Ccircle%20cx='87'%20cy='71'%20r='0.5'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='195'%20cy='86'%20r='0.4'%20fill='white'%20fill-opacity='0.18'/%3E%3Ccircle%20cx='97'%20cy='24'%20r='0.6'%20fill='white'%20fill-opacity='0.5'/%3E%3Ccircle%20cx='88'%20cy='154'%20r='0.6'%20fill='white'%20fill-opacity='0.5'/%3E%3Ccircle%20cx='11'%20cy='186'%20r='0.7'%20fill='white'%20fill-opacity='0.35'/%3E%3Ccircle%20cx='31'%20cy='236'%20r='0.7'%20fill='white'%20fill-opacity='0.18'/%3E%3Ccircle%20cx='141'%20cy='75'%20r='1.2'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='158'%20cy='226'%20r='1.2'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='147'%20cy='49'%20r='1.0'%20fill='white'%20fill-opacity='0.18'/%3E%3Ccircle%20cx='11'%20cy='169'%20r='0.5'%20fill='white'%20fill-opacity='0.5'/%3E%3Ccircle%20cx='74'%20cy='20'%20r='1.2'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='221'%20cy='25'%20r='0.7'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='116'%20cy='162'%20r='1.2'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='41'%20cy='94'%20r='0.6'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='171'%20cy='68'%20r='1.0'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='165'%20cy='18'%20r='0.8'%20fill='white'%20fill-opacity='0.4'/%3E%3Ccircle%20cx='43'%20cy='136'%20r='1.0'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='41'%20cy='118'%20r='0.7'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='236'%20cy='163'%20r='1.0'%20fill='white'%20fill-opacity='0.35'/%3E%3Ccircle%20cx='56'%20cy='175'%20r='0.6'%20fill='white'%20fill-opacity='0.5'/%3E%3Ccircle%20cx='196'%20cy='198'%20r='0.4'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='210'%20cy='8'%20r='1.2'%20fill='white'%20fill-opacity='0.26'/%3E%3Ccircle%20cx='102'%20cy='68'%20r='0.4'%20fill='white'%20fill-opacity='0.22'/%3E%3Ccircle%20cx='233'%20cy='145'%20r='2.2'%20fill='white'%20fill-opacity='0.16'/%3E%3Ccircle%20cx='54'%20cy='167'%20r='1.8'%20fill='white'%20fill-opacity='0.16'/%3E%3Ccircle%20cx='226'%20cy='234'%20r='2.2'%20fill='white'%20fill-opacity='0.16'/%3E%3Ccircle%20cx='36'%20cy='67'%20r='1.6'%20fill='white'%20fill-opacity='0.12'/%3E%3Ccircle%20cx='190'%20cy='143'%20r='2.2'%20fill='white'%20fill-opacity='0.16'/%3E%3Ccircle%20cx='191'%20cy='149'%20r='1.8'%20fill='white'%20fill-opacity='0.2'/%3E%3Ccircle%20cx='102'%20cy='92'%20r='1.6'%20fill='white'%20fill-opacity='0.12'/%3E%3Ccircle%20cx='130'%20cy='126'%20r='1.6'%20fill='white'%20fill-opacity='0.12'/%3E%3C/svg%3E");
      background-repeat: repeat;
      background-size: 240px 240px;
      opacity: 0.20;
      mix-blend-mode: screen;
      z-index: 0;
      transform: translate3d(0,0,0);
      animation: starDrift 70s linear infinite;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(ellipse at 50% 55%,
          rgba(0,0,0,0.0) 0%,
          rgba(0,0,0,0.25) 55%,
          rgba(0,0,0,0.85) 100%);
      z-index: 2;
      opacity: 0.85;
    }

    @keyframes starDrift {
      0%   { transform: translate3d(0,0,0); }
      50%  { transform: translate3d(-40px, 18px, 0); }
      100% { transform: translate3d(0,0,0); }
    }


    /* -----------------------------------------------------------------------
       Performance / quality presets
       Set a class on <body class="fx-balanced">: fx-high | fx-balanced | fx-performance
       -------------------------------------------------------------------- */

    /* Balanced: keep the look, but disable the most expensive effects. */
    body.fx-balanced::before {
      animation: none;
      opacity: 0.14;
    }
    body.fx-balanced canvas {
      filter:
        drop-shadow(0 12px 32px rgba(56, 189, 248, 0.08))
        drop-shadow(0 18px 70px rgba(244, 114, 182, 0.05));
    }
    body.fx-balanced #overlay {
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
    }

    /* Performance: prioritize FPS. */
    body.fx-performance::before {
      animation: none;
      opacity: 0.08;
    }
    body.fx-performance canvas {
      filter: none;
    }
    body.fx-performance #overlay {
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
    }

    canvas {
      position: fixed;
      left: var(--sceneX, 0px);
      top: 0;
      width: var(--sceneW, 100%);
      /*
        The scene can optionally "reserve" vertical space for the bottom sheet
        (e.g., when the panel opens to half-height). We drive this via JS by
        setting --sceneH.
      */
      height: var(--sceneH, 100%);
      display: block;
      z-index: 1;

      /* Soft outer glow around the sphere (alpha-aware) */
      filter:
        drop-shadow(0 18px 55px rgba(56, 189, 248, 0.10))
        drop-shadow(0 28px 120px rgba(244, 114, 182, 0.07));
      will-change: transform;

      /* Animate scene reservation so the sphere glides instead of snapping */
      transition: height 0.24s cubic-bezier(0.2, 0.8, 0.2, 1),
        width 0.24s cubic-bezier(0.2, 0.8, 0.2, 1),
        left 0.24s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    /* While dragging the sheet, keep the scene 1:1 with the finger (no easing). */
    body.sheet-dragging canvas {
      transition: none;
    }

    /* Bottom‑sheet overlay panel */
    #overlay {
      position: fixed;
      left: 50%;
      bottom: 12px;
      transform: translate(-50%, 110%); /* hidden by default */
      width: calc(100% - 32px);
      max-width: 420px;
      /*
        Sheet height is driven by --sheetMaxH (px) so the grabber can resize.
        We use *height* (not only max-height) so size changes can animate smoothly.
      */
      /*
        IMPORTANT (mobile Safari / Chrome):
        Do NOT tie max-height to the same variable as height.
        If max-height jumps immediately to a smaller value, it will clamp the
        transitioning height, making "full -> shrink" look like a snap.
        We keep a constant max-height for safety and animate height only.
      */
      height: var(--sheetMaxH, calc(100vh - 12px));
      max-height: calc(100vh - 12px);
      display: flex;
      flex-direction: column;

      border: 1px solid transparent;
      background:
        linear-gradient(145deg,
          rgba(15, 23, 42, 0.78),
          rgba(17, 24, 39, 0.82)) padding-box,
        linear-gradient(135deg,
          rgba(56, 189, 248, 0.75),
          rgba(244, 114, 182, 0.55),
          rgba(167, 139, 250, 0.40)) border-box;
      overflow: hidden;
      padding: 10px 12px;
      border-radius: 12px 12px 16px 16px;
      font-size: 12px;
      z-index: 12;  /* above status note */
      backdrop-filter: blur(12px) saturate(130%);
      -webkit-backdrop-filter: blur(12px) saturate(130%);
      box-sizing: border-box;
      /* border drawn via background border-box */
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(15, 23, 42, 0.9);

      opacity: 0;
      pointer-events: none;
      transition:
        transform 0.25s ease-out,
        opacity 0.25s ease-out,
        height 0.24s cubic-bezier(0.2, 0.8, 0.2, 1);

    }


    /* Use dynamic viewport units on mobile browsers when available. */
    @supports (height: 100dvh) {
      #overlay {
        height: var(--sheetMaxH, calc(100dvh - 12px));
        max-height: calc(100dvh - 12px);
      }
    }

    /* While dragging the grabber, follow the finger exactly (no height easing). */
    #overlay.sheet-dragging {
      transition: transform 0.25s ease-out, opacity 0.25s ease-out;
      /* During drag, disable expensive blur to keep the sheet feeling 1:1 with the finger. */
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
    }

    #overlay.sheet-dragging::before {
      /* Slightly reduce the glossy overlay while dragging (less shimmer/jank). */
      opacity: 0.40;
    }



    /* Subtle glossy highlight inside the panel */
    #overlay::before {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(900px 220px at 22% 0%,
          rgba(255, 255, 255, 0.10),
          transparent 60%),
        linear-gradient(180deg,
          rgba(255, 255, 255, 0.06),
          transparent 28%,
          rgba(0, 0, 0, 0.18));
      opacity: 0.55;
    }

    /* When open, slide up */
    #overlay.open {
      transform: translate(-50%, 0);
      opacity: 1;
      pointer-events: auto;
    }

    #overlay .row {
      margin-bottom: 4px;
    }

    #overlay .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #a5b4fc;
      margin-top: 4px;
      margin-bottom: 4px;
    }

    #overlay hr {
      border: none;
      border-top: 1px solid rgba(148, 163, 184, 0.25);
      margin: 6px 0;
    }

    #overlay label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    #overlay input,
    #overlay select {
      font-size: 11px;
      padding: 3px 6px;
      margin: 1px 0;
      background: #020617;
      border: 1px solid #1f2937;
      color: #e5e7eb;
      border-radius: 4px;
      outline: none;
      transition: border-color 0.12s ease, box-shadow 0.12s ease, background-color 0.12s ease;
    }

    #overlay input[type="number"] {
      width: 72px;
    }

    #overlay input:focus,
    #overlay select:focus {
      border-color: #38bdf8;
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.4),
        0 0 12px rgba(56, 189, 248, 0.25);
      background: #020617;
    }

    /* Unified styling for all native range sliders (matches the multi-slider look) */
    #overlay input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 28px;
      background: transparent;
      margin: 0;
      padding: 0;
    }

    #overlay input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: rgba(148, 163, 184, 0.20);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      box-sizing: border-box;
    }

    #overlay input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 0%, rgba(59, 130, 246, 0.75), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(56, 189, 248, 0.85);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.55);
      margin-top: -7px; /* center thumb on 6px track */
      cursor: pointer;
    }

    #overlay input[type="range"]:focus::-webkit-slider-runnable-track {
      border-color: rgba(56, 189, 248, 0.75);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.25);
    }

    #overlay input[type="range"]::-moz-range-track {
      height: 6px;
      background: rgba(148, 163, 184, 0.20);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      box-sizing: border-box;
    }

    #overlay input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 0%, rgba(59, 130, 246, 0.75), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(56, 189, 248, 0.85);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.55);
      cursor: pointer;
    }

    #overlay input[type="range"]::-moz-focus-outer {
      border: 0;
    }

    #overlay input[type="range"]:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    /* Consistent disabled state for buttons */
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none !important;
    }

    #overlay #bandText,
    #overlay #currentText {
      color: #e5e7eb;
    }

    .advanced-row {
      display: none;
    }

    /* Overlay header */
    .overlay-header {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      margin-bottom: 4px;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      position: relative;
      z-index: 1;
    }

    .overlay-header-title {
      margin: 0;
    }

        /* Panel launcher (aligned with the sheet) */
    .settings-tab {
      position: fixed;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      width: calc(100% - 32px);
      max-width: 420px;
      height: 46px;
      padding: 0 12px;
      box-sizing: border-box;

      border: 1px solid transparent;
      background:
        linear-gradient(145deg,
          rgba(15, 23, 42, 0.68),
          rgba(17, 24, 39, 0.72)) padding-box,
        linear-gradient(135deg,
          rgba(56, 189, 248, 0.70),
          rgba(244, 114, 182, 0.48),
          rgba(167, 139, 250, 0.34)) border-box;

      border-radius: 12px 12px 16px 16px;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;

      font-size: 13px;
      z-index: 11;  /* below the sheet */
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.72),
        0 0 0 1px rgba(15, 23, 42, 0.85);
      transition: transform 0.25s ease-out, opacity 0.25s ease-out;
    }

    .settings-tab .settings-tab-grabber {
      width: 44px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.55);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.18),
        0 6px 18px rgba(0, 0, 0, 0.35);
      opacity: 0.85;
    }

    .settings-tab .settings-tab-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      line-height: 1;
      letter-spacing: 0.01em;
    }

    .settings-tab .settings-tab-icon {
      font-size: 16px;
      opacity: 0.95;
    }

    .settings-tab .settings-tab-chevron {
      font-size: 12px;
      opacity: 0.8;
      transform: translateY(-1px);
    }

    .settings-tab:active {
      transform: translateX(-50%) translateY(1px) scale(0.99);
    }

    .settings-tab.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateX(-50%) translateY(20px);
    }

/* Mode chips */
    .mode-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 2px 0 4px;
    }

    .mode-chip {
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.8);
      color: #e5e7eb;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      outline: none;
      cursor: pointer;
    }

    .mode-chip.active {
      border-color: rgba(56, 189, 248, 0.9);
      background: radial-gradient(circle at 30% 0%, rgba(59, 130, 246, 0.6), rgba(15, 23, 42, 1));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
      color: #f9fafb;
    }

    /* Band chips + toggles */
    .band-chips .mode-chip {
      min-width: 34px;
      text-align: center;
    }

    .band-chips .mode-chip.disabled {
      opacity: 0.45;
    }

    .band-chips .mode-chip.in-range {
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.35);
      border-color: rgba(34, 197, 94, 0.65);
    }

    .band-chip-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      margin-right: 6px;
      vertical-align: middle;
      background: var(--bandColor, rgba(56, 189, 248, 0.9));
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9);
    }

    .toggle-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      /* border drawn via background border-box */
      background: rgba(15, 23, 42, 0.85);
      color: #e5e7eb;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      user-select: none;
    }

    .toggle-chip input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }



    .slider-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      width: 100%;
    }

    .slider-label input[type="range"] {
      flex: 1;
    }

    .slider-label span {
      white-space: nowrap;

      box-sizing: border-box;
      overflow: hidden;
      will-change: width;
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      transition: width 0.18s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.15s ease;
    }

    .icon-chip {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.85);
      color: #e5e7eb;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      margin-right: 6px;
    }

    .icon-chip.muted {
      opacity: 0.5;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .status-chip.in-range {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.5);
    }

    .status-chip.out-of-range {
      background: rgba(248, 113, 113, 0.15);
      color: #fb7185;
      border: 1px solid rgba(248, 113, 113, 0.5);
    }

    .center-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }

    .center-controls button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.85);
      color: #e5e7eb;
      padding: 2px 8px;
      font-size: 11px;
    }

    .center-controls span {
      font-size: 10px;
      color: #9ca3af;
    }

    .axis-label {
      position: fixed;
      font-size: 12px;
      font-weight: 600;
      padding: 2px 7px;
      border-radius: 999px;
      background:
        linear-gradient(135deg,
          rgba(15, 23, 42, 0.96),
          rgba(30, 64, 175, 0.96));
      color: #e5e7eb;
      pointer-events: none;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      opacity: 0;
      z-index: 5;
      border: 1px solid rgba(56, 189, 248, 0.7);
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.7);
    }

    #labelPosX,
    #labelNegX {
      border-color: rgba(248, 113, 113, 0.85);
      color: #fecaca;
    }

    #labelPosY,
    #labelNegY {
      border-color: rgba(74, 222, 128, 0.85);
      color: #bbf7d0;
    }

    #labelPosZ,
    #labelNegZ {
      border-color: rgba(56, 189, 248, 0.9);
      color: #bae6fd;
    }

    /* Tilt labels on crosshairs – mini glass chips */
    .tilt-label {
      position: fixed;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(10px) saturate(130%);
      -webkit-backdrop-filter: blur(10px) saturate(130%);
      color: #f9fafb;
      pointer-events: none;
      white-space: nowrap;
      box-sizing: border-box;
      font-variant-numeric: tabular-nums;
      transition: width 180ms cubic-bezier(0.2, 0.8, 0.2, 1);
      will-change: width;
      transform: translate(-50%, -50%);
      opacity: 0;
      z-index: 7;
      box-shadow:
        0 6px 18px rgba(15, 23, 42, 0.6),
        0 0 0 1px rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    #gravityTiltLabel {
      border-color: rgba(244, 114, 182, 0.9);
    }

    #cameraTiltLabel {
      border-color: rgba(56, 189, 248, 0.9);
    }

    /* Offscreen measurer for animating tilt-label widths (prevents snap + avoids runaway growth) */
    .tilt-label-measure {
      left: -10000px !important;
      top: -10000px !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
      transform: none !important;
      transition: none !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
      box-shadow: none !important;
    }

    
    /* Camera-derived value shown inside the gravity label when camera is attached */
    .tilt-label .cam-attached-val {
      color: #67e8f9;
      font-weight: 700;
    }
/* Status note – top‑center */
    #status {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      border: 1px solid transparent;
      background:
        linear-gradient(145deg,
          rgba(15, 23, 42, 0.88),
          rgba(17, 24, 39, 0.94)) padding-box,
        linear-gradient(135deg,
          rgba(56, 189, 248, 0.55),
          rgba(244, 114, 182, 0.35),
          rgba(148, 163, 184, 0.18)) border-box;
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 999px;
      max-width: 320px;
      z-index: 10;
      box-sizing: border-box;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow:
        0 12px 30px rgba(0, 0, 0, 0.65),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      color: #cbd5f5;
      text-align: center;
    }

    @media (max-width: 480px) {
      #overlay {
        font-size: 11px;
      }
    }
  

    /* === Multi-handle range slider ====================================== */
    .multi-slider {
      position: relative;
      width: 100%;
      height: 28px;
      margin-top: 6px;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    .multi-slider .track {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 6px;
      transform: translateY(-50%);
      background: rgba(148, 163, 184, 0.20);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      box-sizing: border-box;
    }

    .multi-slider .range {
      position: absolute;
      top: 50%;
      height: 6px;
      transform: translateY(-50%);
      background: rgba(56, 189, 248, 0.45);
      border: 1px solid rgba(56, 189, 248, 0.25);
      border-radius: 999px;
      box-sizing: border-box;
      pointer-events: none;
    }

    .multi-slider .handle {
      position: absolute;
      top: 50%;
      width: 18px;
      height: 18px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: radial-gradient(circle at 30% 0%, rgba(59, 130, 246, 0.75), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(56, 189, 248, 0.85);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.55);
      cursor: pointer;
      touch-action: none;
    }

    .multi-slider .handle:active {
      transform: translate(-50%, -50%) scale(0.96);
    }

    .multi-slider .handle.locked {
      opacity: 0.45;
      cursor: default;
      border-color: rgba(148, 163, 184, 0.55);
      box-shadow: none;
    }

    .multi-slider .handle-label {
      position: absolute;
      left: 50%;
      top: -2px;
      transform: translate(-50%, -100%);
      font-size: 10px;
      color: #e5e7eb;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 6px;
      padding: 1px 5px;
      white-space: nowrap;
      pointer-events: none;
    }

    .multi-slider-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 6px;
      align-items: center;
    }

    .multi-slider-actions button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.85);
      color: #e5e7eb;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
    }

    .multi-slider-actions button:active {
      transform: scale(0.98);
    }


    .patch-centers {
      color: #cbd5e1;
      font-size: 11px;
      line-height: 1.35;
      white-space: normal;
      word-break: break-word;
    }

  
    /* Band resize handles overlay */
    #handlesLayer {
      position: fixed;
      inset: 0;
      pointer-events: none; /* individual handles enable events */
      z-index: 10; /* above canvas */
    }

    .band-handle {
      position: absolute;
      width: 22px;
      height: 22px;
      transform: translate(-50%, -50%);
      border-radius: 999px;

      /* Edge handles (default): blue */
      background:
        radial-gradient(circle at 30% 20%,
          rgba(255, 255, 255, 0.55),
          rgba(56, 189, 248, 0.92) 40%,
          rgba(14, 116, 144, 0.92) 100%);
      border: 1px solid rgba(2, 6, 23, 0.95);

      box-shadow:
        0 14px 30px rgba(0, 0, 0, 0.65),
        0 0 0 1px rgba(15, 23, 42, 0.85),
        inset 0 1px 0 rgba(255, 255, 255, 0.22),
        inset 0 -2px 6px rgba(0, 0, 0, 0.35);

      pointer-events: auto;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: grab;
    }

    .band-handle::before {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: inherit;
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.35),
        rgba(255, 255, 255, 0.06) 45%,
        rgba(0, 0, 0, 0.18));
      pointer-events: none;
      opacity: 0.9;
    }

    .band-handle::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 7px;
      height: 7px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(2, 6, 23, 0.22);
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, 0.10),
        0 1px 2px rgba(0, 0, 0, 0.35);
      pointer-events: none;
      opacity: 0.55;
    }

    .band-handle:active {
      cursor: grabbing;
      transform: translate(-50%, -50%) scale(0.96);
    }

    /* Corners = proportional scale (pink squares) */
    .band-handle.corner {
      border-radius: 7px;
      background:
        radial-gradient(circle at 30% 20%,
          rgba(255, 255, 255, 0.55),
          rgba(244, 114, 182, 0.92) 45%,
          rgba(190, 24, 93, 0.92) 100%);
      border: 1px solid rgba(2, 6, 23, 0.95);
      box-shadow:
        0 14px 30px rgba(0, 0, 0, 0.65),
        0 0 0 1px rgba(244, 114, 182, 0.55),
        inset 0 1px 0 rgba(255, 255, 255, 0.22),
        inset 0 -2px 6px rgba(0, 0, 0, 0.35);
    }

    .band-handle.edge {
      border-radius: 999px;
    }

    /* Inner boundary handles: same size as outer for a unified feel,
       but visually distinguished with a lighter, dashed outline. */
    .band-handle.inner {
      opacity: 0.75;
      border-style: dashed;
      box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.45),
        0 0 0 1px rgba(15, 23, 42, 0.75);
    }

    .band-handle.edge.inner {
      background:
        radial-gradient(circle at 30% 20%,
          rgba(255, 255, 255, 0.25),
          rgba(56, 189, 248, 0.40) 45%,
          rgba(14, 116, 144, 0.28) 100%);
      border-color: rgba(56, 189, 248, 0.90);
    }

    .band-handle.corner.inner {
      background:
        radial-gradient(circle at 30% 20%,
          rgba(255, 255, 255, 0.25),
          rgba(244, 114, 182, 0.40) 45%,
          rgba(190, 24, 93, 0.28) 100%);
      border-color: rgba(244, 114, 182, 0.90);
    }

    /* === UI refinements (vNext) ========================================== */
    #overlay .overlay-header {
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
      margin-bottom: 8px;
    }

    .sheet-grabber {
  /* Functional grabber: large hit target; the bar is drawn via ::before */
  width: 100%;
  height: 22px;
  margin: 0;
  padding: 0;
  border: 0;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: grab;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

.sheet-grabber::before {
  content: "";
  width: 46px;
  height: 4px;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.35);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
  opacity: 0.95;
}

.sheet-grabber:active {
  cursor: grabbing;
}

.sheet-grabber:focus-visible {
  outline: 2px solid rgba(56, 189, 248, 0.65);
  outline-offset: 3px;
  border-radius: 999px;
}

    .overlay-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .overlay-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #a5b4fc;
      user-select: none;
      -webkit-user-select: none;
    }

    .overlay-header-actions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .icon-close, .icon-collapse {
      padding: 2px 10px;
      font-weight: 700;
      line-height: 1;
    }

    /* Make the sheet usable on small screens */
    .overlay-body {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding-right: 2px;
      scrollbar-width: none; /* Firefox */
    }

    .overlay-body::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .panel-card {
      border: 1px solid rgba(148, 163, 184, 0.20);
      background: rgba(2, 6, 23, 0.22);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.35);
      position: relative;
      z-index: 1;
      margin-bottom: 8px;
    }

    .panel-card-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.10em;
      color: #c7d2fe;
      margin-bottom: 6px;
    }

    details.panel-section {
      border: 1px solid rgba(148, 163, 184, 0.20);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(2, 6, 23, 0.12);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      margin: 8px 0;
      position: relative;
      z-index: 1;
    }

    details.panel-section > summary {
      list-style: none;
      cursor: pointer;
      padding: 8px 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      user-select: none;
      -webkit-user-select: none;
      background: rgba(15, 23, 42, 0.42);
      border-bottom: 1px solid rgba(148, 163, 184, 0.14);
    }

    details.panel-section > summary::-webkit-details-marker {
      display: none;
    }

    details.panel-section > summary::after {
      content: "▾";
      margin-left: auto;
      opacity: 0.75;
      transform: rotate(0deg);
      transition: transform 0.15s ease;
    }

    details.panel-section:not([open]) > summary::after {
      transform: rotate(-90deg);
    }

    .summary-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.10em;
      color: #c7d2fe;
    }

    .summary-sub {
      font-size: 11px;
      color: #9ca3af;
    }

    .section-body {
      padding: 8px 10px 10px;
    }

    .band-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-end;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 11px;
      color: #cbd5e1;
    }

    .field input[type="text"] {
      min-width: 160px;
    }

    #overlay input[type="color"] {
      width: 44px;
      height: 28px;
      padding: 0;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(2, 6, 23, 0.75);
    }

    #overlay input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 4px;
    }

    #overlay input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 6px;
    }

    /* Bands row: horizontal scroll instead of wrapping into tall stacks */
    .band-chips {
      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
      scrollbar-width: none;
    }

    .band-chips::-webkit-scrollbar {
      display: none;
    }

    .band-chip-label {
      display: inline-block;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: middle;
    }

    /* Slightly larger tap targets */
    .mode-chip,
    .multi-slider-actions button,
    .center-controls button,
    .icon-chip {
      padding: 4px 10px;
      font-size: 11px;
      min-height: 30px;
    }

    .mode-chip {
      font-size: 11px;
    }

    @media (max-width: 420px) {
      .field input[type="text"] { min-width: 120px; }
      .band-chip-label { max-width: 86px; }
    }

    /* === UI polish (ultra) =============================================== */

    .overlay-title-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .band-pill {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      min-width: 0;
      max-width: 210px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(2, 6, 23, 0.22);
      color: #e5e7eb;
      box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.28),
        0 0 0 1px rgba(15, 23, 42, 0.65);
      cursor: pointer;
      outline: none;
    }

    .band-pill:active {
      transform: translateY(1px) scale(0.98);
    }

    .band-pill.disabled {
      opacity: 0.55;
    }

    .band-pill.in-range {
      border-color: rgba(34, 197, 94, 0.65);
      box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.28),
        0 0 0 2px rgba(34, 197, 94, 0.25);
    }

    .band-pill-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--bandColor, rgba(56, 189, 248, 0.9));
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 0 18px rgba(56, 189, 248, 0.22);
      flex: 0 0 auto;
    }

    .band-pill-label {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 11px;
      color: #cbd5e1;
    }

    /* Sticky navigation tabs inside the sheet */
    .overlay-nav {
      position: relative;
      z-index: 3;
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      padding: 6px;
      margin: 0 0 10px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background:
        linear-gradient(135deg,
          rgba(2, 6, 23, 0.10),
          rgba(15, 23, 42, 0.14));
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.22);
    }

    .nav-tab {
      flex: 1;
      min-height: 30px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(15, 23, 42, 0.20);
      color: rgba(229, 231, 235, 0.92);
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      padding: 4px 6px;
      white-space: nowrap;
    }

    .nav-tab.active {
      border-color: rgba(56, 189, 248, 0.70);
      background: radial-gradient(circle at 30% 0%,
        rgba(59, 130, 246, 0.35),
        rgba(2, 6, 23, 0.35));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.25);
      color: #f9fafb;
    }

    .nav-tab:active {
      transform: translateY(1px) scale(0.98);
    }

    /* Segmented control style (for mode chips) */
    .mode-chips.segmented {
      padding: 6px;
      border-radius: 14px;
      background: rgba(2, 6, 23, 0.16);
      border: 1px solid rgba(148, 163, 184, 0.18);
      gap: 6px;
    }

    .mode-chips.segmented .mode-chip {
      flex: 1;
      min-height: 32px;
      text-align: center;
      border-radius: 12px;
      border-color: rgba(148, 163, 184, 0.22);
      background: rgba(15, 23, 42, 0.18);
    }

    .mode-chips.segmented .mode-chip.active {
      border-color: rgba(56, 189, 248, 0.85);
      background: radial-gradient(circle at 30% 0%,
        rgba(59, 130, 246, 0.42),
        rgba(2, 6, 23, 0.36));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.28);
    }

    /* Button hierarchy */
    button.btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.22);
      color: #e5e7eb;
      padding: 4px 10px;
      min-height: 32px;
      font-size: 11px;
      cursor: pointer;
      transition: transform 0.08s ease, border-color 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    }

    button.btn:active {
      transform: translateY(1px) scale(0.98);
    }

    /* Make sure our .btn styles win inside existing button groups */
    .multi-slider-actions button.btn,
    .center-controls button.btn,
    .band-actions button.btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.22);
      color: #e5e7eb;
      padding: 4px 10px;
      min-height: 32px;
      font-size: 11px;
    }

    button.btn-primary,
    .multi-slider-actions button.btn-primary,
    .center-controls button.btn-primary,
    .band-actions button.btn-primary {
      border-color: rgba(56, 189, 248, 0.75);
      background: radial-gradient(circle at 30% 0%,
        rgba(59, 130, 246, 0.42),
        rgba(15, 23, 42, 0.32));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.22);
    }

    button.btn-secondary,
    .multi-slider-actions button.btn-secondary,
    .center-controls button.btn-secondary,
    .band-actions button.btn-secondary {
      border-color: rgba(148, 163, 184, 0.28);
      background: rgba(2, 6, 23, 0.14);
    }

    button.btn-ghost,
    .multi-slider-actions button.btn-ghost,
    .center-controls button.btn-ghost,
    .band-actions button.btn-ghost {
      border-color: rgba(148, 163, 184, 0.22);
      background: rgba(2, 6, 23, 0.10);
    }

    button.btn-danger,
    .multi-slider-actions button.btn-danger,
    .center-controls button.btn-danger,
    .band-actions button.btn-danger {
      border-color: rgba(248, 113, 113, 0.55);
      background: radial-gradient(circle at 30% 0%,
        rgba(248, 113, 113, 0.20),
        rgba(2, 6, 23, 0.22));
      color: #fecaca;
    }

    button.btn-icon,
    .multi-slider-actions button.btn-icon,
    .center-controls button.btn-icon,
    .band-actions button.btn-icon {
      width: 36px;
      padding-left: 0;
      padding-right: 0;
      text-align: center;
      font-weight: 700;
    }

    /* Switch style for checkboxes inside toggle chips */
    .toggle-chip {
      gap: 10px;
      padding: 5px 10px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(2, 6, 23, 0.14);
    }

    .toggle-chip input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 36px;
      height: 20px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      border: 1px solid rgba(148, 163, 184, 0.35);
      position: relative;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(2, 6, 23, 0.22);
      flex: 0 0 auto;
    }

    .toggle-chip input[type="checkbox"]::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 2px;
      width: 16px;
      height: 16px;
      transform: translate(0, -50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.88);
      box-shadow:
        0 6px 14px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
      transition: transform 0.14s ease, background-color 0.14s ease;
    }

    .toggle-chip input[type="checkbox"]:checked {
      background: rgba(34, 197, 94, 0.26);
      border-color: rgba(34, 197, 94, 0.55);
    }

    .toggle-chip input[type="checkbox"]:checked::after {
      transform: translate(16px, -50%);
      background: rgba(236, 253, 245, 0.95);
    }

    /* Small safe area padding on iOS */
    @supports (padding: max(0px)) {
      #overlay {
        padding-top: max(10px, env(safe-area-inset-top));
        padding-bottom: max(10px, env(safe-area-inset-bottom));
      }
    }


    /* === UI upgrade: band list manager ==================================== */
    .band-chip-strip {
      flex-wrap: nowrap;
      overflow-x: auto;
      overscroll-behavior-x: contain;
      scrollbar-width: none; /* Firefox */
      padding-bottom: 4px;
    }

    .band-chip-strip::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .band-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 6px;
    }

    .band-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 9px 10px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background:
        linear-gradient(135deg,
          rgba(2, 6, 23, 0.16),
          rgba(15, 23, 42, 0.12));
      box-shadow:
        0 10px 22px rgba(0,0,0,0.20),
        0 0 0 1px rgba(2, 6, 23, 0.20);
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .band-row:active {
      transform: translateY(1px) scale(0.995);
    }

    .band-row.active {
      border-color: rgba(56, 189, 248, 0.70);
      background:
        radial-gradient(circle at 30% 0%,
          rgba(59, 130, 246, 0.20),
          rgba(2, 6, 23, 0.18));
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.22),
        0 12px 26px rgba(0,0,0,0.25);
    }

    .band-row.disabled {
      opacity: 0.55;
    }

    .band-row-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--bandColor, rgba(56, 189, 248, 0.9));
      box-shadow:
        0 0 0 2px rgba(2, 6, 23, 0.80),
        0 0 0 1px rgba(15, 23, 42, 0.55);
      flex: 0 0 auto;
    }

    .band-row-text {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .band-row-title {
      font-size: 12px;
      font-weight: 750;
      line-height: 1.1;
      color: rgba(249, 250, 251, 0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .band-row-sub {
      font-size: 10px;
      line-height: 1.1;
      color: rgba(148, 163, 184, 0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .band-row-right {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .band-row-status {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(2, 6, 23, 0.10);
      color: rgba(148, 163, 184, 0.95);
      min-width: 34px;
      text-align: center;
    }

    .band-row-status.in {
      border-color: rgba(34, 197, 94, 0.55);
      background: rgba(34, 197, 94, 0.10);
      color: #22c55e;
    }

    .band-row-status.out {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.08);
      color: #fb7185;
    }

    .band-row-status.off {
      border-color: rgba(148, 163, 184, 0.25);
      background: rgba(2, 6, 23, 0.08);
      color: rgba(148, 163, 184, 0.95);
    }

    .band-row-actions {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .band-row-action {
      width: 32px;
      height: 32px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(2, 6, 23, 0.12);
      color: rgba(229, 231, 235, 0.92);
      font-size: 13px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }

    .band-row-action:active {
      transform: translateY(1px) scale(0.98);
    }

    .band-row-action.danger {
      border-color: rgba(248, 113, 113, 0.45);
      color: #fecaca;
      background: rgba(248, 113, 113, 0.08);
    }

    .band-row-action:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      transform: none;
    }

    /* Compact, performance-friendly switch for list rows */
    .mini-switch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .mini-switch input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 34px;
      height: 18px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      border: 1px solid rgba(148, 163, 184, 0.35);
      position: relative;
      outline: none;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(2, 6, 23, 0.20);
    }

    .mini-switch input[type="checkbox"]::after {
      content: "";
      position: absolute;
      left: 2px;
      top: 50%;
      width: 14px;
      height: 14px;
      transform: translate(0, -50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.88);
      box-shadow:
        0 6px 14px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
      transition: transform 0.14s ease, background-color 0.14s ease;
    }

    .mini-switch input[type="checkbox"]:checked {
      background: rgba(34, 197, 94, 0.20);
      border-color: rgba(34, 197, 94, 0.55);
    }

    .mini-switch input[type="checkbox"]:checked::after {
      transform: translate(16px, -50%);
      background: rgba(236, 253, 245, 0.95);
    }

    /* Bands toolbar: keep it minimal now that rows have actions */
    .band-actions #dupBandBtn,
    .band-actions #removeBandBtn,
    .band-actions #moveBandUpBtn,
    .band-actions #moveBandDownBtn {
      display: none;
    }



    /* -----------------------------------------------------------------------
       Landscape split layout: panel on the left, sphere on the right.
       The sheet "size" variable (--sheetMaxH) becomes WIDTH in landscape.
       -------------------------------------------------------------------- */
    body.landscape #overlay {
      left: 12px;
      right: auto;
      top: 12px;
      bottom: 12px;

      width: var(--sheetMaxH, calc(50vw - 12px));
      max-width: calc(100vw - 24px);

      height: calc(100vh - 24px);
      max-height: calc(100vh - 24px);

      transform: translateX(-110%);
      border-radius: 12px 16px 16px 12px;

      /* Room for the vertical grabber on the right edge */
      padding-right: 30px;

      transition:
        transform 0.25s ease-out,
        opacity 0.25s ease-out,
        width 0.24s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    @supports (height: 100dvh) {
      body.landscape #overlay {
        height: calc(100dvh - 24px);
        max-height: calc(100dvh - 24px);
      }
    }

    body.landscape #overlay.open {
      transform: translateX(0);
    }

    /* Landscape: the vertical grabber should be positioned relative to the whole sheet,
       not the header block, otherwise it overlaps the collapse button. */
    body.landscape .overlay-header {
      position: static;
    }

    body.landscape .sheet-grabber {
      position: absolute;
      right: 0;
      left: auto;
      top: 0;
      bottom: 0;
      width: 26px;
      height: auto;
      cursor: ew-resize;
    }

    body.landscape .sheet-grabber::before {
      width: 4px;
      height: 46px;
    }

    body.landscape .settings-tab {
      left: 12px;
      right: auto;
      top: 50%;
      bottom: auto;
      transform: translateY(-50%);

      width: 54px;
      height: 140px;
      max-width: none;

      border-radius: 12px 16px 16px 12px;
      padding: 12px 8px;
    }

    body.landscape .settings-tab .settings-tab-grabber {
      width: 4px;
      height: 44px;
    }

    body.landscape .settings-tab .settings-tab-label {
      flex-direction: column;
      gap: 6px;
      text-align: center;
    }

    body.landscape .settings-tab .settings-tab-chevron {
      transform: rotate(90deg);
    }

    body.landscape .settings-tab:active {
      transform: translateY(-50%) translateX(-1px) scale(0.99);
    }

    body.landscape .settings-tab.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-50%) translateX(-20px);
    }



    /* CountDown live display */
    .countdown-live {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      letter-spacing: 0.02em;
      font-size: 18px;
      font-weight: 750;
      color: #e0f2fe;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(56, 189, 248, 0.18);
      background: rgba(2, 6, 23, 0.20);
      box-sizing: border-box;
      min-width: 110px;
      text-align: center;
      white-space: nowrap;
    }

    .countdown-bar {
      height: 9px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.14);
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-sizing: border-box;
    }

    .countdown-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg,
        rgba(56, 189, 248, 0.95),
        rgba(244, 114, 182, 0.90));
      transition: width 0.10s linear;
      will-change: width;
    }

</style>
</head>
<body>
<canvas id="glcanvas"
        aria-label="3D tilt training sphere"
        role="img"></canvas>

<div id="handlesLayer" aria-hidden="true"></div>

<div id="overlay" aria-label="Tilt controls and readout">
  <div id="overlayHeader" class="overlay-header" aria-label="Settings header">
    <button type="button" id="sheetGrabber" class="sheet-grabber" aria-label="Drag to resize settings panel. Tap to expand/collapse. Drag toward the edge to close." aria-expanded="false" title="Drag to resize. Tap to expand/collapse. Drag toward the edge to close."></button>
    <div class="overlay-header-row">
      <div class="overlay-title-wrap">
        <div class="overlay-title">Tilt bands</div>
        <button type="button" id="activeBandPill" class="band-pill" aria-label="Active band (jump to bands)">
          <span class="band-pill-dot" aria-hidden="true"></span>
          <span id="activeBandPillLabel" class="band-pill-label">Band 1</span>
        </button>
      </div>
      <div class="overlay-header-actions">
        <button type="button" id="soundToggle" class="icon-chip" aria-label="Toggle sound">🔊</button>
        <button type="button" id="helpBtn" class="icon-chip" aria-label="Help" title="Help">?</button>
        <span class="range-status status-chip in-range" id="rangeStatus">IN RANGE</span>
        <button type="button" id="overlayCloseBtn" class="icon-chip icon-collapse" aria-label="Collapse settings" title="Collapse">▾</button>
      </div>
    </div>
  </div>

    <div id="overlayNav" class="overlay-nav" role="navigation" aria-label="Settings sections">
      <button type="button" class="nav-tab active" data-target="sectionBands" aria-label="Jump to Bands">🧩 Bands</button>
      <button type="button" class="nav-tab" data-target="sectionBand" aria-label="Jump to Band shape">⬡ Shape</button>
      <button type="button" class="nav-tab" data-target="sectionGraphics" aria-label="Jump to Graphics">✨ Gfx</button>
      <button type="button" class="nav-tab" data-target="sectionInfo" aria-label="Jump to Info">ⓘ Info</button>
    </div>

  <div id="overlayBody" class="overlay-body">
    <div id="readouts" class="panel-card">
      <div class="panel-card-title">Readout</div>
      <div class="row">Screen: <span id="screenValue">0°</span></div>
      <div class="row" id="bandText">Band: [-1.0°, 1.0°] on Pitch only</div>
            <div class="row">BeepCount: <span id="inBandTimerReadout">Off</span></div>
      <div class="row">CountDown: <span id="countDownReadout">Off</span></div>
<div class="row" id="currentText">Current: n/a</div>
    </div>


    <details class="panel-section" id="sectionTimer" open>
      <summary>
        <span class="summary-title">BeepCount</span>
        <span class="summary-sub" id="timerSummary">off</span>
      </summary>
      <div class="section-body">
        <div class="row band-meta" style="align-items:flex-end;">
          <label class="toggle-chip" title="Optional: beep while you are inside the active band">
            <input type="checkbox" id="timerEnabledCheckbox">
            <span>BeepCount</span>
          </label>

          <label class="field" style="flex:1; min-width: 150px;">
            Interval (s)
            <input type="number" id="timerIntervalInput" min="0.10" step="0.05" value="1.00" inputmode="decimal" aria-label="Beep interval in seconds">
          </label>

          <button type="button" id="timerResetBtn" class="btn btn-ghost">Reset</button>
        </div>

        <div class="row" style="gap:6px; flex-wrap:wrap;" aria-label="Beep interval presets">
          <button type="button" class="btn btn-secondary" data-timer-preset="0.333">⅓s</button>
          <button type="button" class="btn btn-secondary" data-timer-preset="0.5">½s</button>
          <button type="button" class="btn btn-secondary" data-timer-preset="1">1s</button>
          <button type="button" class="btn btn-secondary" data-timer-preset="2">2s</button>
        </div>

        <div class="row" style="color:#94a3b8; font-size:11px; line-height:1.35;">
          When you enter a band, BeepCount resets to 0 and starts. While you stay in-range, it beeps every <span id="timerIntervalLabel">1.00s</span>.
        </div>
      </div>
    </details>


    <details class="panel-section" id="sectionCountDown">
      <summary>
        <span class="summary-title">CountDown</span>
        <span class="summary-sub" id="countDownSummary">off</span>
      </summary>
      <div class="section-body">
        <div class="row band-meta" style="align-items:flex-end;">
          <label class="toggle-chip" title="Optional: notify when you have stayed inside the active band for the goal time">
            <input type="checkbox" id="countDownEnabledCheckbox">
            <span>CountDown</span>
          </label>

          <label class="field" style="flex:1; min-width: 150px;">
            Goal (s)
            <input type="number" id="countDownGoalInput" min="0.50" step="0.10" value="10.0" inputmode="decimal" aria-label="Goal time in seconds">
          </label>

          <button type="button" id="countDownResetBtn" class="btn btn-ghost">Reset</button>
        </div>

        <div class="row" style="gap:6px; flex-wrap:wrap;" aria-label="Goal presets">
          <button type="button" class="btn btn-secondary" data-countdown-preset="5">5s</button>
          <button type="button" class="btn btn-secondary" data-countdown-preset="10">10s</button>
          <button type="button" class="btn btn-secondary" data-countdown-preset="20">20s</button>
          <button type="button" class="btn btn-secondary" data-countdown-preset="60">60s</button>
        </div>

        <div class="row" style="gap:10px; flex-wrap:wrap; align-items:center; margin-top:6px;">
          <label class="toggle-chip" title="Speak the remaining whole seconds while counting down (uses your device text-to-speech).">
            <input type="checkbox" id="countDownVoiceCheckbox" checked>
            <span>Voice numbers</span>
          </label>
          <span style="color:#94a3b8; font-size:11px;">(whole seconds)</span>
        </div>


        <div class="row" style="align-items:center; gap:10px; margin-top:8px;">
          <div class="countdown-live" id="countDownLive">00:00.0</div>
          <div class="countdown-bar" style="flex:1;">
            <div class="countdown-fill" id="countDownProgress"></div>
          </div>
        </div>

        <div class="row" style="color:#94a3b8; font-size:11px; line-height:1.35;">
          When you enter the <b>active band</b>, it starts counting down from the Goal.
          Once it reaches 0, you will get a short notification beep (and a status message). If <b>Voice numbers</b> is enabled, it will speak the remaining seconds while counting down.
        </div>
      </div>
    </details>

    <details class="panel-section" id="sectionBands" open>
      <summary>
        <span class="summary-title">Bands</span>
        <span class="summary-sub" id="bandsSummary"></span>
      </summary>
      <div class="section-body">
        <div class="row">
          <div id="bandChips" class="mode-chips band-chips band-chip-strip" aria-label="Bands (quick)"></div>
        </div>

        <div class="row">
          <div id="bandList" class="band-list" aria-label="Band list"></div>
        </div>

        <div class="row">
          <div class="multi-slider-actions band-actions" aria-label="Band actions">
            <button type="button" id="addBandBtn" class="btn btn-primary">＋ Band</button>
            <button type="button" id="dupBandBtn" class="btn btn-secondary">⎘ Duplicate</button>
            <button type="button" id="removeBandBtn" class="btn btn-danger">🗑 Remove</button>
            <button type="button" id="moveBandUpBtn" class="btn btn-ghost btn-icon" title="Move band up" aria-label="Move band up">↑</button>
            <button type="button" id="moveBandDownBtn" class="btn btn-ghost btn-icon" title="Move band down" aria-label="Move band down">↓</button>
          </div>
        </div>

        <div class="row band-meta">
          <label class="field">
            Name
            <input type="text" id="bandNameInput" placeholder="(optional)" maxlength="24" autocomplete="off" autocapitalize="off">
          </label>
          <label class="field">
            Color
            <input type="color" id="bandColorInput" value="#38bdf8" aria-label="Band color">
          </label>
          <label class="toggle-chip" title="Toggle whether this band is active">
            <input type="checkbox" id="bandEnabledCheckbox" checked>
            <span>Enabled</span>
          </label>
        </div>
      </div>
    </details>

    <details class="panel-section" id="sectionBand" open>
      <summary>
        <span class="summary-title">Band shape</span>
        <span class="summary-sub" id="bandSummary"></span>
      </summary>

      <div class="section-body">
        <div id="exercise">
          <div class="row">
            <div id="modeChips" class="mode-chips segmented">
              <button type="button" class="mode-chip active" data-mode="pitch">Pitch</button>
              <button type="button" class="mode-chip" data-mode="roll">Roll</button>
              <button type="button" class="mode-chip" data-mode="pitchOrRoll">OR</button>
              <button type="button" class="mode-chip" data-mode="pitchAndRoll">AND</button>
              <button type="button" class="mode-chip" data-mode="circle">Circle</button>
              <button type="button" class="mode-chip" data-mode="polygon">Polygon</button>
            </div>
            <select id="monitorSelect" name="monitorSelect" style="display:none">
              <option value="pitch" selected>Pitch only</option>
              <option value="roll">Roll only</option>
              <option value="pitchOrRoll">Pitch OR Roll</option>
              <option value="pitchAndRoll">Pitch AND Roll</option>
              <option value="circle">Circle</option>
              <option value="polygon">Polygon</option>
            </select>
          </div>

          <div class="row">
            <div class="slider-label" style="width:100%">
              <span id="bandSizeTitle">Ranges</span>
              <span id="bandSizeValue"></span>
            </div>
            <div id="bandMultiSlider" class="multi-slider" aria-label="Band ranges slider">
              <div class="track"></div>
            </div>
            <div class="multi-slider-actions" aria-label="Range slider actions">
              <button type="button" id="addRangeBtn" class="btn btn-secondary">＋ Range</button>
              <button type="button" id="removeRangeBtn" class="btn btn-secondary">－ Range</button>
              <button type="button" id="resetRangesBtn" class="btn btn-ghost">Reset</button>
            </div>
          </div>

          <div class="row center-controls" id="rowCenter">
            <button type="button" id="centerFromCurrentBtn" class="btn btn-ghost">Use current tilt</button>
            <button type="button" id="centerFromCameraBtn" class="btn btn-ghost">Use current view</button>
            <button type="button" id="centerResetBtn" class="btn btn-ghost">Reset</button>
            <span id="centerSummary">@ P 0.0°, R 0.0°</span>
          </div>

          <div class="row advanced-row" id="rowPolySides">
            <label class="slider-label">
              Sides
              <input type="range" id="polySidesSlider" min="3" max="12" step="1" value="3">
              <span id="polySidesValue">3‑gon</span>
            </label>
          </div>

          <div class="row advanced-row" id="rowBandRotation">
            <label class="slider-label">
              Rotation
              <input type="range" id="bandRotationSlider" min="0" max="360" step="1" value="0">
              <span id="bandRotationValue">0°</span>
            </label>
          </div>

          <div class="row advanced-row" id="rowCamAttachYawOffset">
            <label class="slider-label">
              View↔Tilt offset
              <input type="range" id="camAttachYawOffsetSlider" min="0" max="360" step="1" value="0">
              <span id="camAttachYawOffsetValue">0°</span>
            </label>
          </div>

          <div style="display:none">
            <input type="number" id="minAngle"     value="-1" step="1">
            <input type="number" id="maxAngle"     value="1"  step="1">
            <input type="number" id="centerPitch"  value="0"  step="1">
            <input type="number" id="centerRoll"   value="0"  step="1">
            <input type="number" id="polySides"    value="3"  min="3" max="24" step="1">
            <input type="number" id="bandRotation" value="0"  min="0" max="360" step="1">
            <input type="checkbox" id="soundCheckbox">
          </div>
        </div>
      </div>
    </details>

    
    <details class="panel-section" id="sectionGraphics">
      <summary>
        <span class="summary-title">Graphics</span>
        <span class="summary-sub" id="gfxSummary">Balanced</span>
      </summary>
      <div class="section-body">
        <div class="row band-meta">
          <label class="field">
            Quality
            <select id="gfxQualitySelect" aria-label="Graphics quality">
              <option value="high">High</option>
              <option value="balanced" selected>Balanced</option>
              <option value="performance">Performance</option>
            </select>
          </label>

          <label class="field" style="flex:1; min-width: 180px;">
            Resolution
            <input type="range" id="gfxResScale" min="0.60" max="1.00" step="0.05" value="0.85" aria-label="Render resolution scale">
            <span id="gfxResScaleValue">85%</span>
          </label>
        </div>

        <div class="row" style="color:#94a3b8; font-size:11px; line-height:1.35;">
          Tip: If it feels choppy, lower <b>Resolution</b> or switch to <b>Performance</b>.
        </div>
      </div>
    </details>

<details class="panel-section" id="sectionInfo">
      <summary>
        <span class="summary-title">Info</span>
        <span class="summary-sub">debug</span>
      </summary>
      <div class="section-body">
        <div class="row patch-centers" id="patchCentersText"></div>
        <div class="row patch-centers" id="camCrossText"></div>
        <div class="row patch-centers" id="gravCrossText"></div>
      </div>
    </details>
  </div>
</div>


<!-- Panel launcher -->
<button id="settingsToggle"
        class="settings-tab"
        aria-label="Open settings panel"
        aria-expanded="false">
  <span class="settings-tab-grabber" aria-hidden="true"></span>
  <span class="settings-tab-label">
    <span class="settings-tab-icon" aria-hidden="true">⚙</span>
    <span>Settings</span>
    <span class="settings-tab-chevron" aria-hidden="true">▲</span>
  </span>
</button>

<div id="status" role="status" aria-live="polite">
  Tap anywhere to enable sensors and audio. Drag to rotate. Pinch to zoom. Double‑tap to lock/unlock View to Tilt. Long‑press to set band center to View.
</div>

<div class="axis-label" id="labelPosX">+X</div>
<div class="axis-label" id="labelNegX">-X</div>
<div class="axis-label" id="labelPosY">+Y</div>
<div class="axis-label" id="labelNegY">-Y</div>
<div class="axis-label" id="labelPosZ">+Z</div>
<div class="axis-label" id="labelNegZ">-Z</div>

<!-- Tilt readouts attached to crosshairs -->
<div class="tilt-label" id="gravityTiltLabel"></div>
<div class="tilt-label" id="cameraTiltLabel"></div>

<script>
(() => {
  'use strict';

  // === DOM references =======================================================
  const canvas   = document.getElementById('glcanvas');
  const statusEl = document.getElementById('status');

  const overlayEl   = document.getElementById('overlay');
  const handlesLayer = document.getElementById('handlesLayer');
  const overlayBody = document.getElementById('overlayBody');
  const settingsToggle = document.getElementById('settingsToggle');
  const overlayNav = document.getElementById('overlayNav');
  const navTabs = overlayNav ? Array.from(overlayNav.querySelectorAll('.nav-tab')) : [];
  const sheetGrabber = document.getElementById('sheetGrabber');
  const activeBandPill = document.getElementById('activeBandPill');
  const activeBandPillLabel = document.getElementById('activeBandPillLabel');

  const screenEl  = document.getElementById('screenValue');

  const monitorSelect    = document.getElementById('monitorSelect');
  const minAngleInput    = document.getElementById('minAngle');
  const maxAngleInput    = document.getElementById('maxAngle');
  const centerPitchInput = document.getElementById('centerPitch');
  const centerRollInput  = document.getElementById('centerRoll');
  const polySidesInput   = document.getElementById('polySides');
  const bandRotationInput= document.getElementById('bandRotation');
  const soundCheckbox    = document.getElementById('soundCheckbox');
  const bandText         = document.getElementById('bandText');
  const currentText      = document.getElementById('currentText');
  const rangeStatus      = document.getElementById('rangeStatus');

  const inBandTimerReadout  = document.getElementById('inBandTimerReadout');
  const timerSummaryEl      = document.getElementById('timerSummary');
  const timerEnabledCheckbox= document.getElementById('timerEnabledCheckbox');
  const timerIntervalInput  = document.getElementById('timerIntervalInput');
  const timerIntervalLabel  = document.getElementById('timerIntervalLabel');
  const timerResetBtn       = document.getElementById('timerResetBtn');

  const countDownReadout      = document.getElementById('countDownReadout');
  const countDownSummaryEl    = document.getElementById('countDownSummary');
  const countDownEnabledCheckbox = document.getElementById('countDownEnabledCheckbox');
  const countDownGoalInput    = document.getElementById('countDownGoalInput');
  const countDownResetBtn     = document.getElementById('countDownResetBtn');
  const countDownVoiceCheckbox = document.getElementById('countDownVoiceCheckbox');

  const countDownLive         = document.getElementById('countDownLive');
  const countDownProgress     = document.getElementById('countDownProgress');



  const rowCenter      = document.getElementById('rowCenter');
  const rowPolySides   = document.getElementById('rowPolySides');
  const rowBandRotation= document.getElementById('rowBandRotation');

  const modeChipsContainer   = document.getElementById('modeChips');
  const bandChipsContainer   = document.getElementById('bandChips');
  const bandListContainer    = document.getElementById('bandList');
  const addBandBtn           = document.getElementById('addBandBtn');
  const dupBandBtn           = document.getElementById('dupBandBtn');
  const removeBandBtn        = document.getElementById('removeBandBtn');
  const moveBandUpBtn        = document.getElementById('moveBandUpBtn');
  const moveBandDownBtn      = document.getElementById('moveBandDownBtn');
  const bandNameInput        = document.getElementById('bandNameInput');
  const bandColorInput       = document.getElementById('bandColorInput');
  const overlayCloseBtn      = document.getElementById('overlayCloseBtn');
  const bandsSummaryEl       = document.getElementById('bandsSummary');
  const bandSummaryEl        = document.getElementById('bandSummary');
  const bandEnabledCheckbox  = document.getElementById('bandEnabledCheckbox');
  const bandMultiSlider      = document.getElementById('bandMultiSlider');
  const addRangeBtn          = document.getElementById('addRangeBtn');
  const removeRangeBtn       = document.getElementById('removeRangeBtn');
  const resetRangesBtn       = document.getElementById('resetRangesBtn');
  const bandSizeValue        = document.getElementById('bandSizeValue');
  const bandSizeTitle        = document.getElementById('bandSizeTitle');
  const patchCentersText     = document.getElementById('patchCentersText');
  const camCrossText        = document.getElementById('camCrossText');
  const gravCrossText       = document.getElementById('gravCrossText');
  const centerFromCurrentBtn = document.getElementById('centerFromCurrentBtn');
  const centerFromCameraBtn  = document.getElementById('centerFromCameraBtn');
  const centerResetBtn       = document.getElementById('centerResetBtn');
  const centerSummary        = document.getElementById('centerSummary');
  const polySidesSlider      = document.getElementById('polySidesSlider');
  const polySidesValue       = document.getElementById('polySidesValue');
  const bandRotationSlider   = document.getElementById('bandRotationSlider');
  const bandRotationValue    = document.getElementById('bandRotationValue');
  const camAttachYawOffsetSlider = document.getElementById('camAttachYawOffsetSlider');
  const camAttachYawOffsetValue  = document.getElementById('camAttachYawOffsetValue');
  const soundToggle          = document.getElementById('soundToggle');
  const gfxSummaryEl        = document.getElementById('gfxSummary');
  const gfxQualitySelect    = document.getElementById('gfxQualitySelect');
  const gfxResScaleSlider   = document.getElementById('gfxResScale');
  const gfxResScaleValue    = document.getElementById('gfxResScaleValue');


  const labelPosX = document.getElementById('labelPosX');
  const labelNegX = document.getElementById('labelNegX');
  const labelPosY = document.getElementById('labelPosY');
  const labelNegY = document.getElementById('labelNegY');
  const labelPosZ = document.getElementById('labelPosZ');
  const labelNegZ = document.getElementById('labelNegZ');

  const gravityTiltLabel = document.getElementById('gravityTiltLabel');
  const cameraTiltLabel  = document.getElementById('cameraTiltLabel');

// Smooth label position transitions on camera attach/detach.
// When the camera is attached, the two crosses are aligned and the label-placement
// solver often "docks" one of the chips to the side. On detach, the target position
// can jump immediately. We tween that jump so the chip glides instead of snapping.
const LABEL_POS_TWEEN_MS = 260;
const labelPosTween = {
  grav: { has:false, x:0, y:0, active:false, t0:0, dur:LABEL_POS_TWEEN_MS, startX:0, startY:0 },
  cam:  { has:false, x:0, y:0, active:false, t0:0, dur:LABEL_POS_TWEEN_MS, startX:0, startY:0 },
};

// When the gravity + camera crosses converge (e.g. while attaching), their screen-space
// separation can become extremely small. A naive "if dist==0 choose a new direction"
// fallback causes a visible snap right at alignment. Keep the last stable separation
// direction so placement stays continuous, and let the solver smoothly dock as needed.
const labelSepDirState = { has:false, x:1, y:0 };

function startLabelPosTween(which) {
  const st = labelPosTween[which];
  if (!st) return;
  st.active = true;
  st.t0 = performance.now();
  st.dur = LABEL_POS_TWEEN_MS;
  st.startX = st.x;
  st.startY = st.y;
}

function tweenLabelPos(which, tx, ty) {
  const st = labelPosTween[which];
  if (!st || !Number.isFinite(tx) || !Number.isFinite(ty)) return { x: tx, y: ty };

  if (!st.has) {
    st.has = true;
    st.x = tx; st.y = ty;
    st.active = false;
    return { x: tx, y: ty };
  }

  if (!st.active) {
    st.x = tx; st.y = ty;
    return { x: tx, y: ty };
  }

  const now = performance.now();
  let t = (now - st.t0) / Math.max(1, st.dur);
  if (t >= 1) {
    st.active = false;
    st.x = tx; st.y = ty;
    return { x: tx, y: ty };
  }
  if (t < 0) t = 0;

  // smoothstep for ease-in-out
  const u = t * t * (3 - 2 * t);
  const x = st.startX + (tx - st.startX) * u;
  const y = st.startY + (ty - st.startY) * u;

  st.x = x; st.y = y;
  return { x, y };
}


  // When the camera crosshair gets very close to the gravity (tilt) crosshair,
  // the camera label intentionally fades/merges to avoid overlap.
  // We keep the camera "Rot" value available by showing it inside the gravity
  // label during that merge.
  let camToGravMergeFactor = 0; // 0..1 (0 = far, 1 = fully merged)
  // Smooth width changes for the crosshair labels (one-line "chips").
  // When their content grows/shrinks (e.g., Rot appears/disappears), animate
  // the label width instead of snapping.
    // Smooth width changes for the crosshair labels (one-line "chips").
  // When their content grows/shrinks (e.g., Rot appears/disappears), animate
  // the label width instead of snapping.
  let tiltLabelMeasureEl = null;

  function getTiltLabelMeasureEl() {
    if (tiltLabelMeasureEl) return tiltLabelMeasureEl;
    const m = document.createElement('div');
    m.className = 'tilt-label tilt-label-measure';
    m.setAttribute('aria-hidden', 'true');
    document.body.appendChild(m);
    tiltLabelMeasureEl = m;
    return m;
  }

  function computeTiltLabelKey(content, asHtml) {
    const s = String(content);
    if (!asHtml) return String(s.length);
    // Visible-length estimate: strip tags (good enough because we use tabular nums)
    return String(s.replace(/<[^>]*>/g, '').length);
  }

  function measureTiltLabelWidth(el, content, asHtml) {
    const m = getTiltLabelMeasureEl();

    // Ensure measurer isn't constrained
    m.style.width = 'auto';

    // Match typography closely
    const cs = getComputedStyle(el);
    m.style.font = cs.font;
    m.style.letterSpacing = cs.letterSpacing;

    if (asHtml) m.innerHTML = String(content);
    else m.textContent = String(content);

    return m.getBoundingClientRect().width;
  }

  function setTiltLabelContentAnimated(el, content, asHtml) {
    if (!el) return;
    const useHtml = !!asHtml;
    const next = String(content);

    const prev = el.dataset.tiltLast || '';
    const prevIsHtml = (el.dataset.tiltIsHtml === '1');
    if (prev === next && prevIsHtml === useHtml) return;

    const prevKey = el.dataset.tiltKey || '';
    const nextKey = computeTiltLabelKey(next, useHtml);

    // Lock current width so subsequent updates can animate.
    // (Without an explicit pixel width, 'auto' -> px cannot transition.)
    if (el.dataset.tiltWidthLocked !== '1') {
      const w0 = el.getBoundingClientRect().width || el.offsetWidth || 0;
      if (w0 > 0) {
        el.style.width = w0.toFixed(1) + 'px';
        el.dataset.tiltWidthLocked = '1';
      }
    }

    // Update content.
    if (useHtml) el.innerHTML = next;
    else el.textContent = next;

    el.dataset.tiltLast = next;
    el.dataset.tiltIsHtml = useHtml ? '1' : '0';
    el.dataset.tiltKey = nextKey;

    // Only recompute width when the visible-length key changes.
    // This avoids reflow every frame while numbers tick (tabular-nums keeps glyph widths stable).
    if (el.dataset.tiltWidthLocked !== '1') return;
    if (prevKey !== '' && nextKey === prevKey) return;

    const targetW = measureTiltLabelWidth(el, next, useHtml);
    if (!(targetW > 0)) return;

    const curW = parseFloat(el.style.width);
    if (Number.isFinite(curW) && Math.abs(targetW - curW) < 0.75) return;

    el.style.width = targetW.toFixed(1) + 'px';
  }

  function setTiltLabelTextAnimated(el, text) {
    setTiltLabelContentAnimated(el, String(text), false);
  }
  function setTiltLabelHtmlAnimated(el, html) {
    setTiltLabelContentAnimated(el, String(html), true);
  }


  function setStatus(text) {
    statusEl.textContent = text;
  }

  // Short-lived status message (won't overwrite newer messages).
  function flashStatus(text, ms) {
    const duration = (typeof ms === 'number' && ms > 0) ? ms : 1200;
    const prev = statusEl.textContent;
    setStatus(text);
    setTimeout(() => {
      if (statusEl.textContent === text) setStatus(prev);
    }, duration);
  }

  // Alias used by some earlier refactors.
  function flashMessage(text, ms) {
    flashStatus(text, ms);
  }



  // === Graphics quality =====================================================
  // Note: cosmetics (starfield drift / glow / panel blur) can be expensive on mobile.
  // We expose a simple preset + a resolution scale (dynamic DPR multiplier).
  const DEFAULT_GFX = {
    quality: 'balanced', // 'high' | 'balanced' | 'performance'
    renderScale: 0.85    // multiplies DPR (after cap)
  };

  let gfxQuality = DEFAULT_GFX.quality;
  let gfxRenderScale = DEFAULT_GFX.renderScale;

  // Derived per preset
  let gfxDprCap = 2.0;
  let shaderQuality = 1.0; // 0=perf, 1=balanced, 2=high

  // Throttle DOM-heavy UI updates (handles/labels) to improve FPS on slower devices.
  let uiUpdateIntervalMs = 33;
  let lastUiUpdateMs = -Infinity;

  function applyGfxPreset(preset, opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const keepScale = !!options.keepScale;

    const q = (preset === 'high' || preset === 'performance') ? preset : 'balanced';
    gfxQuality = q;

    // Defaults per preset
    let dprCap = 2.0;
    let resScale = 0.85;
    let sQuality = 1.0;
    let uiMs = 33;

    if (q === 'high') {
      dprCap = 2.0;
      resScale = 1.0;
      sQuality = 2.0;
      uiMs = 16;
    } else if (q === 'performance') {
      dprCap = 1.25;
      resScale = 0.70;
      sQuality = 0.0;
      uiMs = 50;
    }

    gfxDprCap = dprCap;
    shaderQuality = sQuality;
    uiUpdateIntervalMs = uiMs;

    if (!keepScale) {
      gfxRenderScale = resScale;
      if (gfxResScaleSlider) gfxResScaleSlider.value = String(resScale);
    }

    // Update body FX class (controls expensive CSS effects)
    document.body.classList.remove('fx-high','fx-balanced','fx-performance');
    document.body.classList.add(q === 'high' ? 'fx-high' : (q === 'performance' ? 'fx-performance' : 'fx-balanced'));

    // UI text
    if (gfxQualitySelect) gfxQualitySelect.value = q;
    if (gfxSummaryEl) gfxSummaryEl.textContent = (q === 'high') ? 'High' : (q === 'performance') ? 'Performance' : 'Balanced';
    if (gfxResScaleValue) gfxResScaleValue.textContent = Math.round(gfxRenderScale * 100) + '%';

    // Resize render target
    resizeCanvas();
  }

  function applyGfxScaleFromUI() {
    if (!gfxResScaleSlider) return;
    let s = parseFloat(gfxResScaleSlider.value);
    if (!Number.isFinite(s)) s = DEFAULT_GFX.renderScale;
    gfxRenderScale = Math.max(0.5, Math.min(1.0, s));
    if (gfxResScaleValue) gfxResScaleValue.textContent = Math.round(gfxRenderScale * 100) + '%';
    resizeCanvas();
  }

  // === WebGL setup ==========================================================
  const gl =
    canvas.getContext('webgl', { antialias: true, alpha: true }) ||
    canvas.getContext('experimental-webgl');

  if (!gl) {
    setStatus('WebGL not supported in this browser.');
    return;
  }

  // --- vec helpers ----------------------------------------------------------
  function length3(v) {
    return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  }
  function normalize3(v) {
    const len = length3(v);
    if (len > 1e-6) return [v[0]/len, v[1]/len, v[2]/len];
    return [0,0,0];
  }
  function dot3(a, b) {
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  }
  function cross3(a, b) {
    return [
      a[1]*b[2] - a[2]*b[1],
      a[2]*b[0] - a[0]*b[2],
      a[0]*b[1] - a[1]*b[0]
    ];
  }
  function sub3(a, b) {
    return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
  }
  function add3(a, b) {
    return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
  }
  function scale3(v, s) {
    return [v[0]*s, v[1]*s, v[2]*s];
  }

  // Alias: multiply a vec3 by a scalar (older code used mul3()).
  function mul3(v, s) {
    return scale3(v, s);
  }

  function projectOntoTangent(axis, centerDir) {
    const d = dot3(axis, centerDir);
    const proj = [
      axis[0] - centerDir[0]*d,
      axis[1] - centerDir[1]*d,
      axis[2] - centerDir[2]*d
    ];
    const len = length3(proj);
    if (len < 1e-5) return null;
    return [proj[0]/len, proj[1]/len, proj[2]/len];
  }
  function degToRad(d) {
    return d * Math.PI / 180;
  }
  function radToDeg(r) {
    return r * 180 / Math.PI;
  }
  function lerp(a, b, t) {
    return a + (b - a) * t;
  }
  function shortestAngleDiff(a, b) {
    let diff = b - a;
    while (diff > Math.PI)  diff -= Math.PI*2;
    while (diff < -Math.PI) diff += Math.PI*2;
    return diff;
  }
  function lerpAngle(a, b, t) {
    return a + shortestAngleDiff(a, b) * t;
  }

  // --- rotation helpers (used for stable polygon recentering) -------------
  // Rodrigues' rotation formula: rotate vector v around unit axis by angle (radians).
  function rotateAroundAxis(v, axis, angle) {
    const ax = axis[0], ay = axis[1], az = axis[2];
    const vx = v[0], vy = v[1], vz = v[2];
    const c = Math.cos(angle);
    const s = Math.sin(angle);

    // cross(axis, v)
    const cx = ay * vz - az * vy;
    const cy = az * vx - ax * vz;
    const cz = ax * vy - ay * vx;

    const d = ax * vx + ay * vy + az * vz;

    return [
      vx * c + cx * s + ax * d * (1 - c),
      vy * c + cy * s + ay * d * (1 - c),
      vz * c + cz * s + az * d * (1 - c)
    ];
  }

  // Minimal-axis/angle rotation that maps unit vector a -> unit vector b.
  // For non-antipodal vectors, axis = normalize(cross(a,b)), angle = atan2(|cross|, dot).
  function rotationFromTo(aIn, bIn) {
    const a = normalize3(aIn);
    const b = normalize3(bIn);

    const v = cross3(a, b);
    const s = length3(v);
    const c = clamp(dot3(a, b), -1, 1);

    if (s < 1e-8) {
      // a and b are (almost) parallel or antiparallel.
      if (c > 0.0) {
        return { axis: [1, 0, 0], angle: 0.0 };
      }
      // Antiparallel: pick any axis orthogonal to a.
      let axis = cross3(a, [1, 0, 0]);
      if (length3(axis) < 1e-6) axis = cross3(a, [0, 1, 0]);
      axis = normalize3(axis);
      return { axis, angle: Math.PI };
    }

    const axis = [v[0] / s, v[1] / s, v[2] / s];
    const angle = Math.atan2(s, c);
    return { axis, angle };
  }


  // --- angle wrapping helpers -------------------------------------------
  function wrap180(deg) {
    let d = deg;
    d = ((d + 180) % 360 + 360) % 360 - 180;
    return d;
  }

  

  function wrapPi(rad) {
    let r = rad;
    const twoPi = Math.PI * 2;
    r = ((r + Math.PI) % twoPi + twoPi) % twoPi - Math.PI;
    return r;
  }

function wrap360(deg) {
    let d = deg;
    d = ((d % 360) + 360) % 360;
    return d;
  }

  // === Multi-range (multi-handle) band definitions ========================
  // Stored as sorted handle positions per mode. Every pair [h0,h1], [h2,h3]...
  // defines an "in-range" stripe. This enables rings/stripes in *any* mode.
  const MAX_RANGES = 32; // shader limit (MAX_RANGES stripes => 2*MAX_RANGES handles)

  const DEFAULT_HANDLES_BY_MODE = {
    pitch:        [-1, 1],
    roll:         [-1, 1],
    pitchOrRoll:  [0, 1],
    pitchAndRoll: [0, 1],
    circle:       [1, 2],
    polygon:      [0, 1]
  };

  // === Band state ===========================================================
  const BAND_COLOR_PALETTE = [
    [0.16, 0.60, 1.00], // cyan
    [1.00, 0.45, 0.45], // red
    [0.34, 0.92, 0.58], // green
    [1.00, 0.55, 0.90], // pink
    [0.98, 0.83, 0.35], // yellow
    [0.56, 0.73, 1.00]  // light blue
  ];

  let bands = [];
  let activeBandIndex = 0;

  // Active-band working state (points at the selected band's objects / values).
  // NOTE: these are reassigned when you switch bands.
  let handlesByMode = JSON.parse(JSON.stringify(DEFAULT_HANDLES_BY_MODE));


  function getSliderSpec(modeStr) {
    // Domains are degrees.
    switch (modeStr) {
      case 'pitch':
        return { min: -90, max: 90, step: 1 };
      case 'roll':
        return { min: -180, max: 180, step: 1 };
      case 'pitchOrRoll':
      case 'pitchAndRoll':
        // OR/AND modes use absolute distances from the user-set center (see shader).
        // Negative range values are not meaningful, so clamp to 0..180.
        return { min: 0, max: 180, step: 1 };
      case 'circle':
        // Radius is physically 0..180, but allowing up to 360 lets you intentionally "include all".
        // Allow 0 so you can make a filled disk (0..R) instead of being forced into a ring (>=1..R).
        return { min: 0, max: 360, step: 1 };
      case 'polygon':
        // Polygon 'shape' range is a radial scale (like circle radius).
        // Negative values are not meaningful (the polygon gauge is always >= 0),
        // so clamp the UI to 0..360 for consistency with circle mode.
        return { min: 0, max: 360, step: 1 };
      default:
        return { min: -90, max: 90, step: 1 };
    }
  }

  function clamp(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v));
  }

  function snapToStep(v, step) {
    if (!(step > 0)) return v;
    return Math.round(v / step) * step;
  }

  function normalizeHandlesForMode(modeStr, handles) {
    const spec = getSliderSpec(modeStr);
    const step = spec.step || 1;

    // Parse numeric, snap, clamp.
    let h = (Array.isArray(handles) ? handles : []).map(x => {
      const n = (typeof x === 'number') ? x : parseFloat(x);
      const v = Number.isFinite(n) ? n : 0;
      return clamp(snapToStep(v, step), spec.min, spec.max);
    });

    // Ensure even count (pairs). Drop trailing odd handle.
    if (h.length % 2 === 1) h = h.slice(0, h.length - 1);

    // Ensure at least one pair.
    if (h.length < 2) {
      h = DEFAULT_HANDLES_BY_MODE[modeStr]
        ? DEFAULT_HANDLES_BY_MODE[modeStr].slice()
        : [-1, 1];
    }

    // Clamp again after defaults.
    h = h.map(v => clamp(snapToStep(v, step), spec.min, spec.max));
    if (h.length % 2 === 1) h = h.slice(0, h.length - 1);

    // Hard cap to shader limit.
    const maxHandles = MAX_RANGES * 2;
    if (h.length > maxHandles) h = h.slice(0, maxHandles);

    // OR/AND: we intentionally keep a single one-sided range [0..hi].
    // Allowing an inner boundary (lo > 0) is both unintuitive here and can
    // create visual artifacts ("splitting"). Extra ranges are redundant
    // because the union reduces to the largest hi.
    if (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll') {
      let hi = h.length ? h[h.length - 1] : 1;
      if (!Number.isFinite(hi)) hi = 1;
      hi = clamp(snapToStep(hi, step), spec.min, spec.max);
      return [0, hi];
    }

    // Polygon: keep explicit min/max pairs (allow overlaps).
    // This lets us adjust only the outer (or inner) boundary degrees when the
    // user stretches corners/edges, without breaking pairings.
    if (modeStr === 'polygon') {
      const pairs = [];
      for (let i = 0; i + 1 < h.length; i += 2) {
        let a = h[i];
        let b = h[i + 1];
        if (b < a) { const t = a; a = b; b = t; }
        if (b - a < step) b = clamp(a + step, spec.min, spec.max);
        pairs.push([a, b]);
      }
      // Stable presentation: sort ranges by their lower endpoint.
      pairs.sort((p, q) => p[0] - q[0]);
      h = [];
      for (const p of pairs) { h.push(p[0], p[1]); }
      return h;
    }

    // Other modes: keep strict ordering by sorting globally.
    h.sort((a, b) => a - b);
    return h;
  }

  function getHandles(modeStr) {
    const m = (modeStr && handlesByMode[modeStr]) ? modeStr : 'pitch';
    return (handlesByMode[m] || DEFAULT_HANDLES_BY_MODE[m] || [-1, 1]).slice();
  }

  function setHandles(modeStr, handles, opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const doSave = options.save !== false;
    const doUpdate = options.update !== false;
    const doRender = options.render !== false;

    const m = (modeStr && typeof modeStr === 'string') ? modeStr : 'pitch';
    handlesByMode[m] = normalizeHandlesForMode(m, handles);

    // Keep legacy min/max inputs in sync with the first stripe (helps any old logic + debugging).
    const h = handlesByMode[m];
    if (h.length >= 2) {
      minAngleInput.value = h[0];
      maxAngleInput.value = h[1];
    }

    if (doRender) renderMultiSlider();
    if (doSave) saveSettings();
    if (doUpdate) updateUI();
  }

  function getRanges(modeStr) {
    const h = getHandles(modeStr);
    const ranges = [];
    for (let i = 0; i + 1 < h.length; i += 2) {
      let a = h[i];
      let b = h[i + 1];
      if (b < a) { const t = a; a = b; b = t; }
      ranges.push({ min: a, max: b });
    }
    return ranges;
  }

  function valueInRangesLinear(v, ranges) {
    for (let i = 0; i < ranges.length; i++) {
      const r = ranges[i];
      if (v >= r.min && v <= r.max) return true;
    }
    return false;
  }

  function valueInRangesAngle360(vDeg, ranges) {
    for (let i = 0; i < ranges.length; i++) {
      const r = ranges[i];
      if (inAngleBand360(vDeg, r.min, r.max)) return true;
    }
    return false;
  }

  function rangesText(ranges) {
    if (!ranges || !ranges.length) return '(none)';
    return ranges.map(r => `[${r.min.toFixed(1)}°, ${r.max.toFixed(1)}°]`).join(' + ');
  }

  function bandPatchCentersText(modeStr, ranges, band) {
    if (!ranges || !ranges.length) return '';

    const parts = ranges.map(r => {
      const midRaw = 0.5 * (r.min + r.max);
      const mid = (modeStr === 'roll') ? wrap180(midRaw) : midRaw;
      return `[${r.min.toFixed(1)}..${r.max.toFixed(1)}]→${mid.toFixed(1)}°`;
    });

    if (modeStr === 'pitch')   return 'Band centers (pitch): ' + parts.join('  ');
    if (modeStr === 'roll')    return 'Band centers (roll): ' + parts.join('  ');
    if (modeStr === 'circle')  return 'Ring centers (radius): ' + parts.join('  ');
    if (modeStr === 'polygon') return 'Band centers (shape): ' + parts.join('  ');

    // OR / AND are relative to the @ centerPitch/centerRoll (shown below).
    if (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll') {
      return 'Band centers (offset from @): ' + parts.join('  ');
    }

    return 'Band centers: ' + parts.join('  ');
  }

  // ---- Range display helpers (keeps degree readouts correct when shapes are stretched) ----
  function fmtDeg(v, digits = 1) {
    if (!Number.isFinite(v)) return 'n/a';
    return v.toFixed(digits) + '°';
  }

  function computePolyStats(n, verts, planes) {
    const nn = Math.max(3, Math.min(MAX_POLY_SIDES_JS, (n | 0) || 3));

    let vMin = Infinity, vMax = 0;
    let dMin = Infinity, dMax = 0;

    if (verts && verts.length >= nn * 2) {
      for (let i = 0; i < nn; i++) {
        const x = +verts[i * 2] || 0;
        const y = +verts[i * 2 + 1] || 0;
        const r = Math.hypot(x, y);
        if (r < vMin) vMin = r;
        if (r > vMax) vMax = r;
      }
    } else {
      vMin = 0; vMax = 0;
    }

    if (planes && planes.length >= nn * 3) {
      for (let i = 0; i < nn; i++) {
        const d = Math.abs(+planes[i * 3 + 2] || 0);
        if (d < dMin) dMin = d;
        if (d > dMax) dMax = d;
      }
    } else {
      dMin = 0; dMax = 0;
    }

    if (!Number.isFinite(vMin)) vMin = 0;
    if (!Number.isFinite(vMax)) vMax = 0;
    if (!Number.isFinite(dMin)) dMin = 0;
    if (!Number.isFinite(dMax)) dMax = 0;

    return { vMin, vMax, dMin, dMax };
  

  // Keep polygon slider values aligned to actual geometry.
  // We store polygon verts (outer + inner) normalized so their farthest vertex is at radius 1,
  // and push the "real" degree scale into the polygon range endpoints:
  //   - odd indices (maxes) scale the OUTER polygon
  //   - even indices (mins) scale the INNER polygon
  //
  // This way, the slider numbers stay meaningful (degrees) even after stretching corners/edges.
  function normalizePolygonBandScaling(band) {
    if (!band) return;

    const n = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(band.polySides || 3)));
    const spec = getSliderSpec('polygon');
    const step = spec.step || 1;

    if (!band.handlesByMode) band.handlesByMode = {};
    let h = Array.isArray(band.handlesByMode.polygon)
      ? band.handlesByMode.polygon.slice()
      : (DEFAULT_HANDLES_BY_MODE.polygon ? DEFAULT_HANDLES_BY_MODE.polygon.slice() : [0, 1]);

    // Outer polygon normalization: scale verts down, scale range maxes up.
    const stO = computePolyStats(n, band.polyVerts);
    const sO = stO.vMax;
    if (Number.isFinite(sO) && sO > 1e-6 && Math.abs(sO - 1) > 1e-6) {
      for (let i = 0; i < n; i++) {
        band.polyVerts[i * 2]     /= sO;
        band.polyVerts[i * 2 + 1] /= sO;
      }
      for (let i = 1; i < h.length; i += 2) {
        const hi0 = Number.isFinite(h[i]) ? h[i] : 0;
        h[i] = hi0 * sO;
      }
    }

    // Inner polygon normalization: scale verts down, scale range mins up.
    const stI = computePolyStats(n, band.polyVertsInner);
    const sI = stI.vMax;
    if (Number.isFinite(sI) && sI > 1e-6 && Math.abs(sI - 1) > 1e-6) {
      for (let i = 0; i < n; i++) {
        band.polyVertsInner[i * 2]     /= sI;
        band.polyVertsInner[i * 2 + 1] /= sI;
      }
      for (let i = 0; i + 1 < h.length; i += 2) {
        const lo0 = Number.isFinite(h[i]) ? h[i] : spec.min;
        h[i] = lo0 * sI;
      }
    }

    // Clamp/clean up handles and ensure each pair is valid.
    band.handlesByMode.polygon = normalizeHandlesForMode('polygon', h);

    // Rebuild derived planes.
    rebuildPolyPlanes(n, band.polyVerts, band.polyPlanes);
    rebuildPolyPlanes(n, band.polyVertsInner, band.polyPlanesInner);
  }
}

  function getRangeDisplay(modeStr, ranges, cfg) {
    const rs = Array.isArray(ranges) ? ranges : [];
    const count = rs.length;

    if (count === 0) return { compact: '—', lines: [] };

    const sp = Math.max(1e-6, (cfg && Number.isFinite(cfg.rectScalePitch) ? cfg.rectScalePitch : rectScalePitch));
    const sr = Math.max(1e-6, (cfg && Number.isFinite(cfg.rectScaleRoll)  ? cfg.rectScaleRoll  : rectScaleRoll));
    const sx = Math.max(1e-6, (cfg && Number.isFinite(cfg.ellipseScaleX)  ? cfg.ellipseScaleX  : ellipseScaleX));
    const sy = Math.max(1e-6, (cfg && Number.isFinite(cfg.ellipseScaleY)  ? cfg.ellipseScaleY  : ellipseScaleY));

    // Polygon context
    let polySides = 3;
    if (cfg && Number.isFinite(cfg.polySides)) polySides = cfg.polySides | 0;
    else if (typeof polySidesInput !== 'undefined' && polySidesInput) polySides = (parseInt(polySidesInput.value, 10) || 3);
    polySides = Math.max(3, Math.min(MAX_POLY_SIDES_JS, polySides));

    const vO = (cfg && cfg.polyVerts) ? cfg.polyVerts : polyVerts;
    const pO = (cfg && cfg.polyPlanes) ? cfg.polyPlanes : polyPlanes;
    const vI = (cfg && cfg.polyVertsInner) ? cfg.polyVertsInner : polyVertsInner;
    const pI = (cfg && cfg.polyPlanesInner) ? cfg.polyPlanesInner : polyPlanesInner;

    const isEllipse = (modeStr === 'circle') && (Math.abs(sx - sy) > 1e-4);

    function loHi(r) {
      const a = Number.isFinite(r.min) ? r.min : 0;
      const b = Number.isFinite(r.max) ? r.max : 0;
      return { lo: Math.min(a, b), hi: Math.max(a, b) };
    }

    if (modeStr === 'pitch' || modeStr === 'roll') {
      const lines = rs.map(r => {
        const { lo, hi } = loHi(r);
        return `${fmtDeg(lo)}..${fmtDeg(hi)}`;
      });
      const compact = (count === 1) ? lines[0] : `${count} ranges`;
      return { compact, lines };
    }

    if (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll') {
      // NOTE: the min end is functionally locked to 0 in these modes to avoid splitting artifacts.
      const lines = rs.map(r => {
        const { hi } = loHi(r);
        const pHi = hi * sp;
        const rHi = hi * sr;
        return `${fmtDeg(0)}..${fmtDeg(hi)}  →  P≤${fmtDeg(pHi)}, R≤${fmtDeg(rHi)}`;
      });

      const hiMax = rs.reduce((acc, r) => Math.max(acc, loHi(r).hi), 0);
      const compact = (count === 1)
        ? `${fmtDeg(0)}..${fmtDeg(hiMax)}  (P≤${fmtDeg(hiMax * sp)}, R≤${fmtDeg(hiMax * sr)})`
        : `${count} ranges (P≤${fmtDeg(hiMax * sp)}, R≤${fmtDeg(hiMax * sr)})`;

      return { compact, lines };
    }

    if (modeStr === 'circle') {
      const lines = rs.map(r => {
        const { lo, hi } = loHi(r);
        if (!isEllipse) return `${fmtDeg(lo)}..${fmtDeg(hi)}`;
        const xLo = lo * sx, xHi = hi * sx;
        const yLo = lo * sy, yHi = hi * sy;
        return `${fmtDeg(lo)}..${fmtDeg(hi)}  →  X ${fmtDeg(xLo)}..${fmtDeg(xHi)}, Y ${fmtDeg(yLo)}..${fmtDeg(yHi)}`;
      });

      const hiMax = rs.reduce((acc, r) => Math.max(acc, loHi(r).hi), 0);
      const loMin = rs.reduce((acc, r) => Math.min(acc, loHi(r).lo), Infinity);

      let compact;
      if (!isEllipse) {
        compact = (count === 1) ? lines[0] : `${count} ranges`;
      } else {
        const outer = `X≤${fmtDeg(hiMax * sx)}, Y≤${fmtDeg(hiMax * sy)}`;
        if (count === 1 && loMin > 1e-6) {
          const inner = `inner X≤${fmtDeg(loMin * sx)}, Y≤${fmtDeg(loMin * sy)}`;
          compact = `${outer} (${inner})`;
        } else {
          compact = (count === 1) ? outer : `${count} ranges (${outer})`;
        }
      }

      return { compact, lines };
    }

    if (modeStr === 'polygon') {
      const stO = computePolyStats(polySides, vO, pO);
      const stI = computePolyStats(polySides, vI, pI);

      const lines = rs.map(r => {
        const { lo, hi } = loHi(r);

        const oEdgeLo = hi * stO.dMin;
        const oEdgeHi = hi * stO.dMax;
        const oVertLo = hi * stO.vMin;
        const oVertHi = hi * stO.vMax;

        let s = `${fmtDeg(lo)}..${fmtDeg(hi)}  →  Outer edges ${fmtDeg(oEdgeLo)}–${fmtDeg(oEdgeHi)}, verts ${fmtDeg(oVertLo)}–${fmtDeg(oVertHi)}`;

        if (lo > 1e-6) {
          const iEdgeLo = lo * stI.dMin;
          const iEdgeHi = lo * stI.dMax;
          const iVertLo = lo * stI.vMin;
          const iVertHi = lo * stI.vMax;
          s += `; Inner edges ${fmtDeg(iEdgeLo)}–${fmtDeg(iEdgeHi)}, verts ${fmtDeg(iVertLo)}–${fmtDeg(iVertHi)}`;
        }
        return s;
      });

      const hiMax = rs.reduce((acc, r) => Math.max(acc, loHi(r).hi), 0);
      const outer = `Outer≈edges ${fmtDeg(hiMax * stO.dMin)}–${fmtDeg(hiMax * stO.dMax)}`;
      const compact = (count === 1) ? outer : `${count} ranges (${outer})`;

      return { compact, lines };
    }

    // Fallback (treat like linear degrees)
    const lines = rs.map(r => {
      const { lo, hi } = loHi(r);
      return `${fmtDeg(lo)}..${fmtDeg(hi)}`;
    });
    const compact = (count === 1) ? lines[0] : `${count} ranges`;
    return { compact, lines };
  }


  // ---- Slider handle label helpers --------------------------------------
  // In stretched/irregular modes, the raw slider value is a *shape-space*
  // threshold, not a single global "degrees" measurement in every direction.
  // These helpers keep the slider's visible labels meaningful by showing the
  // effective pitch/roll extents (OR/AND), ellipse axes (circle), or polygon
  // edge-distance range (polygon) for the current shape.
  function fmtNumCompact(v, digits = 1) {
    if (!Number.isFinite(v)) return 'n/a';
    let s = v.toFixed(digits);
    if (digits > 0) s = s.replace(/\.0+$/, '');
    return s;
  }

  function fmtDegCompact(v, digits = 1) {
    return fmtNumCompact(v, digits) + '°';
  }

  function formatSliderHandleLabel(modeStr, val, idx, cfg, polyStatsOuter, polyStatsInner) {
    const v = Number(val);
    if (!Number.isFinite(v)) return 'n/a';

    // Plain linear degrees
    if (modeStr === 'pitch' || modeStr === 'roll') return fmtDegCompact(v, 1);

    // OR / AND: show effective pitch/roll extents after stretch.
    if (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll') {
      const sp = Math.max(1e-6, (cfg && Number.isFinite(cfg.rectScalePitch)) ? cfg.rectScalePitch : rectScalePitch);
      const sr = Math.max(1e-6, (cfg && Number.isFinite(cfg.rectScaleRoll))  ? cfg.rectScaleRoll  : rectScaleRoll);
      const p = v * sp;
      const r = v * sr;
      // If no stretch, keep it simple.
      if (Math.abs(sp - 1) < 1e-6 && Math.abs(sr - 1) < 1e-6) return fmtDegCompact(v, 1);
      return `P${fmtDegCompact(p, 1)} R${fmtDegCompact(r, 1)}`;
    }

    // Circle: show ellipse semi-axes after stretch.
    if (modeStr === 'circle') {
      const sx = Math.max(1e-6, (cfg && Number.isFinite(cfg.ellipseScaleX)) ? cfg.ellipseScaleX : ellipseScaleX);
      const sy = Math.max(1e-6, (cfg && Number.isFinite(cfg.ellipseScaleY)) ? cfg.ellipseScaleY : ellipseScaleY);
      const x = v * sx;
      const y = v * sy;
      if (Math.abs(sx - sy) < 1e-6) return fmtDegCompact(v, 1);
      return `X${fmtDegCompact(x, 1)} Y${fmtDegCompact(y, 1)}`;
    }

    // Polygon: show an approximate edge-distance range for this threshold.
    if (modeStr === 'polygon') {
      // Polygon degrees are interpreted as the boundary "circumradius" (distance to the farthest corner).
      // This keeps the slider numbers aligned with what you see after corner/edge edits.
      return fmtDegCompact(v, 1);
    }

    return fmtDegCompact(v, 1);
  }

  function updateMultiSliderHandleLabels(cfgOverride) {
    if (!bandMultiSlider) return;
    if (!sliderHandleEls || sliderHandleEls.length === 0) return;

    const modeStr = (cfgOverride && cfgOverride.modeStr) ? cfgOverride.modeStr : (monitorSelect?.value || 'pitch');
    const handles = getHandles(modeStr);

    // Precompute polygon stats once (outer/inner can differ).
    let stO = null;
    let stI = null;
    if (modeStr === 'polygon') {
      const cfg = cfgOverride || getBandSettingsForBand(bands?.[activeBandIndex] || makeDefaultBand(0));
      const sides = cfg.polySides || (parseInt(polySidesInput.value) || 3);
      const vO = cfg.polyVerts || polyVerts;
      const pO = cfg.polyPlanes || polyPlanes;
      const vI = cfg.polyVertsInner || polyVertsInner;
      const pI = cfg.polyPlanesInner || polyPlanesInner;
      stO = computePolyStats(sides, vO, pO);
      stI = computePolyStats(sides, vI, pI);
    }

    for (let i = 0; i < sliderHandleEls.length && i < handles.length; i++) {
      const hEl = sliderHandleEls[i];
      if (!hEl) continue;
      const lbl = hEl.querySelector('.handle-label');
      if (!lbl) continue;
      lbl.textContent = formatSliderHandleLabel(modeStr, handles[i], i, cfgOverride, stO, stI);
      // Keep raw value available on hover (desktop).
      hEl.title = `Raw: ${fmtDeg(handles[i], 1)}`;
    }
  }


  // Multi-slider UI state
  let sliderHandleEls = [];
  let sliderRangeEls  = [];
  let activeHandleIdx = -1;
  let activePointerId = null;

  function valueToPct(value, spec) {
    const span = (spec.max - spec.min) || 1;
    return ((value - spec.min) / span) * 100;
  }

  function pctToValue(pct, spec) {
    const span = (spec.max - spec.min) || 1;
    return spec.min + (pct / 100) * span;
  }

  function clearMultiSliderDom() {
    if (!bandMultiSlider) return;
    const toRemove = bandMultiSlider.querySelectorAll('.range, .handle');
    toRemove.forEach(el => el.remove());
    sliderHandleEls = [];
    sliderRangeEls = [];
  }

  function renderMultiSlider() {
    if (!bandMultiSlider) return;

    const band = getBandSettings();
    const modeStr = band.modeStr;
    const spec = getSliderSpec(modeStr);
    const handles = getHandles(modeStr);

    const isOrAnd = (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll');

    // Range controls (all modes): allow multiple bands/rings/stripes.
    // Buttons are only disabled by shader handle-limit or when only one range remains.
    const maxHandlesAllowed = MAX_RANGES * 2;

    if (addRangeBtn) {
      const canAdd = (!isOrAnd) && (handles.length + 2 <= maxHandlesAllowed);
      addRangeBtn.disabled = !canAdd;
      addRangeBtn.title = isOrAnd
        ? 'OR/AND uses a single 0..max range.'
        : (canAdd ? '' : `Max ${MAX_RANGES} ranges reached.`);
    }

    if (removeRangeBtn) {
      const canRemove = (!isOrAnd) && (handles.length > 2);
      removeRangeBtn.disabled = !canRemove;
      removeRangeBtn.title = isOrAnd
        ? 'OR/AND uses a single 0..max range.'
        : (canRemove ? '' : 'At least one range is required.');
    }

    if (bandSizeTitle) bandSizeTitle.textContent = 'Ranges';

    const ranges = getRanges(modeStr);
    if (bandSizeValue) {
      bandSizeValue.textContent = getRangeDisplay(modeStr, ranges).compact;
    }

    clearMultiSliderDom();

    // Build range strips
    for (let i = 0; i + 1 < handles.length; i += 2) {
      const a = handles[i];
      const b = handles[i + 1];
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      const left = valueToPct(lo, spec);
      const right = valueToPct(hi, spec);
      const el = document.createElement('div');
      el.className = 'range';
      el.style.left = left + '%';
      el.style.width = Math.max(0, right - left) + '%';
      bandMultiSlider.appendChild(el);
      sliderRangeEls.push(el);
    }

    // Build handles
    const labelCfg = {
      modeStr,
      rectScalePitch,
      rectScaleRoll,
      ellipseScaleX,
      ellipseScaleY,
      polySides: (parseInt(polySidesInput.value) || 3),
      polyVerts,
      polyVertsInner,
      polyPlanes,
      polyPlanesInner
    };

    handles.forEach((val, idx) => {
      const h = document.createElement('div');
      h.className = 'handle';
      h.style.left = valueToPct(val, spec) + '%';
      h.dataset.index = String(idx);

      const isLocked = isOrAnd && idx === 0;
      if (isLocked) h.classList.add('locked');

      const lab = document.createElement('div');
      lab.className = 'handle-label';
      lab.textContent = formatSliderHandleLabel(modeStr, val, idx, labelCfg, null, null);
      h.appendChild(lab);

      if (!isLocked) {
        h.addEventListener('pointerdown', (ev) => {
          ev.preventDefault();
          const i = parseInt(h.dataset.index, 10);
          if (!Number.isFinite(i)) return;
          activeHandleIdx = i;
          activePointerId = ev.pointerId;
          h.setPointerCapture(ev.pointerId);
        });
      }

      bandMultiSlider.appendChild(h);
      sliderHandleEls.push(h);
    });

    // Ensure labels reflect the current shape stretch (edge handles can change scales without
    // forcing a full slider re-render).
    updateMultiSliderHandleLabels(labelCfg);
  }

  function updateMultiSliderFromDrag(clientX) {
    if (activeHandleIdx < 0) return;
    const band = getBandSettings();
    const modeStr = band.modeStr;
    const spec = getSliderSpec(modeStr);
    const step = spec.step || 1;
    const rect = bandMultiSlider.getBoundingClientRect();
    if (!rect.width) return;

    let pct = ((clientX - rect.left) / rect.width) * 100;
    pct = clamp(pct, 0, 100);

    let v = pctToValue(pct, spec);
    v = clamp(snapToStep(v, step), spec.min, spec.max);

    const handles = getHandles(modeStr);

    if (modeStr === 'polygon') {
      // Polygon ranges are explicit min/max pairs; allow overlaps between ranges.
      // Constrain only within the active pair.
      const pairStart = activeHandleIdx & ~1; // even index of this pair
      const isMin = (activeHandleIdx % 2 === 0);
      const otherIdx = isMin ? (pairStart + 1) : pairStart;
      const otherVal = (otherIdx >= 0 && otherIdx < handles.length && Number.isFinite(handles[otherIdx]))
        ? handles[otherIdx]
        : (isMin ? spec.max : spec.min);

      if (isMin) {
        v = clamp(v, spec.min, otherVal - step);
      } else {
        v = clamp(v, otherVal + step, spec.max);
      }
    } else {
      // Keep ordering by constraining to neighbors.
      const prev = (activeHandleIdx > 0) ? handles[activeHandleIdx - 1] : spec.min;
      const next = (activeHandleIdx < handles.length - 1) ? handles[activeHandleIdx + 1] : spec.max;
      const pad = step; // keep at least 1-step separation between handles
      const minAllowed = (activeHandleIdx > 0) ? (prev + pad) : spec.min;
      const maxAllowed = (activeHandleIdx < handles.length - 1) ? (next - pad) : spec.max;

      v = clamp(v, minAllowed, maxAllowed);
    }

    handles[activeHandleIdx] = v;
    handlesByMode[modeStr] = handles;

    // Sync legacy inputs
    if (handles.length >= 2) {
      minAngleInput.value = handles[0];
      maxAngleInput.value = handles[1];
    }

    // Update DOM positions + labels
    const hEl = sliderHandleEls[activeHandleIdx];
    if (hEl) {
      hEl.style.left = valueToPct(v, spec) + '%';
    }

    // Update range strips
    for (let ri = 0; ri < sliderRangeEls.length; ri++) {
      const a = handles[ri * 2];
      const b = handles[ri * 2 + 1];
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      const left = valueToPct(lo, spec);
      const right = valueToPct(hi, spec);
      const el = sliderRangeEls[ri];
      if (el) {
        el.style.left = left + '%';
        el.style.width = Math.max(0, right - left) + '%';
      }
    }

    // Update the small value readout
    const ranges = getRanges(modeStr);
    if (bandSizeValue) {
      bandSizeValue.textContent = getRangeDisplay(modeStr, ranges).compact;
    }

    // Keep handle labels honest (effective degrees depend on shape stretch).
    updateMultiSliderHandleLabels({
      modeStr,
      rectScalePitch,
      rectScaleRoll,
      ellipseScaleX,
      ellipseScaleY,
      polySides: (parseInt(polySidesInput.value) || 3),
      polyVerts,
      polyVertsInner,
      polyPlanes,
      polyPlanesInner
    });
  }

  if (bandMultiSlider) {
    bandMultiSlider.addEventListener('pointermove', (ev) => {
      if (activeHandleIdx < 0) return;
      if (activePointerId != null && ev.pointerId !== activePointerId) return;
      updateMultiSliderFromDrag(ev.clientX);
      updateUI();
    });

    const endDrag = (ev) => {
      if (activeHandleIdx < 0) return;
      if (activePointerId != null && ev.pointerId !== activePointerId) return;
      // Normalize + clamp, then persist.
      const band = getBandSettings();
      const modeStr = band.modeStr;
      setHandles(modeStr, handlesByMode[modeStr], { save: true, update: true, render: true });
      activeHandleIdx = -1;
      activePointerId = null;
    };

    bandMultiSlider.addEventListener('pointerup', endDrag);
    bandMultiSlider.addEventListener('pointercancel', endDrag);
    bandMultiSlider.addEventListener('pointerleave', (ev) => {
      // If pointer leaves while captured, the handle still moves; do nothing.
    });
  }

  if (addRangeBtn) {
    addRangeBtn.addEventListener('click', () => {
      const band = getBandSettings();
      const modeStr = band.modeStr;
      const spec = getSliderSpec(modeStr);
      const step = spec.step || 1;

      let handles = getHandles(modeStr);
      const maxHandles = MAX_RANGES * 2;
      if (handles.length + 2 > maxHandles) {
        setStatus(`Max ${MAX_RANGES} ranges reached (shader limit).`);
        return;
      }

      // Add a new small range near the end of the domain.
      const last = handles[handles.length - 1];
      let a = clamp(last + 2 * step, spec.min, spec.max);
      let b = clamp(a + 2 * step, spec.min, spec.max);
      if (b - a < step) {
        // Fallback: place near center.
        const mid = 0.5 * (spec.min + spec.max);
        a = clamp(mid - step, spec.min, spec.max);
        b = clamp(mid + step, spec.min, spec.max);
      }

      handles = handles.concat([a, b]);
      setHandles(modeStr, handles, { save: true, update: true, render: true });
    });
  }

  if (removeRangeBtn) {
    removeRangeBtn.addEventListener('click', () => {
      const band = getBandSettings();
      const modeStr = band.modeStr;
      let handles = getHandles(modeStr);
      if (handles.length <= 2) {
        // Keep at least one range.
        handles = (DEFAULT_HANDLES_BY_MODE[modeStr] || [-1, 1]).slice();
      } else {
        handles = handles.slice(0, Math.max(2, handles.length - 2));
      }
      setHandles(modeStr, handles, { save: true, update: true, render: true });
    });
  }

  if (resetRangesBtn) {
    resetRangesBtn.addEventListener('click', () => {
    const band = getBandSettings();
    const modeStr = band.modeStr;

    // Also reset per-mode stretch state so "Reset ranges" truly restores the shape.
    if (modeStr === 'pitchOrRoll' || modeStr === 'pitchAndRoll') {
      rectScalePitch = 1;
      rectScaleRoll  = 1;
    } else if (modeStr === 'circle') {
      ellipseScaleX = 1;
      ellipseScaleY = 1;
    } else if (modeStr === 'polygon') {
      resetPolyVerts(band.polySides, polyVerts, polyPlanes);
      resetPolyVerts(band.polySides, polyVertsInner, polyPlanesInner);
      polyVertsLoaded = true;
      polyVertsInnerLoaded = true;
    }

    const def = (DEFAULT_HANDLES_BY_MODE[modeStr] || [-1, 1]).slice();
    setHandles(modeStr, def, { save: true, update: true, render: true });
    saveSettings();
  });
  }
  // Returns [0,360)
  function wrap360(deg) {
    let d = deg % 360;
    if (d < 0) d += 360;
    return d;
  }

  // Round an angle on a 0..360 axis to N decimals, never returning 360 (wraps to 0).
  // This prevents UI flicker between 0° and 360° when the true value is very near zero.
  function roundAngle360(deg, decimals = 1) {
    if (!Number.isFinite(deg)) return 0;
    const factor = Math.pow(10, decimals);
    let d = wrap360(deg);
    let r = Math.round(d * factor) / factor;
    if (r >= 360) r = 0;
    if (Object.is(r, -0)) r = 0;
    return r;
  }

  // Format an angle on a 0..360 axis without ever showing 360.0° (it becomes 0.0°).
  function formatAngle360(deg, decimals = 1) {
    if (!Number.isFinite(deg)) return 'n/a';
    return roundAngle360(deg, decimals).toFixed(decimals) + '°';
  }

  // Returns [-180,180)
  function wrap180(deg) {
    return wrap360(deg + 180) - 180;
  }
  // True if value is inside the circular interval from min->max (CW on a 0..360 axis)
  // where the interval length is interpreted as (max-min) unless it spans >=360.
  function inAngleBand360(valueDeg, minDeg, maxDeg) {
    const spanRaw = maxDeg - minDeg;
    if (spanRaw >= 360) return true;
    const v = wrap360(valueDeg);
    const minN = wrap360(minDeg);
    const maxN = wrap360(maxDeg);
    const span = wrap360(maxN - minN);
    const t = wrap360(v - minN);
    return t <= span + 1e-9;
  }
  function angleDistanceDeg(aDeg, bDeg) {
    return Math.abs(wrap180(aDeg - bDeg));
  }

  function tiltToDir(pitchDeg, rollDeg) {
    const lat = degToRad(pitchDeg);
    const lon = degToRad(rollDeg);
    const y = Math.sin(lat);
    const r = Math.cos(lat);
    const x = r * Math.sin(lon);
    const z = r * Math.cos(lon);
    const len = Math.sqrt(x*x + y*y + z*z) || 1;
    return [x/len, y/len, z/len];
  }

  function computeCrossAngles(dir, upVec) {
    const EPS = 1e-6;
    const len = length3(dir);
    if (len < EPS) return null;
    const f = [dir[0]/len, dir[1]/len, dir[2]/len];

    const fy = Math.max(-1, Math.min(1, f[1]));
    const pitchRad = Math.asin(fy);
    const yawRad   = Math.atan2(f[0], f[2]);

    let rollRad = 0;
    if (upVec) {
      let u = upVec.slice();
      const lenU = length3(u);
      if (lenU > EPS) {
        u = [u[0]/lenU, u[1]/lenU, u[2]/lenU];
        const dotUF = dot3(u, f);
        u = [u[0]-f[0]*dotUF, u[1]-f[1]*dotUF, u[2]-f[2]*dotUF];
        const lenUT = length3(u);
        if (lenUT > EPS) {
          u = [u[0]/lenUT, u[1]/lenUT, u[2]/lenUT];
          const worldUp = [0, 1, 0];
          let rightBase = cross3(worldUp, f);
          let lenRB = length3(rightBase);
          if (lenRB < EPS) {
            rightBase = cross3([0, 0, 1], f);
            lenRB = length3(rightBase);
          }
          if (lenRB > EPS) {
            rightBase = [rightBase[0]/lenRB, rightBase[1]/lenRB, rightBase[2]/lenRB];
            let upBase = cross3(f, rightBase);
            const lenUB = length3(upBase);
            if (lenUB > EPS) {
              upBase = [upBase[0]/lenUB, upBase[1]/lenUB, upBase[2]/lenUB];
              const dotU = dot3(u, upBase);
              const dotR = dot3(u, rightBase);
              rollRad = Math.atan2(dotR, dotU);
            }
          }
        }
      }
    }

    return {
      pitchDeg: pitchRad * 180 / Math.PI,
      yawDeg:   yawRad   * 180 / Math.PI,
      rollDeg:  rollRad  * 180 / Math.PI
    };
  }

  // Band center frame
  let bandCenterDir = [0, 0, 1];
  let bandFrameX    = [1, 0, 0];
  let bandFrameY    = [0, 1, 0];

  function updateBandFrameFromDir() {
    let dir = normalize3(bandCenterDir);
    bandCenterDir = dir;

    let ref = [0, 1, 0];
    if (Math.abs(dot3(ref, dir)) > 0.9) ref = [1, 0, 0];

    let x = cross3(ref, dir);
    let lenX = length3(x);
    if (lenX < 1e-6) {
      x = cross3([0, 0, 1], dir);
      lenX = length3(x) || 1;
    }
    bandFrameX = [x[0]/lenX, x[1]/lenX, x[2]/lenX];

    let y = cross3(dir, bandFrameX);
    let lenY = length3(y) || 1;
    bandFrameY = [y[0]/lenY, y[1]/lenY, y[2]/lenY];
  }

  // Axis labels (world space)
  const labels = [
    { el: labelPosX, dir: [ 1,  0,  0] },
    { el: labelNegX, dir: [-1,  0,  0] },
    { el: labelPosY, dir: [ 0,  1,  0] },
    { el: labelNegY, dir: [ 0, -1,  0] },
    { el: labelPosZ, dir: [ 0,  0,  1] },
    { el: labelNegZ, dir: [ 0,  0, -1] }
  ];

  // Camera state + inertia
  let yaw   = 0;
  let pitch = 0;
  const camDist   = 4;
  let   zoomScale = 1;
  const orthoBase = 1.2;
  const MIN_ZOOM = 0.02;
  // Sphere sizing -----------------------------------------------------------
  // Keep the sphere at a stable *absolute* on-screen size (CSS pixels), even when
  // the scene is split (portrait/landscape) and the canvas CSS size changes.
  //
  // We capture a reference radius once from the full viewport and keep using it.
  // (Zoom still works: zoomScale changes the on-screen radius.)
  let sphereBaseRadiusCss = null; // radius at zoomScale=1 (CSS px)

  function ensureSphereBaseRadiusCss() {
    if (Number.isFinite(sphereBaseRadiusCss) && sphereBaseRadiusCss > 0) {
      return sphereBaseRadiusCss;
    }
    const refMin = Math.min(getViewportWidthPx(), getViewportHeightPx());
    // Match the default fit when uOrthoScale == orthoBase (sphere ~83% of refMin).
    sphereBaseRadiusCss = Math.max(60, refMin / (2 * orthoBase));
    return sphereBaseRadiusCss;
  }


  // Manual yaw for the *camera crosshair* (decoupled from compass). Controlled via two-finger twist.
  let camCrossYawDeg = 0;
  // Calibration offset (degrees) between gravity cross and camera cross when camera is ATTACHED.
  // Set this to e.g. 45 to remove a consistent 45° clocking offset.
  let camAttachYawOffsetDeg = 0;

  // Stretch scales (edge handles) for rectangular modes (pitchOrRoll / pitchAndRoll)
  // These are dimensionless multipliers applied to pitch/roll distances.
  let rectScalePitch = 1;
  let rectScaleRoll  = 1;

  // Ellipse scales (edge handles) for circle mode (turns circle into an ellipse when stretched).
  let ellipseScaleX = 1;
  let ellipseScaleY = 1;

  // Polygon shape (mode === 'polygon')
  // We store a user-editable polygon directly as 2D vertices in the band tangent plane.
  // The vertices are stored in "shapeCoord = 1" units (so the outer boundary uses verts * tOuter).
  const MAX_POLY_SIDES_JS = 24;

  // Base (unrotated) polygon vertices for shapeCoord=1: [x0,y0,x1,y1,...] in degrees.
  let polyVerts = new Float32Array(MAX_POLY_SIDES_JS * 2);
  let polyVertsLoaded = false;

  // Inner polygon (hole) for polygon mode.
  // Same representation as polyVerts, but used for the INNER boundary (range min).
  // If not explicitly saved/edited, we default it to a copy of the outer polygon.
  let polyVertsInner = new Float32Array(MAX_POLY_SIDES_JS * 2);
  let polyVertsInnerLoaded = false;

  // Derived edge half-planes for the same base polygon:
  // plane_i = (nx, ny, d) where (nx,ny) is unit outward normal and dot(n, p) <= d defines the edge.
  // (These are also in shapeCoord=1 units.)
  let polyPlanes = new Float32Array(MAX_POLY_SIDES_JS * 3);

  // Derived planes for the inner polygon.
  let polyPlanesInner = new Float32Array(MAX_POLY_SIDES_JS * 3);

  function rotate2D(x, y, angRad) {
    const c = Math.cos(angRad);
    const s = Math.sin(angRad);
    return { x: x * c - y * s, y: x * s + y * c };
  }

  function polySignedArea2D(n, verts) {
    let A2 = 0;
    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;
      const xi = verts[i * 2],     yi = verts[i * 2 + 1];
      const xj = verts[j * 2],     yj = verts[j * 2 + 1];
      A2 += xi * yj - xj * yi;
    }
    return 0.5 * A2;
  }

  function polyCentroid2D(n, verts) {
    if (n < 3) return { x: 0, y: 0, area: 0 };

    let A2 = 0;
    let Cx6A = 0;
    let Cy6A = 0;

    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;
      const xi = verts[i * 2],     yi = verts[i * 2 + 1];
      const xj = verts[j * 2],     yj = verts[j * 2 + 1];
      const cross = xi * yj - xj * yi;
      A2 += cross;
      Cx6A += (xi + xj) * cross;
      Cy6A += (yi + yj) * cross;
    }

    if (Math.abs(A2) < 1e-10) return { x: 0, y: 0, area: 0 };
    const inv6A = 1 / (3 * A2); // since 6A = 3*A2
    return { x: Cx6A * inv6A, y: Cy6A * inv6A, area: 0.5 * A2 };
  }

  function polyIsConvexCCW2D(n, verts) {
    if (n < 3) return false;
    const area = polySignedArea2D(n, verts);
    if (!(area > 1e-8)) return false;

    let sign = 0;
    for (let i = 0; i < n; i++) {
      const i0 = i;
      const i1 = (i + 1) % n;
      const i2 = (i + 2) % n;

      const x0 = verts[i0 * 2], y0 = verts[i0 * 2 + 1];
      const x1 = verts[i1 * 2], y1 = verts[i1 * 2 + 1];
      const x2 = verts[i2 * 2], y2 = verts[i2 * 2 + 1];

      const ax = x1 - x0;
      const ay = y1 - y0;
      const bx = x2 - x1;
      const by = y2 - y1;

      const cross = ax * by - ay * bx;
      if (Math.abs(cross) < 1e-10) continue;
      const s = cross > 0 ? 1 : -1;
      if (sign === 0) sign = s;
      else if (s !== sign) return false;
    }
    return sign >= 0;
  }

  function rebuildPolyPlanes(n, verts = polyVerts, outPlanes = polyPlanes) {
    const nn = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(n || 3)));

    for (let i = 0; i < nn; i++) {
      const j = (i + 1) % nn;
      const x0 = verts[i * 2],     y0 = verts[i * 2 + 1];
      const x1 = verts[j * 2],     y1 = verts[j * 2 + 1];
      const ex = x1 - x0;
      const ey = y1 - y0;

      // CCW polygon => outward normal is edge rotated -90°: (ey, -ex)
      let nx = ey;
      let ny = -ex;
      const L = Math.hypot(nx, ny) || 0;
      if (L < 1e-10) {
        nx = 1;
        ny = 0;
      } else {
        nx /= L;
        ny /= L;
      }

      let d = nx * x0 + ny * y0;
      // Ensure d is positive for stability (origin should be inside).
      if (d < 0) {
        nx = -nx;
        ny = -ny;
        d = -d;
      }

      const o = i * 3;
      outPlanes[o]     = nx;
      outPlanes[o + 1] = ny;
      outPlanes[o + 2] = Math.max(1e-6, d);
    }

    for (let i = nn; i < MAX_POLY_SIDES_JS; i++) {
      const o = i * 3;
      outPlanes[o] = 1;
      outPlanes[o + 1] = 0;
      outPlanes[o + 2] = 1;
    }
  }

  // Polygon "gauge" (shape coordinate) at a point in the polygon's base (unrotated) plane.
  // For a convex polygon represented by half-planes dot(p, n_i) <= S * d_i,
  // the gauge is: gauge(p) = max_i dot(p, n_i) / d_i. The point is inside the
  // scaled polygon at S if and only if gauge(p) <= S.
  function polyGauge2D(n, planes, x, y) {
    const nn = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(n || 3)));
    let g = -1e9;
    for (let i = 0; i < nn; i++) {
      const o = i * 3;
      const nx = planes[o];
      const ny = planes[o + 1];
      const d  = Math.max(1e-6, planes[o + 2]);
      const v = (x * nx + y * ny) / d;
      if (v > g) g = v;
    }
    return g;
  }

  function polyAllVertsInside(n, innerVertsNorm, innerScale, outerPlanes, outerScale) {
    const nn = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(n || 3)));
    for (let i = 0; i < nn; i++) {
      const x = innerVertsNorm[i * 2] * innerScale;
      const y = innerVertsNorm[i * 2 + 1] * innerScale;
      const g = polyGauge2D(nn, outerPlanes, x, y);
      if (g > outerScale + 1e-6) return false;
    }
    return true;
  }

  function resetPolyVerts(sides, outVerts = polyVerts, outPlanes = polyPlanes) {
    const n = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(sides || 3)));
    const sector = (Math.PI * 2) / n;

    // Match the old polygon orientation: vertices are half a sector ahead of the first edge normal.
    for (let i = 0; i < n; i++) {
      const a = (i + 0.5) * sector;
      outVerts[i * 2]     = Math.cos(a);
      outVerts[i * 2 + 1] = Math.sin(a);
    }
    for (let i = n; i < MAX_POLY_SIDES_JS; i++) {
      outVerts[i * 2] = 0;
      outVerts[i * 2 + 1] = 0;
    }

    rebuildPolyPlanes(n, outVerts, outPlanes);
  }


  let yawVel   = 0;
  let pitchVel = 0;

  const BASE_ROTATION_SPEED = 0.005;
  const BASE_CAM_FRICTION   = 3.0;

  function getRotationSensitivity() {
    const z = Math.min(Math.max(zoomScale, MIN_ZOOM), 2.0);
    return Math.min(Math.max(z, 0.02), 2.0);
  }

  function getCamFriction() {
    const CLOSE_Z = 0.25;
    const FAR_Z   = 2.0;
    const z = Math.min(Math.max(zoomScale, CLOSE_Z), FAR_Z);
    const t = (z - CLOSE_Z) / (FAR_Z - CLOSE_Z);
    const closeFactor = 1.3;
    const farFactor   = 0.7;
    const factor = closeFactor + (farFactor - closeFactor) * t;
    return BASE_CAM_FRICTION * factor;
  }

  let lastFrameTime = null;
  let lastDragTime  = null;

  // Interaction
  let isDragging   = false;
  let lastX = 0;
  let lastY = 0;
  let isPinching   = false;
  let lastPinchDist = 0;
  let userActivated  = false;
  let justEndedPinch = false;

  // Double-tap
  let lastTapTime = 0;
  let lastTapX = 0;
  let lastTapY = 0;
  const DOUBLE_TAP_MAX_DELAY = 300;
  const DOUBLE_TAP_MAX_MOVE  = 30;

  // Long-press (set band center from camera)
  const LONG_PRESS_MS = 550;
  const LONG_PRESS_MAX_MOVE = 12; // px
  let longPressTimer = null;
  let longPressArmed = false;
  // Two-finger pinch/twist + long-press
  let lastPinchAngle = 0;
  let twoLongPressTimer = null;
  let twoLongPressArmed = false;
  let twoLongPressStartX = 0;
  let twoLongPressStartY = 0;
  let twoLongPressStartDist = 0;
  let longPressFired = false;
  let longPressStartX = 0;
  let longPressStartY = 0;

  function clearLongPress() {
    longPressArmed = false;
    if (longPressTimer != null) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  }

  // Camera attach
  let cameraAttachedToGravity = false;
  let attachTransitionActive = false;
  let attachTransitionTime   = 0;
  const ATTACH_TRANSITION_DURATION = 0.4;
  let attachFromYaw   = 0;
  let attachFromPitch = 0;

  // Audio
  let audioContext = null;
  let warningOsc   = null;
  let warningGain  = null;
  let audioReady   = false;

  // In-band beep timer (optional)
  let beepTimerEnabled      = false;  // UI toggle
  let beepTimerIntervalSec  = 1.0;    // UI interval (seconds)
  let beepTimerIntervalMs   = 1000;   // cached milliseconds
  let beepTimerWasInRange   = false;  // last union state
  let beepTimerStartMs      = 0;      // perf.now() when entering a band
  let beepTimerNextBeepMs   = 0;      // perf.now() when next beep is due
  let beepTimerElapsedMs    = 0;      // last computed elapsed time inside band
  let beepTimerBeepCount    = 0;      // number of beeps since entry
  let beepTimerLastIntervalMs = 1000; // for detecting interval changes while running

  // CountDown (optional): set a goal time to stay inside the active band, then notify.
  let countDownEnabled      = false;  // UI toggle
  let countDownGoalSec      = 10.0;   // UI goal (seconds)
  let countDownGoalMs       = 10000;  // cached milliseconds
  let countDownWasInRange   = false;  // last active-band state
  let countDownStartMs      = 0;      // perf.now() when entering the active band
  let countDownElapsedMs    = 0;      // last computed elapsed time inside active band
  let countDownTriggered    = false;  // whether we've already notified for this entry
  let countDownLastGoalMs   = 10000;  // detect goal changes while running



  // CountDown voice (optional): speak remaining seconds
  let countDownVoiceEnabled    = false;
  let countDownVoiceLastSpoken = null;  // last spoken whole-seconds value
  let countDownVoiceSpokeDone  = false; // whether we've spoken the completion cue

  // Sensors
  let sensorsInitialized = false;
  let sensorsAvailable   = false;
  let haveSensorData     = false;

  let devicePitchDeg = 0;
  let deviceRollDeg  = 0;
  // Smoothed compass heading (degrees, 0..360, clockwise from North), or null when unavailable.
  let deviceYawDeg   = null;
  // Raw compass sample (degrees) from the latest sensor event (for debugging).
  let deviceYawRawDeg = null;

  // Compass smoothing / hysteresis to prevent flicker/jitter.
  let compassTargetRad    = 0;
  let compassFilteredRad  = 0;
  let compassInitialized  = false;
  let lastCompassMs       = -Infinity;

  // Tuning:
  const COMPASS_SMOOTH_TAU = 0.18; // seconds (higher = smoother, more lag)
  const COMPASS_HOLD_MS    = 900;  // ms to keep last valid compass before declaring "unavailable"


  // Gravity direction (magenta cross)
  let gravityDir = [0,0,1];

  // Inertial pitch/roll
  let targetPitchDeg = 0;
  let targetRollDeg  = 0;
  let inertialPitchDeg = 0;
  let inertialRollDeg  = 0;
  let inertialPitchVel = 0;
  let inertialRollVel  = 0;
  let inertialInitialized = false;

  const INERTIA_NATURAL_FREQ = 6.0;
  const INERTIA_DAMPING      = 0.8;

  // Global in-range flag (for sphere color)
  let globalInRange = false;
  let activeBandInRange = false; // active band only (for CountDown)

  // Last camera directions (for UI)
  let lastForward   = [0,0,-1];
  let lastCamCenter = [0,0,1];
  let lastGravityUp = [0,1,0];
  let lastCamUp     = [0,1,0];

  // === Shaders ==============================================================
  function createShader(glCtx, type, source) {
    const shader = glCtx.createShader(type);
    glCtx.shaderSource(shader, source);
    glCtx.compileShader(shader);
    if (!glCtx.getShaderParameter(shader, glCtx.COMPILE_STATUS)) {
      const kind = (type === glCtx.FRAGMENT_SHADER) ? 'Fragment' : 'Vertex';
      setStatus(kind + ' shader error: ' + glCtx.getShaderInfoLog(shader));
      glCtx.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram(glCtx, vsSource, fsSource) {
    const vs = createShader(glCtx, glCtx.VERTEX_SHADER, vsSource);
    const fs = createShader(glCtx, glCtx.FRAGMENT_SHADER, fsSource);
    if (!vs || !fs) return null;
    const prg = glCtx.createProgram();
    glCtx.attachShader(prg, vs);
    glCtx.attachShader(prg, fs);
    glCtx.bindAttribLocation(prg, 0, 'aPosition');
    glCtx.linkProgram(prg);
    if (!glCtx.getProgramParameter(prg, glCtx.LINK_STATUS)) {
      setStatus('Program link error: ' + glCtx.getProgramInfoLog(prg));
      return null;
    }
    return prg;
  }

  const vsSource = `
    attribute vec2 aPosition;
    varying vec2 vPos;
    void main() {
      vPos = aPosition;
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fsSource = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    varying vec2 vPos;

    uniform vec3 uEye;
    uniform vec3 uForward;
    uniform vec3 uRight;
    uniform vec3 uUp;
    uniform float uOrthoScale;
    uniform float uAspect;

    uniform float uPass;
    uniform vec3  uBandTint;

    uniform vec3 uGravityCenter;
    uniform vec3 uGravityUp;
    uniform vec3 uGravityRight;

    uniform vec3 uCamCenter;
    uniform vec3 uCamUp;
    uniform vec3 uCamRight;

    uniform float uCrossArc;
    uniform float uCrossWidth;
    uniform float uBandMinDeg;
    uniform float uBandMaxDeg;

    uniform float uRectScalePitch;
    uniform float uRectScaleRoll;
    uniform float uEllipseScaleX;
    uniform float uEllipseScaleY;

    #define MAX_POLY_SIDES 24
    // Polygon is the intersection of half-planes in the local tangent plane:
    //   dot(p, n_i) <= S * d_i
    // packed as vec3(n.x, n.y, d).
    // Outer and inner polygons are evaluated independently so the "ring" thickness
    // can vary per-side when the user edits the inner boundary.
    uniform vec3 uPolyPlanesOuter[MAX_POLY_SIDES];
    uniform vec3 uPolyPlanesInner[MAX_POLY_SIDES];

    // Polygon vertices at S=1 (for stable centerline based on vertex midpoints)
    uniform vec2 uPolyVertsOuter[MAX_POLY_SIDES];
    uniform vec2 uPolyVertsInner[MAX_POLY_SIDES];

    #define MAX_RANGES 32
    uniform int uRangeCount;
    uniform float uRangeMins[MAX_RANGES];
    uniform float uRangeMaxs[MAX_RANGES];
    uniform float uBandMode;
    uniform float uBandPolySides;

    uniform vec3 uBandCenterDir;
    uniform vec3 uBandFrameX;
    uniform vec3 uBandFrameY;
    uniform float uBandRotationRad;

    uniform float uCenterPitchDeg;
    uniform float uCenterRollDeg;

    uniform float uGlobalInRange;
    uniform float uQuality;

    const float CROSS_INTENSITY = 1.7;
    const float GAMMA = 2.2;
    const float ALONG_POWER = 2.1;

    vec3 toLinear(vec3 c) {
      return pow(c, vec3(GAMMA));
    }

    vec3 toSRGB(vec3 c) {
      return pow(max(c, vec3(0.0)), vec3(1.0 / GAMMA));
    }

    float greatCircleBandFaded(
      vec3 pDir, vec3 centerDir,
      vec3 tangentDir, float arcAngle,
      float lineWidth
    ) {
      float c = dot(centerDir, pDir);
      float t = dot(tangentDir, pDir);
      float angleAlong = atan(t, c);
      float absAngle   = abs(angleAlong);
      if (absAngle > arcAngle) {
        return 0.0;
      }
      float planeLenSq = max(0.0, 1.0 - c*c - t*t);
      float off        = sqrt(planeLenSq);
      float radial     = smoothstep(lineWidth, 0.0, off);
      float alongBase  = 1.0 - (absAngle / arcAngle);
      alongBase = clamp(alongBase, 0.0, 1.0);
      float along = pow(alongBase, ALONG_POWER);
      return radial * along;
    }

    float bandMembership(float valueDeg, float minDeg, float maxDeg) {
      float feather = 0.25;
      float t1 = smoothstep(minDeg - feather, minDeg + feather, valueDeg);
      float t2 = 1.0 - smoothstep(maxDeg - feather, maxDeg + feather, valueDeg);
      float m  = clamp(t1 * t2, 0.0, 1.0);
      return pow(m, 3.0);
    }

    // Wrap degrees to [-180, 180)
    float wrap180(float a) {
      float r = mod(a + 180.0, 360.0);
      if (r < 0.0) r += 360.0;
      return r - 180.0;
    }

    // Shortest distance on a 0..360 circle, in degrees.
    float dist360(float aDeg, float bDeg) {
      float d = mod(aDeg - bDeg + 180.0, 360.0) - 180.0;
      return abs(d);
    }

    // Soft outline pulse (1 at dist=0, 0 at dist>=width).
    float edgePulse(float distDeg, float widthDeg) {
      return 1.0 - smoothstep(0.0, widthDeg, distDeg);
    }


    // Circular band membership on a 0..360 axis (fixes seam cutoffs at the atan2 branch).
    float bandMembershipWrapped360(float valueDeg, float minDeg, float maxDeg) {
      float feather = 0.25;

      float spanRaw = maxDeg - minDeg;
      if (spanRaw >= 360.0) {
        return 1.0;
      }

      float v    = mod(valueDeg, 360.0);
      if (v < 0.0) v += 360.0;
      float minN = mod(minDeg, 360.0);
      if (minN < 0.0) minN += 360.0;
      float maxN = mod(maxDeg, 360.0);
      if (maxN < 0.0) maxN += 360.0;

      float span = mod(maxN - minN + 360.0, 360.0);
      float t    = mod(v - minN + 360.0, 360.0);

      float t1 = smoothstep(0.0 - feather, 0.0 + feather, t);
      float t2 = 1.0 - smoothstep(span - feather, span + feather, t);
      float m  = clamp(t1 * t2, 0.0, 1.0);
      return pow(m, 3.0);
    }

    float unionMembershipLinear(float vDeg) {
      float m = 0.0;
      for (int i = 0; i < MAX_RANGES; i++) {
        if (i < uRangeCount) {
          m = max(m, bandMembership(vDeg, uRangeMins[i], uRangeMaxs[i]));
        }
      }
      return m;
    }

    float unionMembershipWrapped360(float vDeg) {
      float m = 0.0;
      for (int i = 0; i < MAX_RANGES; i++) {
        if (i < uRangeCount) {
          m = max(m, bandMembershipWrapped360(vDeg, uRangeMins[i], uRangeMaxs[i]));
        }
      }
      return m;
    }


    // Distance from point to a line segment in the polygon's tangent plane (degrees).
    // Used to draw a stable polygon centerline even when inner/outer shapes mismatch.
    float distPointSegment(vec2 p, vec2 a, vec2 b) {
      vec2 ab = b - a;
      float denom = dot(ab, ab);
      if (denom < 1e-6) return length(p - a);
      float t = dot(p - a, ab) / denom;
      t = clamp(t, 0.0, 1.0);
      vec2 q = a + t * ab;
      return length(p - q);
    }

    void main() {
      vec3 forward = normalize(uForward);
      vec3 right   = normalize(uRight);
      vec3 up      = normalize(uUp);

      float halfHeight = uOrthoScale;
      float halfWidth  = uOrthoScale * uAspect;
      vec2 plane       = vec2(vPos.x * halfWidth, vPos.y * halfHeight);

      vec3 rayOrigin = uEye + right * plane.x + up * plane.y;
      vec3 rayDir    = forward;

      float radius = 1.0;
      float d      = dot(rayOrigin, rayDir);
      float c      = dot(rayOrigin, rayOrigin) - radius * radius;
      float disc   = d*d - c;

      if (disc < 0.0) {
        discard;
      }

      float tHit = -d - sqrt(disc);
      if (tHit < 0.0) {
        discard;
      }

      vec3 hitPos = rayOrigin + rayDir * tHit;
      vec3 N      = normalize(hitPos);
      vec3 V      = -forward;

      float depthFactor = clamp(dot(N, V), 0.0, 1.0);

      // --- Sphere shading ---------------------------------------------------
      // Base palette shifts slightly when any enabled band is "in range".
      vec3 baseColorOut = vec3(0.07, 0.03, 0.12);
      vec3 baseColorIn  = vec3(0.02, 0.18, 0.14);
      float inFlag = clamp(uGlobalInRange, 0.0, 1.0);
      vec3 baseColor = mix(baseColorOut, baseColorIn, inFlag);

      // Subtle pole tint so the sphere feels less flat.
      float pole = clamp(N.y * 0.5 + 0.5, 0.0, 1.0);
      baseColor += (pole - 0.5) * 0.020 * vec3(0.18, 0.38, 0.95);

      // Gentle low-frequency surface variation (keeps it from looking like a flat disk).
      // Skipped in Performance mode to save ALU.
      float surfN = 0.5;
      if (uQuality > 1.5) {
        surfN = fract(sin(dot(N.xz * 73.0 + N.yy * 19.0, vec2(127.1, 311.7))) * 43758.5453);
      }
      baseColor *= 0.985 + 0.03 * surfN;

      // Two-light + hemisphere ambient + fresnel rim.
      vec3 lightA = normalize(vec3(0.35, 0.65, 0.68));
      vec3 lightB = normalize(vec3(-0.72, 0.18, 0.67));

      float wrap = 0.35;
      float ndlA = clamp((dot(N, lightA) + wrap) / (1.0 + wrap), 0.0, 1.0);
      float ndlB = clamp((dot(N, lightB) + wrap) / (1.0 + wrap), 0.0, 1.0);

      vec3 skyCol    = vec3(0.10, 0.18, 0.36);
      vec3 groundCol = vec3(0.02, 0.01, 0.04);
      float hemiT = pole;
      vec3 ambient = mix(groundCol, skyCol, hemiT);

      float diffuse = 0.28 + 0.62 * ndlA + 0.22 * ndlB;

      float specAmt = 0.0;
      if (uQuality > 0.5) {
        vec3 halfA = normalize(lightA + V);
        vec3 halfB = normalize(lightB + V);
        float shinA = (uQuality > 1.5) ? 92.0 : 48.0;
        float shinB = (uQuality > 1.5) ? 64.0 : 32.0;
        float specA = pow(max(dot(N, halfA), 0.0), shinA);
        float specB = pow(max(dot(N, halfB), 0.0), shinB);
        specAmt = (0.17 * specA + 0.08 * specB) * (0.25 + 0.75 * depthFactor);
      }

      float rim  = pow(1.0 - depthFactor, (uQuality > 1.5) ? 2.2 : 1.7);
      float fres = 0.0;
      if (uQuality > 0.5) {
        fres = pow(1.0 - depthFactor, 5.0);
      }
      vec3 rimCol  = vec3(0.18, 0.40, 0.98);
      vec3 fresCol = vec3(0.26, 0.60, 1.00);

      vec3 sphereColor = baseColor * diffuse;
      sphereColor += ambient * (0.55 + 0.25 * inFlag);
      sphereColor += specAmt * vec3(0.92, 0.96, 1.00);
      sphereColor += rimCol  * (0.16 * rim);
      sphereColor += fresCol * (0.12 * fres);

      vec3 sphereLinear = toLinear(sphereColor);

      // Camera cross (cyan)
      vec3 camCenter = normalize(uCamCenter);
      float camUpBand = greatCircleBandFaded(
        N, camCenter,
        normalize(uCamUp),
        uCrossArc,
        uCrossWidth
      );
      float camRightBand = greatCircleBandFaded(
        N, camCenter,
        normalize(uCamRight),
        uCrossArc,
        uCrossWidth
      );
      float camMask = clamp(camUpBand + camRightBand, 0.0, 1.0);

      vec3 camColorSrgb   = vec3(0.20, 0.94, 1.0);
      vec3 camColorLinear = toLinear(camColorSrgb);
      float camIntensity  = camMask * CROSS_INTENSITY;
      vec3 camLightLinear = camColorLinear * camIntensity;

      // Gravity cross (magenta)
      vec3 gCenter = normalize(uGravityCenter);
      float gravUpBand = greatCircleBandFaded(
        N, gCenter,
        normalize(uGravityUp),
        uCrossArc,
        uCrossWidth
      );
      float gravRightBand = greatCircleBandFaded(
        N, gCenter,
        normalize(uGravityRight),
        uCrossArc,
        uCrossWidth
      );
      float gravMask = clamp(gravUpBand + gravRightBand, 0.0, 1.0);

      vec3 gravColorSrgb   = vec3(1.0, 0.38, 0.78);
      vec3 gravColorLinear = toLinear(gravColorSrgb);
      float gravIntensity  = gravMask * CROSS_INTENSITY;
      vec3 gravLightLinear = gravColorLinear * gravIntensity;

      // Axis crosses (optional; disabled in Performance for speed)
      vec3 axisLightLinear = vec3(0.0);
      float axisMaskAll = 0.0;
      if (uQuality > 0.5) {
        float axisArc   = 0.7;
        float axisWidth = uCrossWidth;

        float pxMask = 0.0, nxMask = 0.0;
        float pyMask = 0.0, nyMask = 0.0;
        float pzMask = 0.0, nzMask = 0.0;

        {
          vec3 c0 = normalize(vec3(1.0, 0.0, 0.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 1.0, 0.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 0.0, 1.0)),
            axisArc,
            axisWidth
          );
          pxMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        {
          vec3 c0 = normalize(vec3(-1.0, 0.0, 0.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 1.0, 0.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 0.0, 1.0)),
            axisArc,
            axisWidth
          );
          nxMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        {
          vec3 c0 = normalize(vec3(0.0, 1.0, 0.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 0.0, 1.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(1.0, 0.0, 0.0)),
            axisArc,
            axisWidth
          );
          pyMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        {
          vec3 c0 = normalize(vec3(0.0, -1.0, 0.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 0.0, 1.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(1.0, 0.0, 0.0)),
            axisArc,
            axisWidth
          );
          nyMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        {
          vec3 c0 = normalize(vec3(0.0, 0.0, 1.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 1.0, 0.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(1.0, 0.0, 0.0)),
            axisArc,
            axisWidth
          );
          pzMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        {
          vec3 c0 = normalize(vec3(0.0, 0.0, -1.0));
          float upBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(0.0, 1.0, 0.0)),
            axisArc,
            axisWidth
          );
          float rightBand = greatCircleBandFaded(
            N, c0,
            normalize(vec3(1.0, 0.0, 0.0)),
            axisArc,
            axisWidth
          );
          nzMask = clamp(upBand + rightBand, 0.0, 1.0);
        }

        vec3 axisXColorSrgb = vec3(1.0, 0.45, 0.45);
        vec3 axisYColorSrgb = vec3(0.45, 1.0, 0.55);
        vec3 axisZColorSrgb = vec3(0.45, 0.78, 1.0);

        vec3 axisXColorLinear = toLinear(axisXColorSrgb);
        vec3 axisYColorLinear = toLinear(axisYColorSrgb);
        vec3 axisZColorLinear = toLinear(axisZColorSrgb);

        float axisIntensityScale = 0.7;

        axisLightLinear =
            axisXColorLinear * (pxMask + nxMask) * CROSS_INTENSITY * axisIntensityScale +
            axisYColorLinear * (pyMask + nyMask) * CROSS_INTENSITY * axisIntensityScale +
            axisZColorLinear * (pzMask + nzMask) * CROSS_INTENSITY * axisIntensityScale;

        axisMaskAll = clamp(pxMask + nxMask + pyMask + nyMask + pzMask + nzMask, 0.0, 1.0);
      }

      // Band / region
      float pitchDeg = degrees(asin(clamp(N.y, -1.0, 1.0)));
      float rollDeg  = degrees(atan(N.x, N.z));

      float pitchVal = pitchDeg;
      float rollVal  = rollDeg;

      // OR/AND modes are relative to the user-set center. We use absolute distances so the band is
      // symmetric about the chosen center (center = true COM). Per-axis scale lets edge handles stretch.
      if (uBandMode > 1.5 && uBandMode < 3.5) {
        float p = pitchDeg - uCenterPitchDeg;
        float r = wrap180(rollDeg - uCenterRollDeg);
        float sp = max(1e-6, uRectScalePitch);
        float sr = max(1e-6, uRectScaleRoll);
        pitchVal = abs(p) / sp;
        rollVal  = abs(r) / sr;
      }

      float inPitch = unionMembershipLinear(pitchVal);

      float inRoll;
      if (uBandMode < 1.5) {
        // Roll-only is absolute longitude; treat each range as circular to cross the atan2 branch cut.
        inRoll = unionMembershipWrapped360(rollDeg);
      } else {
        inRoll = unionMembershipLinear(rollVal);
      }

      vec3 bandZ = normalize(uBandCenterDir);
      vec3 bandX = normalize(uBandFrameX);
      vec3 bandY = normalize(uBandFrameY);

      bandX = normalize(bandX - dot(bandX, bandZ) * bandZ);
      bandY = normalize(cross(bandZ, bandX));

      vec3 pLocal = vec3(dot(N, bandX), dot(N, bandY), dot(N, bandZ));
      float angRad    = acos(clamp(pLocal.z, -1.0, 1.0));
      float radiusDeg = degrees(angRad);
      float theta     = atan(pLocal.y, pLocal.x);

      float inRangeBand = 0.0;
      float edgeMask = 0.0;
      float glowMask = 0.0;

      // Edge/glow widths (degrees). We tie these loosely to the crosshair stroke width so
      // the UI feels consistent as you zoom.
      float edgeW = max(0.18, (uCrossWidth * 180.0 / 3.14159265) * 0.85);
      float glowW = edgeW * 6.0;

      if (uBandMode < 0.5) {
        // Pitch
        inRangeBand = inPitch;
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float lo = min(uRangeMins[i], uRangeMaxs[i]);
            float hi = max(uRangeMins[i], uRangeMaxs[i]);
            float dLo = abs(pitchVal - lo);
            float dHi = abs(pitchVal - hi);
            edgeMask = max(edgeMask, max(edgePulse(dLo, edgeW), edgePulse(dHi, edgeW)));
            glowMask = max(glowMask, max(edgePulse(dLo, glowW), edgePulse(dHi, glowW)));
          }
        }

      } else if (uBandMode < 1.5) {
        // Roll (wrap-safe)
        inRangeBand = inRoll;
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float lo = uRangeMins[i];
            float hi = uRangeMaxs[i];
            float dLo = dist360(rollDeg, lo);
            float dHi = dist360(rollDeg, hi);
            edgeMask = max(edgeMask, max(edgePulse(dLo, edgeW), edgePulse(dHi, edgeW)));
            glowMask = max(glowMask, max(edgePulse(dLo, glowW), edgePulse(dHi, glowW)));
          }
        }

      } else if (uBandMode < 3.5) {
        // OR/AND: connected outer region (<= hi) minus a central hole (<= lo in both axes).
        float gOuter = (uBandMode < 2.5) ? min(pitchVal, rollVal) : max(pitchVal, rollVal);
        float gHole  = max(pitchVal, rollVal);

        float m = 0.0;
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float rA = uRangeMins[i];
            float rB = uRangeMaxs[i];
            float lo = min(rA, rB);
            float hi = max(rA, rB);

            // Outer membership: value <= hi (one-sided band; no fade at 0)
            float mP = bandMembership(pitchVal, -9999.0, hi);
            float mR = bandMembership(rollVal,  -9999.0, hi);
            float outer = (uBandMode < 2.5) ? max(mP, mR) : (mP * mR);

            // Inner hole: (pitch <= lo) AND (roll <= lo)
            float hole = 0.0;
            if (lo > 1e-6) {
              float hP = bandMembership(pitchVal, -9999.0, lo);
              float hR = bandMembership(rollVal,  -9999.0, lo);
              hole = hP * hR;
            }

            float inside = outer * (1.0 - hole);
            m = max(m, inside);

            // Outer boundary + hole boundary (for nicer outlines)
            edgeMask = max(edgeMask, edgePulse(abs(gOuter - hi), edgeW));
            glowMask = max(glowMask, edgePulse(abs(gOuter - hi), glowW));

            if (lo > 1e-6) {
              edgeMask = max(edgeMask, edgePulse(abs(gHole - lo), edgeW));
              glowMask = max(glowMask, edgePulse(abs(gHole - lo), glowW));
            }
          }
        }
        inRangeBand = m;

      } else if (uBandMode < 4.5) {
        // Circle / ellipse
        float thetaRot = theta - uBandRotationRad;
        float x = radiusDeg * cos(thetaRot);
        float y = radiusDeg * sin(thetaRot);
        float sx = max(1e-6, uEllipseScaleX);
        float sy = max(1e-6, uEllipseScaleY);
        float ellipseVal = sqrt((x/sx)*(x/sx) + (y/sy)*(y/sy));

        inRangeBand = unionMembershipLinear(ellipseVal);

        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float lo = min(uRangeMins[i], uRangeMaxs[i]);
            float hi = max(uRangeMins[i], uRangeMaxs[i]);

            edgeMask = max(edgeMask, edgePulse(abs(ellipseVal - hi), edgeW));
            glowMask = max(glowMask, edgePulse(abs(ellipseVal - hi), glowW));

            // Only draw an inner outline when the ring actually has thickness.
            if (lo > 1e-6) {
              edgeMask = max(edgeMask, edgePulse(abs(ellipseVal - lo), edgeW));
              glowMask = max(glowMask, edgePulse(abs(ellipseVal - lo), glowW));
            }
          }
        }

      } else {
        // Polygon (outer + inner are evaluated independently so the ring can vary per-side)
        float n  = max(3.0, uBandPolySides);
        float thetaRot = theta - uBandRotationRad;

        // Point in the polygon tangent plane (after rotation).
        float x = radiusDeg * cos(thetaRot);
        float y = radiusDeg * sin(thetaRot);

        float gaugeOut = -1e9;
        for (int i = 0; i < MAX_POLY_SIDES; i++) {
          if (float(i) < n) {
            vec3 pl = uPolyPlanesOuter[i];
            float d = max(1e-6, pl.z);
            float proj = x * pl.x + y * pl.y;
            gaugeOut = max(gaugeOut, proj / d);
          }
        }

        float gaugeIn = -1e9;
        for (int i = 0; i < MAX_POLY_SIDES; i++) {
          if (float(i) < n) {
            vec3 pl = uPolyPlanesInner[i];
            float d = max(1e-6, pl.z);
            float proj = x * pl.x + y * pl.y;
            gaugeIn = max(gaugeIn, proj / d);
          }
        }

        float mPoly = 0.0;
        float feather = 0.25;

        for (int r = 0; r < MAX_RANGES; r++) {
          if (r < uRangeCount) {
            float a = uRangeMins[r];
            float b = uRangeMaxs[r];
            float minS = min(a, b);
            float maxS = max(a, b);

            float insideOuter = 1.0 - smoothstep(maxS - feather, maxS + feather, gaugeOut);

            float outsideInner = 1.0;
            if (minS > 1e-6) {
              outsideInner = smoothstep(minS - feather, minS + feather, gaugeIn);
            }

            float mm = clamp(insideOuter * outsideInner, 0.0, 1.0);
            mPoly = max(mPoly, pow(mm, 3.0));

            // Outlines for outer/inner polygon boundaries.
            edgeMask = max(edgeMask, edgePulse(abs(gaugeOut - maxS), edgeW));
            glowMask = max(glowMask, edgePulse(abs(gaugeOut - maxS), glowW));
            if (minS > 1e-6) {
              edgeMask = max(edgeMask, edgePulse(abs(gaugeIn - minS), edgeW));
              glowMask = max(glowMask, edgePulse(abs(gaugeIn - minS), glowW));
            }
          }
        }

        inRangeBand = mPoly;
      }

      float bandMask = clamp(inRangeBand, 0.0, 1.0);
      vec3 bandColorSrgb   = uBandTint;
      vec3 bandColorLinear = toLinear(bandColorSrgb);
      float BAND_INTENSITY = 0.6;
      vec3 bandLightLinear = bandColorLinear * bandMask * BAND_INTENSITY;

      // ---- Center indicator (auto from each range) ---------------------------
      // Band centers are the midpoints of each [min..max] stripe/ring.
      float widthDeg   = uCrossWidth * 180.0 / 3.14159265;
      float lineTolDeg = widthDeg * 1.1;

      float centerMask = 0.0;

      // Crosshair geometry (used for AND / circle / polygon)
      float crossLenDeg   = 2.0;
      float crossThickDeg = widthDeg * 1.1;

      if (uBandMode < 0.5) {
        // Pitch: one latitude midline per range.
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float midLat = 0.5 * (uRangeMins[i] + uRangeMaxs[i]);
            if (abs(pitchDeg - midLat) < lineTolDeg) {
              centerMask = 1.0;
            }
          }
        }
      } else if (uBandMode < 1.5) {
        // Roll: one longitude midline per range (wrap-safe).
        // Use a latitude compensation so the stroke has constant angular thickness
        // (longitude degrees shrink by cos(latitude) near the poles).
        float cosLat = max(0.05, abs(cos(radians(pitchDeg))));
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float midLon = 0.5 * (uRangeMins[i] + uRangeMaxs[i]);
            float dLon = rollDeg - midLon;
            dLon = mod(dLon + 180.0, 360.0) - 180.0;
            if (abs(dLon) * cosLat < lineTolDeg) {
              centerMask = 1.0;
            }
          }
        }
      } else if (uBandMode < 2.5) {
        // Pitch OR Roll: single COM center (one vertical + one horizontal midline).
        if (abs(pitchDeg - uCenterPitchDeg) < lineTolDeg) centerMask = 1.0;
        float dLon0 = rollDeg - uCenterRollDeg;
        dLon0 = mod(dLon0 + 180.0, 360.0) - 180.0;
        float cosLat = max(0.05, abs(cos(radians(pitchDeg))));
        if (abs(dLon0) * cosLat < lineTolDeg) centerMask = 1.0;
      } else if (uBandMode < 3.5) {
        // Pitch AND Roll: single COM crosshair at the region centroid.
        // Use local tangent-plane angles so stroke thickness stays constant everywhere
        // (avoids longitude scaling near the poles).
        float dX0 = abs(degrees(atan(pLocal.x, pLocal.z)));
        float dY0 = abs(degrees(atan(pLocal.y, pLocal.z)));
        bool onVert0 = (dX0 < crossThickDeg && dY0 < crossLenDeg);
        bool onHorz0 = (dY0 < crossThickDeg && dX0 < crossLenDeg);
        if (onVert0 || onHorz0) centerMask = 1.0;
      } else if (uBandMode < 4.5) {
        // Circle: crosshair at center + ring midlines.
        float dX0 = abs(degrees(atan(pLocal.x, pLocal.z)));
        float dY0 = abs(degrees(atan(pLocal.y, pLocal.z)));
        bool onVert0 = (dX0 < crossThickDeg && dY0 < crossLenDeg);
        bool onHorz0 = (dY0 < crossThickDeg && dX0 < crossLenDeg);
        if (onVert0 || onHorz0) centerMask = 1.0;

        // Midline thickness should be constant (not stretched by ellipse axes).
        // Use an approximate signed distance to the ellipse contour in the local
        // tangent plane:
        //   F(x,y) = (x/sx)^2 + (y/sy)^2 - midR^2
        //   dist ≈ F / |grad F|
        float thetaRotC = theta - uBandRotationRad;
        float xC = radiusDeg * cos(thetaRotC);
        float yC = radiusDeg * sin(thetaRotC);
        float sxC = max(1e-6, uEllipseScaleX);
        float syC = max(1e-6, uEllipseScaleY);
        float invSx2 = 1.0 / (sxC * sxC);
        float invSy2 = 1.0 / (syC * syC);
        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float midR = 0.5 * (uRangeMins[i] + uRangeMaxs[i]);
            float F = (xC * xC) * invSx2 + (yC * yC) * invSy2 - midR * midR;
            float gx = 2.0 * xC * invSx2;
            float gy = 2.0 * yC * invSy2;
            float g  = max(1e-6, sqrt(gx * gx + gy * gy));
            float distDeg = F / g;
            if (abs(distDeg) < lineTolDeg) {
              centerMask = 1.0;
            }
          }
        }

      } else {
        // Polygon: crosshair at center + polygon midlines.
        float dX0 = abs(degrees(atan(pLocal.x, pLocal.z)));
        float dY0 = abs(degrees(atan(pLocal.y, pLocal.z)));
        bool onVert0 = (dX0 < crossThickDeg && dY0 < crossLenDeg);
        bool onHorz0 = (dY0 < crossThickDeg && dX0 < crossLenDeg);
        if (onVert0 || onHorz0) centerMask = 1.0;

        float n  = max(3.0, uBandPolySides);
        float thetaRot = theta - uBandRotationRad;

        // Point in the polygon tangent plane (after rotation).
        float xP = radiusDeg * cos(thetaRot);
        float yP = radiusDeg * sin(thetaRot);

        // Midlines: draw the band centerline.
        // For a ring (inner boundary present), build the centerline from vertex-wise
        // midpoints between the INNER(minS) and OUTER(maxS) corners. This guarantees
        // ONE corner per vertex and keeps that corner on the segment from inner->outer.
        vec2 p2 = vec2(xP, yP);
        int nn = int(n);

        for (int i = 0; i < MAX_RANGES; i++) {
          if (i < uRangeCount) {
            float a = uRangeMins[i];
            float b = uRangeMaxs[i];
            float minS = min(a, b);
            float maxS = max(a, b);

            if (minS > 1e-6) {
              float bestD = 1e4;

              // Walk the centerline edges without dynamic array indexing (WebGL1 restriction).
              vec2 outFirst = uPolyVertsOuter[0] * maxS;
              vec2 inFirst  = uPolyVertsInner[0] * minS;

              vec2 outPrev  = outFirst;
              vec2 inPrev   = inFirst;

              vec2 outLast  = outFirst;
              vec2 inLast   = inFirst;

              // Segments: 0->1->2->...->(nn-1)
              for (int e = 1; e < MAX_POLY_SIDES; e++) {
                if (e < nn) {
                  vec2 outCur = uPolyVertsOuter[e] * maxS;
                  vec2 inCur  = uPolyVertsInner[e] * minS;

                  vec2 c0 = 0.5 * (outPrev + inPrev);
                  vec2 c1 = 0.5 * (outCur  + inCur);

                  bestD = min(bestD, distPointSegment(p2, c0, c1));

                  outPrev = outCur;
                  inPrev  = inCur;
                  outLast = outCur;
                  inLast  = inCur;
                }
              }

              // Closing segment: (nn-1)->0
              if (nn >= 3) {
                vec2 c0 = 0.5 * (outLast + inLast);
                vec2 c1 = 0.5 * (outFirst + inFirst);
                bestD = min(bestD, distPointSegment(p2, c0, c1));
              }
              if (bestD < lineTolDeg) centerMask = 1.0;

            } else {
              // Filled shape (no inner boundary): fallback to classic midpoint contour
              float midS = 0.5 * (minS + maxS);
              float distDeg = -1e9;
              for (int e = 0; e < MAX_POLY_SIDES; e++) {
                if (float(e) < n) {
                  vec3 pl = uPolyPlanesOuter[e];
                  float projDeg = xP * pl.x + yP * pl.y;
                  distDeg = max(distDeg, projDeg - midS * pl.z);
                }
              }
              if (abs(distDeg) < lineTolDeg) {
                centerMask = 1.0;
              }
            }
          }
        }

      }

      // Overlay-only pass: draw bands additively on top of the base pass
      if (uPass > 0.5) {
        // Fill + glow + crisp outlines + centerline (alpha is ignored by our blend state).
        vec3 edgeColor   = mix(bandColorSrgb, vec3(1.0), 0.45);
        vec3 glowColor   = mix(bandColorSrgb, vec3(1.0), 0.25);
        vec3 centerColor = mix(bandColorSrgb, vec3(1.0), 0.55);

        // Fade slightly near the sphere rim so overlays feel "attached" to the surface.
        float vis = 0.42 + 0.58 * pow(depthFactor, 0.65);

        float fillAmt   = bandMask   * 0.26;
        float glowAmt   = glowMask   * 0.24;
        float edgeAmt   = edgeMask   * 0.70;
        float centerAmt = centerMask * 0.88;

        vec3 overlayColor =
          bandColorSrgb * fillAmt +
          glowColor     * glowAmt +
          edgeColor     * edgeAmt +
          centerColor   * centerAmt;

        gl_FragColor = vec4(overlayColor * vis, 0.0);
        return;
      }

      float CENTER_INTENSITY = 0.9;
      vec3 centerLightLinear = bandColorLinear * centerMask * CENTER_INTENSITY;

      // Combined cross mask – used for alpha
      float crossMask = clamp(
        camMask + gravMask + axisMaskAll,
        0.0, 1.0
      );

      // ---- Additive lighting in linear space --------------------------------
      vec3 colorLinear =
        sphereLinear +
        camLightLinear +
        gravLightLinear +
        axisLightLinear;

      // Subtle dither to reduce color banding (High only — saves ALU on Performance).
      if (uQuality > 1.5) {
        float dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);
        colorLinear += (dither - 0.5) * 0.003;
      }
      colorLinear = max(colorLinear, vec3(0.0));

      colorLinear = colorLinear / (vec3(1.0) + colorLinear);
      vec3 color = toSRGB(colorLinear);

      float baseAlpha  = 0.2 + 0.8 * depthFactor;
      float crossAlpha = 1.0;
      float useCross   = step(0.001, crossMask);
      float alpha      = mix(baseAlpha, crossAlpha, useCross);

      gl_FragColor = vec4(color, alpha);
    }
  `;

  const program = createProgram(gl, vsSource, fsSource);
  if (!program) {
    // Shader/compiler/linker already reported details to the status banner.
    return;
  }

  gl.useProgram(program);

  const attribPosition = gl.getAttribLocation(program, 'aPosition');

  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]),
    gl.STATIC_DRAW
  );
  gl.enableVertexAttribArray(attribPosition);
  gl.vertexAttribPointer(attribPosition, 2, gl.FLOAT, false, 0, 0);

  const uEyeLoc           = gl.getUniformLocation(program, 'uEye');
  const uForwardLoc       = gl.getUniformLocation(program, 'uForward');
  const uRightLoc         = gl.getUniformLocation(program, 'uRight');
  const uUpLoc            = gl.getUniformLocation(program, 'uUp');
  const uOrthoScaleLoc    = gl.getUniformLocation(program, 'uOrthoScale');
  const uAspectLoc        = gl.getUniformLocation(program, 'uAspect');
  const uPassLoc          = gl.getUniformLocation(program, 'uPass');
  const uBandTintLoc      = gl.getUniformLocation(program, 'uBandTint');
  const uGravityCenterLoc = gl.getUniformLocation(program, 'uGravityCenter');
  const uGravityUpLoc     = gl.getUniformLocation(program, 'uGravityUp');
  const uGravityRightLoc  = gl.getUniformLocation(program, 'uGravityRight');
  const uCamCenterLoc     = gl.getUniformLocation(program, 'uCamCenter');
  const uCamUpLoc         = gl.getUniformLocation(program, 'uCamUp');
  const uCamRightLoc      = gl.getUniformLocation(program, 'uCamRight');
  const uCrossArcLoc      = gl.getUniformLocation(program, 'uCrossArc');
  const uCrossWidthLoc    = gl.getUniformLocation(program, 'uCrossWidth');

  const uBandMinLoc         = gl.getUniformLocation(program, 'uBandMinDeg');
  const uBandMaxLoc         = gl.getUniformLocation(program, 'uBandMaxDeg');
  const uRangeCountLoc      = gl.getUniformLocation(program, 'uRangeCount');
  const uRangeMinsLoc       = gl.getUniformLocation(program, 'uRangeMins[0]');
  const uRangeMaxsLoc       = gl.getUniformLocation(program, 'uRangeMaxs[0]');
  const uBandModeLoc        = gl.getUniformLocation(program, 'uBandMode');
  const uBandPolySidesLoc   = gl.getUniformLocation(program, 'uBandPolySides');
  const uBandCenterDirLoc   = gl.getUniformLocation(program, 'uBandCenterDir');
  const uBandFrameXLoc      = gl.getUniformLocation(program, 'uBandFrameX');
  const uBandFrameYLoc      = gl.getUniformLocation(program, 'uBandFrameY');
  const uBandRotationRadLoc = gl.getUniformLocation(program, 'uBandRotationRad');
  const uCenterPitchDegLoc  = gl.getUniformLocation(program, 'uCenterPitchDeg');
  const uCenterRollDegLoc   = gl.getUniformLocation(program, 'uCenterRollDeg');
  const uRectScalePitchLoc = gl.getUniformLocation(program, 'uRectScalePitch');
  const uRectScaleRollLoc  = gl.getUniformLocation(program, 'uRectScaleRoll');
  const uEllipseScaleXLoc  = gl.getUniformLocation(program, 'uEllipseScaleX');
  const uEllipseScaleYLoc  = gl.getUniformLocation(program, 'uEllipseScaleY');
  const uPolyPlanesOuterLoc= gl.getUniformLocation(program, 'uPolyPlanesOuter[0]');
  const uPolyPlanesInnerLoc= gl.getUniformLocation(program, 'uPolyPlanesInner[0]');
  const uPolyVertsOuterLoc = gl.getUniformLocation(program, 'uPolyVertsOuter[0]');
  const uPolyVertsInnerLoc = gl.getUniformLocation(program, 'uPolyVertsInner[0]');
  const uGlobalInRangeLoc   = gl.getUniformLocation(program, 'uGlobalInRange');
  const uQualityLoc         = gl.getUniformLocation(program, 'uQuality');

  gl.uniform1f(uCrossArcLoc, Math.PI);
  gl.clearColor(0,0,0,0);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  canvas.addEventListener('webglcontextlost', (e) => {
    e.preventDefault();
    setStatus('WebGL context lost. Please reload.');
  });

  // === Canvas size ==========================================================
  function resizeCanvas() {
    const displayWidth  = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    if (!displayWidth || !displayHeight) return;
    const deviceDpr = window.devicePixelRatio || 1;
    // Effective DPR = min(deviceDpr, cap) * scale (lets us trade sharpness for FPS on high‑DPR screens).
    const dpr   = Math.max(0.5, Math.min(deviceDpr, gfxDprCap) * gfxRenderScale);
    const width = Math.floor(displayWidth * dpr);
    const height= Math.floor(displayHeight * dpr);
    if (canvas.width !== width || canvas.height !== height) {
      canvas.width  = width;
      canvas.height = height;
    }
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // === Orientation helper ===================================================
  function getScreenOrientationDegrees() {
    let angle = 0;
    if (window.screen && window.screen.orientation &&
        typeof window.screen.orientation.angle === 'number') {
      angle = window.screen.orientation.angle;
    } else if (typeof window.orientation === 'number') {
      angle = window.orientation;
    }
    if (angle < 0) angle += 360;
    return angle;
  }

  function normalizeDeg360(deg) {
    let d = deg % 360;
    if (d < 0) d += 360;
    return d;
  }

  function getCompassHeadingDeg(e) {
    // Returns a compass heading in degrees:
    //   0 = North, 90 = East, 180 = South, 270 = West
    // Clockwise increasing.
    //
    // Priority:
    //  1) iOS Safari: webkitCompassHeading (already CW from North)
    //  2) Absolute DeviceOrientation alpha: convert with heading = 360 - alpha
    //
    // If no absolute compass is available, returns null.
    if (typeof e.webkitCompassHeading === 'number' && !Number.isNaN(e.webkitCompassHeading)) {
      return normalizeDeg360(e.webkitCompassHeading);
    }
    if (e.absolute === true && typeof e.alpha === 'number' && !Number.isNaN(e.alpha)) {
      const a = normalizeDeg360(e.alpha);
      return normalizeDeg360(360 - a);
    }
    return null;
  }

  // === Gravity dir from inertial angles ====================================
  function updateGravityDirection() {
    const lat = degToRad(inertialPitchDeg);
    const lon = degToRad(inertialRollDeg);
    const y = Math.sin(lat);
    const r = Math.cos(lat);
    const x = r * Math.sin(lon);
    const z = r * Math.cos(lon);
    const len = Math.sqrt(x*x + y*y + z*z);
    gravityDir = (len < 1e-6) ? [0,0,1] : [x/len, y/len, z/len];
  }

  // === Sensors ==============================================================

  function handleOrientation(e) {
    if (e.beta == null || e.gamma == null) return;
    haveSensorData = true;

    // Compass heading (CW from North) when available.
    const headingDeg = getCompassHeadingDeg(e);
    if (headingDeg != null) {
      deviceYawRawDeg = headingDeg;
      lastCompassMs = performance.now();

      let r = degToRad(headingDeg);
      while (r > Math.PI)  r -= Math.PI * 2;
      while (r < -Math.PI) r += Math.PI * 2;
      compassTargetRad = r;

      if (!compassInitialized) {
        compassFilteredRad = compassTargetRad;
        compassInitialized = true;
      }
    } else {
      deviceYawRawDeg = null;
      // Don't clear lastCompassMs here; render() will apply COMPASS_HOLD_MS hysteresis.
    }

    const beta  = e.beta;
    const gamma = e.gamma;
    const orientation = getScreenOrientationDegrees();

    let pitchVal, rollVal;
    if (orientation === 0) {
      pitchVal = beta;
      rollVal  = gamma;
    } else if (orientation === 90) {
      pitchVal = gamma;
      rollVal  = -beta;
    } else if (orientation === 180) {
      pitchVal = -beta;
      rollVal  = -gamma;
    } else if (orientation === 270) {
      pitchVal = -gamma;
      rollVal  = beta;
    } else {
      pitchVal = beta;
      rollVal  = gamma;
    }

    devicePitchDeg = pitchVal;
    deviceRollDeg  = rollVal;

    targetPitchDeg = pitchVal;
    targetRollDeg  = rollVal;
  }
  function handleMotion() {}

  function initSensors() {
    if (sensorsInitialized) return;
    sensorsInitialized = true;

    if (!window.DeviceOrientationEvent) {
      sensorsAvailable = false;
      setStatus('No motion sensors detected.');
      return;
    }

    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then((state) => {
          if (state === 'granted') {
            sensorsAvailable = true;
            window.addEventListener('deviceorientation', handleOrientation, true);
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('devicemotion', handleMotion, true);
            setStatus('Motion sensors active. Drag to rotate. Pinch to zoom. Double‑tap to attach/detach camera.');
          } else {
            sensorsAvailable = false;
            setStatus('Motion sensor permission denied.');
          }
        })
        .catch(() => {
          sensorsAvailable = false;
          setStatus('Motion sensor permission error.');
        });
    } else {
      sensorsAvailable = true;
      window.addEventListener('deviceorientation', handleOrientation, true);
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      window.addEventListener('devicemotion', handleMotion, true);
      setStatus('Motion sensors available. Drag to rotate. Pinch to zoom. Double‑tap to attach/detach camera.');
    }
  }

  // === Audio ================================================================
  function initAudio() {
    if (audioReady) return;
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass) {
      setStatus('Web Audio API not supported.');
      return;
    }
    audioContext = new AudioContextClass();
    audioReady = true;
    if (audioContext.state === 'suspended') audioContext.resume();
  }

  function stopWarningTone() {
    if (!warningOsc) return;
    try { warningOsc.stop(); } catch (e) {}
    warningOsc.disconnect();
    warningGain.disconnect();
    warningOsc = null;
    warningGain = null;
  }

  // distance normalized (0 center, 1 border) using same geometry as band
  function computeAudioDistanceNormalized(band, pitchDegOverride, rollDegOverride) {
    if (!haveSensorData) return 0;

    const mode = band.modeStr;
    const pi   = Math.PI;

    // IMPORTANT: Use canonical pitch/roll derived from the current gravity direction.
    // DeviceOrientation beta/gamma can exceed the shader's pitch domain when the phone is upside-down.
    // The shader (and tap picking) always uses pitch=asin(y) and roll=atan2(x,z), so we mirror that here.
    let pitch = pitchDegOverride;
    let roll  = rollDegOverride;
    if (!Number.isFinite(pitch) || !Number.isFinite(roll)) {
      const pr = dirToPitchRollDeg(gravityDir);
      pitch = pr.pitch;
      roll  = pr.roll;
    }
if (mode === 'pitch') {
      const ranges = band.ranges || getRanges('pitch');
      let best = 1;
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        if (pitch >= r.min && pitch <= r.max) {
          const center = 0.5 * (r.min + r.max);
          const halfWidth = Math.max(Math.abs(r.max - r.min) * 0.5, 1e-3);
          const dist = Math.abs(pitch - center);
          best = Math.min(best, dist / halfWidth);
        }
      }
      return Math.max(0, Math.min(best, 1));
    }

    if (mode === 'roll') {
      const ranges = band.ranges || getRanges('roll');
      let best = 1;
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        if (inAngleBand360(roll, r.min, r.max)) {
          const center = 0.5 * (r.min + r.max);
          const halfWidth = Math.max(Math.abs(r.max - r.min) * 0.5, 1e-3);
          const dist = angleDistanceDeg(roll, center);
          best = Math.min(best, dist / halfWidth);
        }
      }
      return Math.max(0, Math.min(best, 1));
    }

    if (mode === 'circle') {
      const centerDir = tiltToDir(band.centerPitch, band.centerRoll);
      const devDir    = tiltToDir(pitch, roll);

      let dotVal = dot3(centerDir, devDir);
      if (dotVal >  1) dotVal = 1;
      if (dotVal < -1) dotVal = -1;

      const radiusDeg = Math.acos(dotVal) * 180 / pi;

      const ranges = band.ranges || getRanges('circle');
      let best = 1;
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        if (radiusDeg >= r.min && radiusDeg <= r.max) {
          const center = 0.5 * (r.min + r.max);
          const halfWidth = Math.max(Math.abs(r.max - r.min) * 0.5, 1e-3);
          const dist = Math.abs(radiusDeg - center);
          best = Math.min(best, dist / halfWidth);
        }
      }
      return Math.max(0, Math.min(best, 1));
    }

    if (mode === 'polygon') {
      const devDir = tiltToDir(pitch, roll);

      const bandZ = normalize3(bandCenterDir);
      let bandX   = normalize3(bandFrameX);
      let bandY   = normalize3(bandFrameY);

      const dotZX = dot3(bandZ, bandX);
      bandX = normalize3([
        bandX[0] - bandZ[0] * dotZX,
        bandX[1] - bandZ[1] * dotZX,
        bandX[2] - bandZ[2] * dotZX
      ]);
      bandY = normalize3(cross3(bandZ, bandX));

      const pLocalX = dot3(devDir, bandX);
      const pLocalY = dot3(devDir, bandY);
      const pLocalZ = dot3(devDir, bandZ);

      const angRad    = Math.acos(Math.max(-1, Math.min(1, pLocalZ)));
      const radiusDeg = angRad * 180 / pi;

      const theta0  = Math.atan2(pLocalY, pLocalX);
      const rotRad  = (band.rotationDeg || 0) * pi / 180;
      const thetaRot = theta0 - rotRad;

      // Point in polygon tangent plane (after rotation).
      const x = radiusDeg * Math.cos(thetaRot);
      const y = radiusDeg * Math.sin(thetaRot);

      const n       = Math.max(3, band.polySides);

      // Polygon gauges (match shader):
      //   gauge = max_i dot(p, n_i) / d_i
      let gaugeOut = -1e9;
      let gaugeIn  = -1e9;
      for (let i = 0; i < n; i++) {
        const o = i * 3;
        {
          const nx = planesOuter[o];
          const ny = planesOuter[o + 1];
          const d  = Math.max(1e-6, planesOuter[o + 2]);
          const v  = (x * nx + y * ny) / d;
          if (v > gaugeOut) gaugeOut = v;
        }
        {
          const nx = planesInner[o];
          const ny = planesInner[o + 1];
          const d  = Math.max(1e-6, planesInner[o + 2]);
          const v  = (x * nx + y * ny) / d;
          if (v > gaugeIn) gaugeIn = v;
        }
      }

      const ranges = band.ranges || getRanges('polygon');
      let best = 1;
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        const minS = Math.min(r.min, r.max);
        const maxS = Math.max(r.min, r.max);
        if (gaugeOut <= maxS && (minS <= 1e-6 || gaugeIn >= minS)) {
          const span = Math.max(Math.abs(maxS - minS), 1e-3);
          // Normalized "distance-to-centerline" that works for mismatched inner/outer shapes.
          // For the classic homothetic case (inner==outer), this reduces to:
          //   |shapeCoord - mid| / halfWidth
          const uInner = (gaugeIn - minS) / span;
          const uOuter = (maxS - gaugeOut) / span;
          const distNorm = Math.abs(uInner - uOuter);
          best = Math.min(best, distNorm);
        }
      }

      return Math.max(0, Math.min(best, 1));
    }

    // Rectangular region: Pitch OR / AND Roll (multi-range)
    // These modes use absolute distances from the chosen center, with per-axis scaling.
    const relPitch = pitch - band.centerPitch;
    const relRoll  = wrap180(roll - band.centerRoll);

    const sp = Math.max(1e-6, rectScalePitch);
    const sr = Math.max(1e-6, rectScaleRoll);
    const pitchVal = Math.abs(relPitch) / sp;
    const rollVal  = Math.abs(relRoll)  / sr;

    const ranges = band.ranges || getRanges(mode);

    // OR: cross-shaped region with a central hole.
    if (mode === 'pitchOrRoll') {
      let best = 1;
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        const lo = Math.min(r.min, r.max);
        const hi = Math.max(r.min, r.max);

        const outer = (pitchVal <= hi) || (rollVal <= hi);
        const hole  = (lo > 1e-6) && (pitchVal < lo) && (rollVal < lo);
        if (!outer || hole) continue;

        const minCoord = Math.min(pitchVal, rollVal);
        const maxCoord = Math.max(pitchVal, rollVal);

        if (lo <= 1e-6) {
          // No inner cut-out: ramp from axis (0) to outer boundary (1).
          const denom = Math.max(hi, 1e-3);
          best = Math.min(best, minCoord / denom);
        } else {
          // With an inner cut-out: interpolate between inner and outer boundaries.
          const span   = Math.max(hi - lo, 1e-3);
          const dInner = Math.max(0, maxCoord - lo);    // 0 at the hole boundary
          const dOuter = Math.max(0, hi - minCoord);    // 0 at the outer boundary
          const t      = dInner / Math.max(1e-6, (dInner + dOuter));
          const dist   = Math.abs(t - 0.5) * 2.0;
          best = Math.min(best, dist);
        }
      }
      return Math.max(0, Math.min(best, 1));
    }

    // AND: rectangular ring (Chebyshev metric).
    if (mode === 'pitchAndRoll') {
      let best = 1;
      const coord = Math.max(pitchVal, rollVal);
      for (let i = 0; i < ranges.length; i++) {
        const r = ranges[i];
        const lo = Math.min(r.min, r.max);
        const hi = Math.max(r.min, r.max);
        if (coord >= lo && coord <= hi) {
          const center = 0.5 * (lo + hi);
          const halfWidth = Math.max(Math.abs(hi - lo) * 0.5, 1e-3);
          const dist = Math.abs(coord - center);
          best = Math.min(best, dist / halfWidth);
        }
      }
      return Math.max(0, Math.min(best, 1));
    }

    // Fallback: treat as center.
    return 0;
  }

  // distance‑based tone with jump at the border (more drastic)
  function updateWarningTone(distanceNorm, hasSensor, inRange) {
    if (!audioReady || !soundCheckbox.checked || !hasSensor) {
      stopWarningTone();
      return;
    }

    // 0 at center, 1 at the band border
    const inside = Math.max(0, Math.min(distanceNorm, 1));

    // Inside band: smooth ramp
    const MIN_FREQ     = 400;    // center
    const BORDER_FREQ  = 2200;   // at border

    const MIN_GAIN     = 0.0;    // center
    const BORDER_GAIN  = 0.06;   // at border

    // Outside band: **drastic jump**
    const OUTSIDE_FREQ = 4800;   // much higher than border tone
    const OUTSIDE_GAIN = 0.18;   // ~3× louder than at the border

    let freq, gain;

    if (inRange) {
      // Linear ramp from center → border (0–10 region)
      freq = MIN_FREQ  + (BORDER_FREQ  - MIN_FREQ)  * inside;
      gain = MIN_GAIN  + (BORDER_GAIN  - MIN_GAIN)  * inside;
    } else {
      // Outside the band: constant "20" alert level
      freq = OUTSIDE_FREQ;
      gain = OUTSIDE_GAIN;
    }

    // If effectively silent, just fade down
    if (gain < 0.001) {
      if (warningGain && warningGain.gain.setTargetAtTime) {
        const t = audioContext.currentTime;
        warningGain.gain.setTargetAtTime(0, t, 0.03);
      } else if (warningGain) {
        warningGain.gain.value = 0;
      }
      return;
    }

    // Start oscillator if needed
    if (!warningOsc) {
      warningOsc = audioContext.createOscillator();
      warningGain = audioContext.createGain();
      warningOsc.type = 'sine';
      warningOsc.connect(warningGain);
      warningGain.connect(audioContext.destination);
      warningOsc.start();
    }

    const t = audioContext.currentTime;

    if (warningOsc.frequency.setTargetAtTime) {
      warningOsc.frequency.setTargetAtTime(freq, t, 0.03);
    } else {
      warningOsc.frequency.value = freq;
    }

    if (warningGain.gain.setTargetAtTime) {
      warningGain.gain.setTargetAtTime(gain, t, 0.03);
    } else {
      warningGain.gain.value = gain;
    }
  }

  function updateSoundToggleUI() {
    if (!soundToggle || !soundCheckbox) return;
    const on = soundCheckbox.checked;
    soundToggle.textContent = on ? '🔊' : '🔈';
    if (on) soundToggle.classList.remove('muted');
    else   soundToggle.classList.add('muted');
  }


  // === In-band timer beeps (optional) ======================================
  function clampBeepIntervalSec(sec) {
    if (!Number.isFinite(sec)) return 1.0;
    // Allow basically any user value, but keep it sane (and avoid CPU/audio overload).
    // 0.10s is already 10 beeps/sec which is plenty.
    return Math.max(0.10, Math.min(60.0, sec));
  }

  function formatBeepInterval(sec) {
    if (!Number.isFinite(sec)) sec = 1.0;
    // Keep up to 3 decimals, trim trailing zeros.
    const fixed = (sec < 1) ? sec.toFixed(3) : sec.toFixed(2);
    return fixed.replace(/0+$/,'').replace(/\.$/,'');
  }

  function syncBeepTimerSettingsFromUI(opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const commit = options.commit !== false; // default: true
    const force  = options.force === true;

    // Read UI -> state
    if (timerEnabledCheckbox) beepTimerEnabled = !!timerEnabledCheckbox.checked;

    let sec = beepTimerIntervalSec;
    if (timerIntervalInput) {
      const v = parseFloat(timerIntervalInput.value);
      if (Number.isFinite(v)) sec = v;
    }
    sec = clampBeepIntervalSec(sec);

    beepTimerIntervalSec = sec;
    beepTimerIntervalMs  = Math.max(100, Math.round(sec * 1000));

    const secStr = formatBeepInterval(sec);

    // Only normalize the input text when the user isn't actively typing,
    // otherwise you can't enter values like 0.333 (it keeps snapping).
    const inputIsActive = !!(timerIntervalInput && document.activeElement === timerIntervalInput);
    if (timerIntervalInput && commit && (!inputIsActive || force)) {
      timerIntervalInput.value = secStr;
    }

    if (timerIntervalLabel) timerIntervalLabel.textContent = secStr + 's';
    if (timerSummaryEl) timerSummaryEl.textContent = beepTimerEnabled ? ('every ' + secStr + 's') : 'off';
  }

  function formatDurationMs(ms) {
    ms = Math.max(0, ms || 0);
    const totalSec = ms / 1000;
    const hours = Math.floor(totalSec / 3600);
    const minutes = Math.floor((totalSec - hours * 3600) / 60);
    const seconds = totalSec - hours * 3600 - minutes * 60;

    const secStr = seconds.toFixed(1).padStart(4, '0'); // e.g. "03.2"
    if (hours > 0) {
      return String(hours) + ':' + String(minutes).padStart(2,'0') + ':' + secStr;
    }
    return String(minutes).padStart(2,'0') + ':' + secStr;
  }

  function playBeep() {
    if (!audioReady || !audioContext) return;
    // On iOS, contexts can get suspended between interactions.
    if (audioContext.state === 'suspended') {
      try { audioContext.resume(); } catch (e) {}
    }

    // Keep beeps short, and scale slightly with the chosen interval.
    const intervalSec = Math.max(0.10, beepTimerIntervalSec || 1.0);
    const dur = Math.min(0.09, Math.max(0.03, intervalSec * 0.22));
    const freq = 880;  // clean, audible beep
    const peak = 0.14; // not too loud

    const t0 = audioContext.currentTime;

    const osc = audioContext.createOscillator();
    const g   = audioContext.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0, t0);
    g.gain.linearRampToValueAtTime(peak, t0 + 0.004);
    g.gain.linearRampToValueAtTime(0.0, t0 + dur);

    osc.connect(g);
    g.connect(audioContext.destination);

    osc.start(t0);
    osc.stop(t0 + dur + 0.01);

    osc.onended = () => {
      try { osc.disconnect(); } catch (e) {}
      try { g.disconnect(); } catch (e) {}
    };
  }

  function resetBeepTimer(nowMs) {
    beepTimerStartMs    = nowMs;
    beepTimerElapsedMs  = 0;
    beepTimerBeepCount  = 0;
    beepTimerLastIntervalMs = beepTimerIntervalMs;
    beepTimerNextBeepMs = nowMs + beepTimerIntervalMs;
  }

  function tickBeepTimer(nowMs, inRange, hasSensor) {
    // Keep state synced even if user types a new interval.
    syncBeepTimerSettingsFromUI({ commit:false });

    if (!beepTimerEnabled || !hasSensor) {
      // Do not "arm" while disabled; next enable counts as a fresh entry.
      beepTimerWasInRange = false;
      return;
    }

    if (inRange) {
      if (!beepTimerWasInRange) {
        resetBeepTimer(nowMs);
      }

      // If the interval changed while running, re-align the next beep from "now"
      // (keep elapsed + count; just adjust cadence).
      if (beepTimerIntervalMs !== beepTimerLastIntervalMs) {
        beepTimerLastIntervalMs = beepTimerIntervalMs;
        beepTimerNextBeepMs = nowMs + beepTimerIntervalMs;
      }

      beepTimerElapsedMs = nowMs - beepTimerStartMs;

      // Beep only when sound is enabled, and avoid bursts after tab suspend.
      if (soundCheckbox && soundCheckbox.checked && audioReady && !document.hidden) {
        if (!(beepTimerNextBeepMs > 0)) beepTimerNextBeepMs = nowMs + beepTimerIntervalMs;

        // If we fell behind by a lot (e.g., background), resync instead of rapid-fire catchup.
        if (nowMs - beepTimerNextBeepMs > beepTimerIntervalMs * 4) {
          beepTimerNextBeepMs = nowMs + beepTimerIntervalMs;
        }

        let safety = 0;
        while (nowMs >= beepTimerNextBeepMs && safety < 8) {
          playBeep();
          beepTimerBeepCount++;
          beepTimerNextBeepMs += beepTimerIntervalMs;
          safety++;
        }
      }
    } else {
      // Leaving the band stops the timer; next entry resets.
      beepTimerWasInRange = false;
      return;
    }

    beepTimerWasInRange = true;
  }

  function updateBeepTimerReadout(inRange, hasSensor) {
    if (!inBandTimerReadout) return;

    if (!beepTimerEnabled) {
      inBandTimerReadout.textContent = 'Off';
      if (timerSummaryEl) timerSummaryEl.textContent = 'off';
      return;
    }

    // Enabled
    if (!hasSensor) {
      inBandTimerReadout.textContent = 'Waiting…';
      return;
    }

    if (inRange) {
      const count = (beepTimerBeepCount | 0);
      inBandTimerReadout.textContent = formatDurationMs(beepTimerElapsedMs) + ' (' + count + ')';
      return;
    }

    // Out of range
    if (beepTimerElapsedMs > 0) {
      const count = (beepTimerBeepCount | 0);
      inBandTimerReadout.textContent = 'Last ' + formatDurationMs(beepTimerElapsedMs) + ' (' + count + ')';
    } else {
      inBandTimerReadout.textContent = 'Out';
    }
  }


  
  // === CountDown (optional) ================================================
  function clampCountDownGoalSec(sec) {
    if (!Number.isFinite(sec)) return 10.0;
    // Allow a wide range, but keep it sane.
    return Math.max(0.10, Math.min(3600.0, sec));
  }

  function formatCountDownGoal(sec) {
    if (!Number.isFinite(sec)) sec = 10.0;
    // Format for display/input without producing the "10 -> 1" bug.
    // Only trim trailing zeros when there is a decimal point.
    let fixed = (sec < 1) ? sec.toFixed(2) : (sec < 10 ? sec.toFixed(1) : sec.toFixed(0));
    if (fixed.indexOf('.') >= 0) fixed = fixed.replace(/0+$/,'').replace(/\.$/,'');
    return fixed;
  }

  function syncCountDownSettingsFromUI(opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const commit = options.commit !== false; // default: true
    const force  = options.force === true;

    if (countDownEnabledCheckbox) countDownEnabled = !!countDownEnabledCheckbox.checked;

    if (countDownVoiceCheckbox) countDownVoiceEnabled = !!countDownVoiceCheckbox.checked;

    let sec = countDownGoalSec;
    if (countDownGoalInput) {
      const v = parseFloat(countDownGoalInput.value);
      if (Number.isFinite(v)) sec = v;
    }
    sec = clampCountDownGoalSec(sec);

    countDownGoalSec = sec;
    countDownGoalMs  = Math.max(100, Math.round(sec * 1000));

    const secStr = formatCountDownGoal(sec);

    const inputIsActive = !!(countDownGoalInput && document.activeElement === countDownGoalInput);
    if (countDownGoalInput && commit && (!inputIsActive || force)) {
      countDownGoalInput.value = secStr;
    }

    if (countDownSummaryEl) {
      countDownSummaryEl.textContent = countDownEnabled ? ('goal ' + secStr + 's' + (countDownVoiceEnabled ? ' + voice' : '')) : 'off';
    }
  }

  function playGoalBeepPattern() {
    if (!audioReady || !audioContext) return;
    if (audioContext.state === 'suspended') {
      try { audioContext.resume(); } catch (e) {}
    }

    // Triple beep: distinct from the cadence beeps.
    const t0 = audioContext.currentTime;
    const freq = 1175;
    const peak = 0.16;
    const dur  = 0.085;
    const gap  = 0.070;

    for (let i = 0; i < 3; i++) {
      const t = t0 + i * (dur + gap);
      const osc = audioContext.createOscillator();
      const g   = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, t);

      g.gain.setValueAtTime(0.0, t);
      g.gain.linearRampToValueAtTime(peak, t + 0.004);
      g.gain.linearRampToValueAtTime(0.0, t + dur);

      osc.connect(g);
      g.connect(audioContext.destination);

      osc.start(t);
      osc.stop(t + dur + 0.01);

      osc.onended = () => {
        try { osc.disconnect(); } catch (e) {}
        try { g.disconnect(); } catch (e) {}
      };
    }
  }


  // --- CountDown Voice (TTS) --------------------------------------------
  // Optional: speak the remaining whole seconds while counting down.
  // Uses the device text-to-speech engine (SpeechSynthesis API).
  function haveSpeechSynthesis() {
    return (typeof window !== 'undefined'
      && typeof window.speechSynthesis !== 'undefined'
      && typeof window.SpeechSynthesisUtterance !== 'undefined');
  }

  function cancelCountDownSpeech() {
    if (!haveSpeechSynthesis()) return;
    try { window.speechSynthesis.cancel(); } catch (e) {}
  }

  function speakCountDownText(text) {
    if (!haveSpeechSynthesis()) return false;
    try {
      const synth = window.speechSynthesis;

      // If something is already queued up, clear it so we stay in sync with the clock.
      if (synth.speaking || synth.pending) {
        try { synth.cancel(); } catch (e) {}
      }

      const u = new SpeechSynthesisUtterance(String(text));
      u.lang = (navigator && navigator.language) ? navigator.language : 'en-US';
      u.rate = 1.05;
      u.pitch = 1.0;
      u.volume = 1.0;

      try { synth.resume(); } catch (e) {}
      synth.speak(u);
      return true;
    } catch (e) {
      return false;
    }
  }

  function tickCountDownVoice(inRange) {
    if (!countDownVoiceEnabled) return;
    if (!countDownEnabled) return;

    // Only speak while actively in range.
    if (!inRange) return;

    // Respect the global sound toggle.
    if (!(soundCheckbox && soundCheckbox.checked)) return;
    if (document.hidden) return;

    if (!haveSpeechSynthesis()) return;

    const goalMs = Math.max(0, countDownGoalMs || 0);
    const elapsed = Math.max(0, countDownElapsedMs || 0);
    const leftMs = Math.max(0, goalMs - elapsed);

    if (countDownTriggered) {
      if (!countDownVoiceSpokeDone) {
        speakCountDownText('done');
        countDownVoiceSpokeDone = true;
      }
      return;
    }

    // Speak whole seconds remaining (10..1). Never speak 0.
    const leftWhole = Math.max(0, Math.ceil(leftMs / 1000));
    if (leftWhole <= 0) return;

    if (leftWhole !== countDownVoiceLastSpoken) {
      speakCountDownText(leftWhole);
      countDownVoiceLastSpoken = leftWhole;
    }
  }

  function resetCountDown(nowMs) {
    countDownStartMs   = nowMs;
    countDownElapsedMs = 0;
    countDownTriggered = false;
    countDownLastGoalMs = countDownGoalMs;

    // Voice state (speak numbers from the new starting point).
    countDownVoiceLastSpoken = null;
    countDownVoiceSpokeDone  = false;
    cancelCountDownSpeech();
  }

  function tickCountDown(nowMs, inRange, hasSensor) {
    syncCountDownSettingsFromUI({ commit:false });

    if (!countDownEnabled || !hasSensor) {
      // If we were speaking a countdown, stop it when sensors stop or the feature is disabled.
      if (countDownWasInRange) {
        cancelCountDownSpeech();
      }
      countDownWasInRange = false;
      return;
    }

    if (inRange) {
      if (!countDownWasInRange) {
        resetCountDown(nowMs);
      }

      // If the goal changed while running, keep elapsed but re-evaluate trigger.
      if (countDownGoalMs !== countDownLastGoalMs) {
        countDownLastGoalMs = countDownGoalMs;

        // Reset voice tracking so the spoken number matches the new goal immediately.
        countDownVoiceLastSpoken = null;
        countDownVoiceSpokeDone  = false;
        cancelCountDownSpeech();
      }

      countDownElapsedMs = nowMs - countDownStartMs;

      if (!countDownTriggered && countDownElapsedMs >= countDownGoalMs) {
        countDownTriggered = true;

        // Notify (sound if enabled)
        const goalStr = formatCountDownGoal(countDownGoalSec);
        flashMessage('✅ CountDown reached: ' + goalStr + 's', 1500);

        if (soundCheckbox && soundCheckbox.checked && audioReady && !document.hidden) {
          playGoalBeepPattern();
        }
      }
      // Speak countdown numbers (optional).
      tickCountDownVoice(true);
    } else {
      // Leaving the band stops the timer; next entry resets.
      if (countDownWasInRange) {
        cancelCountDownSpeech();
      }
      countDownWasInRange = false;
      return;
    }

    countDownWasInRange = true;
  }

  
  function updateCountDownReadout(inRange, hasSensor) {
    // Update both the Readout row and the CountDown section's live display.
    const setText = (el, s) => { if (el) el.textContent = s; };
    const setProgress = (frac) => {
      if (!countDownProgress) return;
      const f = Math.max(0, Math.min(1, (frac || 0)));
      countDownProgress.style.width = (f * 100).toFixed(1) + '%';
    };

    if (!countDownEnabled) {
      setText(countDownReadout, 'Off');
      setText(countDownLive, 'Off');
      setProgress(0);
      if (countDownSummaryEl) countDownSummaryEl.textContent = 'off';
      return;
    }

    if (!hasSensor) {
      setText(countDownReadout, 'Waiting…');
      setText(countDownLive, 'Waiting…');
      setProgress(0);
      return;
    }

    const goalMs = Math.max(0, countDownGoalMs || 0);
    const elapsed = Math.max(0, countDownElapsedMs || 0);

    if (inRange) {
      if (countDownTriggered) {
        setText(countDownReadout, 'Done ✓');
        setText(countDownLive, 'Done ✓');
        setProgress(1);
      } else {
        const left = Math.max(0, goalMs - elapsed);
        const leftStr = formatDurationMs(left);
        // Show pure time (looks like a real countdown).
        setText(countDownReadout, leftStr);
        setText(countDownLive, leftStr);
        setProgress(goalMs > 0 ? (elapsed / goalMs) : 0);
      }
      return;
    }

    // Out of range
    if (elapsed > 0) {
      if (countDownTriggered) {
        setText(countDownReadout, 'Last Done ✓');
        setText(countDownLive, 'Last Done ✓');
        setProgress(1);
      } else {
        const lastStr = formatDurationMs(elapsed);
        setText(countDownReadout, 'Last ' + lastStr);
        setText(countDownLive, 'Last ' + lastStr);
        setProgress(goalMs > 0 ? Math.min(1, elapsed / goalMs) : 0);
      }
    } else {
      setText(countDownReadout, 'Out');
      setText(countDownLive, 'Out');
      setProgress(0);
    }
  }


    // === Timers per-band (BeepCount + CountDown) ============================
  // Each band owns its own timer settings and runtime state.
  // Timers run for ANY band that is currently in range — you do NOT need to
  // select a band for its countdown/beeps to be audible.
  //
  // Stored per-band (serialized):
  //   band.beepCount: { enabled:boolean, intervalSec:number }
  //   band.countDown: { enabled:boolean, goalSec:number, voice:boolean }
  //
  // Runtime per-band (NOT serialized):
  //   band._beepCountState, band._countDownState
  //
  // If multiple bands overlap, the spoken countdown follows the band with the
  // smallest time remaining.
  let timersVoiceOwnerBandIndex = -1;
  let timersLastBeepWallMs = -Infinity;
  let timersLastBeepFocusBandIndex = -1;
  let timersLastCountDownFocusBandIndex = -1;

  function bandDisplayName(i) {
    const b = (Array.isArray(bands) && i >= 0 && i < bands.length) ? bands[i] : null;
    const n = (b && typeof b.name === 'string' && b.name.trim()) ? b.name.trim() : '';
    return n ? n : ('Band ' + (i + 1));
  }

  function anyBandHasBeepCountEnabled() {
    if (!Array.isArray(bands)) return false;
    for (let i = 0; i < bands.length; i++) {
      const b = bands[i];
      if (!b || b.enabled === false) continue;
      ensureBandTimerConfig(b);
      if (b.beepCount && b.beepCount.enabled) return true;
    }
    return false;
  }

  function anyBandHasCountDownEnabled() {
    if (!Array.isArray(bands)) return false;
    for (let i = 0; i < bands.length; i++) {
      const b = bands[i];
      if (!b || b.enabled === false) continue;
      ensureBandTimerConfig(b);
      if (b.countDown && b.countDown.enabled) return true;
    }
    return false;
  }

  function resetBeepCountStateForBand(band, nowMs, intervalMs) {
    const st = band._beepCountState;
    st.startMs = nowMs;
    st.elapsedMs = 0;
    st.beepCount = 0;
    st.lastIntervalMs = intervalMs;
    st.nextBeepMs = nowMs + intervalMs;
  }

  function tickBeepCountForBand(band, nowMs, inRange, hasSensor) {
    ensureBandTimerConfig(band);
    const cfg = band.beepCount || {};
    const st = band._beepCountState;

    const enabled = !!cfg.enabled;

    if (!enabled || !hasSensor || band.enabled === false) {
      // Do not arm while disabled; next enable counts as a fresh entry.
      st.wasInRange = false;
      return;
    }

    const intervalSec = clampBeepIntervalSec(cfg.intervalSec);
    const intervalMs = Math.max(100, Math.round(intervalSec * 1000));

    // If interval changed while running, resync.
    if (st.lastIntervalMs !== intervalMs) {
      st.lastIntervalMs = intervalMs;
      if (st.wasInRange) {
        st.nextBeepMs = nowMs + intervalMs;
      }
    }

    if (inRange) {
      if (!st.wasInRange) {
        resetBeepCountStateForBand(band, nowMs, intervalMs);
      }

      st.elapsedMs = nowMs - st.startMs;

      // Beep only when sound is enabled, and avoid bursts after tab suspend.
      if (soundCheckbox && soundCheckbox.checked && audioReady && !document.hidden) {
        if (!(st.nextBeepMs > 0)) st.nextBeepMs = nowMs + intervalMs;

        // If we fell behind by a lot (e.g., background), resync instead of rapid-fire catchup.
        if (nowMs - st.nextBeepMs > intervalMs * 4) {
          st.nextBeepMs = nowMs + intervalMs;
        }

        let safety = 0;
        while (nowMs >= st.nextBeepMs && safety < 8) {
          // Avoid multi-band beep pileups on the same frame.
          if (nowMs - timersLastBeepWallMs > 60) {
            playBeep();
            timersLastBeepWallMs = nowMs;
          }
          st.beepCount++;
          st.nextBeepMs += intervalMs;
          safety++;
        }
      }

      st.wasInRange = true;
    } else {
      // Leaving the band stops the timer; next entry resets.
      st.wasInRange = false;
      return;
    }
  }

  function resetCountDownStateForBand(band, nowMs, goalMs) {
    const st = band._countDownState;
    st.startMs = nowMs;
    st.elapsedMs = 0;
    st.triggered = false;
    st.lastGoalMs = goalMs;

    // Voice state (speak numbers from the new starting point).
    st.voiceLastSpoken = null;
    st.voiceSpokeDone = false;
  }

  function tickCountDownForBand(band, nowMs, inRange, hasSensor) {
    ensureBandTimerConfig(band);
    const cfg = band.countDown || {};
    const st = band._countDownState;

    const enabled = !!cfg.enabled;

    if (!enabled || !hasSensor || band.enabled === false) {
      st.wasInRange = false;
      return;
    }

    const goalSec = clampCountDownGoalSec(cfg.goalSec);
    const goalMs = Math.max(100, Math.round(goalSec * 1000));

    if (inRange) {
      if (!st.wasInRange) {
        resetCountDownStateForBand(band, nowMs, goalMs);
      }

      // Goal changed while running: keep elapsed but reset voice tracking.
      if (st.lastGoalMs !== goalMs) {
        st.lastGoalMs = goalMs;
        st.voiceLastSpoken = null;
        st.voiceSpokeDone = false;
      }

      st.elapsedMs = nowMs - st.startMs;

      if (!st.triggered && st.elapsedMs >= goalMs) {
        st.triggered = true;

        // Notify: distinct from the cadence beeps.
        if (soundCheckbox && soundCheckbox.checked && audioReady && !document.hidden) {
          playGoalBeepPattern();
        }
      }

      st.wasInRange = true;
    } else {
      // Leaving the band stops the timer; next entry resets.
      st.wasInRange = false;
      return;
    }
  }

  function pickCountDownVoiceOwner(inRangeSet, hasSensor) {
    if (!hasSensor) return -1;

    // Respect the global sound toggle.
    if (!(soundCheckbox && soundCheckbox.checked)) return -1;
    if (document.hidden) return -1;

    if (!haveSpeechSynthesis()) return -1;

    if (!(inRangeSet instanceof Set) || inRangeSet.size === 0) return -1;

    let best = -1;
    let bestLeft = Infinity;

    inRangeSet.forEach((i) => {
      const band = (Array.isArray(bands) && i >= 0 && i < bands.length) ? bands[i] : null;
      if (!band || band.enabled === false) return;
      ensureBandTimerConfig(band);

      const cfg = band.countDown || {};
      if (!cfg.enabled || !cfg.voice) return;

      const goalSec = clampCountDownGoalSec(cfg.goalSec);
      const goalMs = Math.max(100, Math.round(goalSec * 1000));
      const st = band._countDownState || {};
      const elapsed = Math.max(0, +st.elapsedMs || 0);
      const left = Math.max(0, goalMs - elapsed);

      if (left < bestLeft) {
        bestLeft = left;
        best = i;
      }
    });

    return best;
  }

  function tickCountDownVoiceForBandIndex(bandIndex) {
    if (!(Array.isArray(bands) && bandIndex >= 0 && bandIndex < bands.length)) return;
    const band = bands[bandIndex];
    if (!band || band.enabled === false) return;

    ensureBandTimerConfig(band);

    const cfg = band.countDown || {};
    const st = band._countDownState;

    if (!cfg.enabled || !cfg.voice) return;

    // Only speak while actively in range.
    if (!st.wasInRange) return;

    // Respect the global sound toggle.
    if (!(soundCheckbox && soundCheckbox.checked)) return;
    if (document.hidden) return;

    if (!haveSpeechSynthesis()) return;

    const goalSec = clampCountDownGoalSec(cfg.goalSec);
    const goalMs = Math.max(100, Math.round(goalSec * 1000));
    const elapsed = Math.max(0, +st.elapsedMs || 0);
    const leftMs = Math.max(0, goalMs - elapsed);

    if (st.triggered) {
      if (!st.voiceSpokeDone) {
        try { cancelCountDownSpeech(); } catch (_) {}
        speakCountDownText('done');
        st.voiceSpokeDone = true;
      }
      return;
    }

    // Speak whole seconds remaining (10..1). Never speak 0.
    const leftWhole = Math.max(0, Math.ceil(leftMs / 1000));
    if (leftWhole <= 0) return;

    if (leftWhole !== st.voiceLastSpoken) {
      // Cancel any queued speech to avoid overlap/backlog.
      try { cancelCountDownSpeech(); } catch (_) {}
      speakCountDownText(leftWhole);
      st.voiceLastSpoken = leftWhole;
    }
  }

  function tickTimersAllBands(nowMs, inRangeSet, hasSensor) {
    // Update per-band timer states.
    if (!Array.isArray(bands) || bands.length === 0) return;

    for (let i = 0; i < bands.length; i++) {
      const band = bands[i];
      if (!band) continue;

      const inRange = !!(hasSensor && inRangeSet instanceof Set && inRangeSet.has(i));
      tickBeepCountForBand(band, nowMs, inRange, hasSensor);
      tickCountDownForBand(band, nowMs, inRange, hasSensor);
    }

    // Spoken countdown follows the "best" in-range band.
    const newOwner = pickCountDownVoiceOwner(inRangeSet, hasSensor);
    if (newOwner !== timersVoiceOwnerBandIndex) {
      timersVoiceOwnerBandIndex = newOwner;
      try { cancelCountDownSpeech(); } catch (_) {}
    }
    if (timersVoiceOwnerBandIndex >= 0) {
      tickCountDownVoiceForBandIndex(timersVoiceOwnerBandIndex);
    }
  }

  function updateTimersReadouts(nowMs, inRangeSet, hasSensor) {
    // --- BeepCount readout (Readout card row) ---
    const haveAnyBeep = anyBandHasBeepCountEnabled();

    if (inBandTimerReadout) {
      if (!haveAnyBeep) {
        inBandTimerReadout.textContent = 'Off';
      } else if (!hasSensor) {
        inBandTimerReadout.textContent = 'Waiting…';
      } else {
        // Choose an in-range band with BeepCount enabled (prefer the soonest next beep).
        let focus = -1;
        let bestDt = Infinity;

        if (inRangeSet instanceof Set && inRangeSet.size > 0) {
          inRangeSet.forEach((i) => {
            const b = (i >= 0 && i < bands.length) ? bands[i] : null;
            if (!b || b.enabled === false) return;
            ensureBandTimerConfig(b);
            if (!(b.beepCount && b.beepCount.enabled)) return;
            const st = b._beepCountState || {};
            const dt = (st.nextBeepMs > 0) ? (st.nextBeepMs - nowMs) : Infinity;
            if (dt < bestDt) {
              bestDt = dt;
              focus = i;
            }
          });
        }

        if (focus >= 0) {
          const b = bands[focus];
          ensureBandTimerConfig(b);
          const st = b._beepCountState;
          const elapsed = Math.max(0, +st.elapsedMs || 0);
          const count = (st.beepCount | 0);
          timersLastBeepFocusBandIndex = focus;
          inBandTimerReadout.textContent = bandDisplayName(focus) + ' ' + formatDurationMs(elapsed) + ' (' + count + ')';
        } else {
          // No in-range BeepCount: show last if available.
          const last = timersLastBeepFocusBandIndex;
          if (last >= 0 && last < bands.length) {
            const b = bands[last];
            ensureBandTimerConfig(b);
            const st = b._beepCountState;
            const elapsed = Math.max(0, +st.elapsedMs || 0);
            const count = (st.beepCount | 0);
            if (elapsed > 0) {
              inBandTimerReadout.textContent = bandDisplayName(last) + ' Last ' + formatDurationMs(elapsed) + ' (' + count + ')';
            } else {
              inBandTimerReadout.textContent = 'Out';
            }
          } else {
            inBandTimerReadout.textContent = 'Out';
          }
        }
      }
    }

    // --- CountDown readout + live display + progress bar ---
    const haveAnyCd = anyBandHasCountDownEnabled();

    const setText = (el, s) => { if (el) el.textContent = s; };
    const setProgress = (frac) => {
      if (!countDownProgress) return;
      const f = Math.max(0, Math.min(1, (frac || 0)));
      countDownProgress.style.width = (f * 100).toFixed(1) + '%';
    };

    if (!haveAnyCd) {
      setText(countDownReadout, 'Off');
      setText(countDownLive, 'Off');
      setProgress(0);
      return;
    }

    if (!hasSensor) {
      setText(countDownReadout, 'Waiting…');
      setText(countDownLive, 'Waiting…');
      setProgress(0);
      return;
    }

    // Pick an in-range countdown band (prefer the smallest time remaining).
    let focusCd = -1;
    let bestLeft = Infinity;

    if (inRangeSet instanceof Set && inRangeSet.size > 0) {
      inRangeSet.forEach((i) => {
        const b = (i >= 0 && i < bands.length) ? bands[i] : null;
        if (!b || b.enabled === false) return;
        ensureBandTimerConfig(b);
        if (!(b.countDown && b.countDown.enabled)) return;

        const goalSec = clampCountDownGoalSec(b.countDown.goalSec);
        const goalMs = Math.max(100, Math.round(goalSec * 1000));
        const st = b._countDownState || {};
        const elapsed = Math.max(0, +st.elapsedMs || 0);
        const left = Math.max(0, goalMs - elapsed);

        if (left < bestLeft) {
          bestLeft = left;
          focusCd = i;
        }
      });
    }

    if (focusCd >= 0) {
      const b = bands[focusCd];
      ensureBandTimerConfig(b);
      const cfg = b.countDown || {};
      const st = b._countDownState;

      const goalSec = clampCountDownGoalSec(cfg.goalSec);
      const goalMs = Math.max(100, Math.round(goalSec * 1000));
      const elapsed = Math.max(0, +st.elapsedMs || 0);
      const leftMs = Math.max(0, goalMs - elapsed);

      timersLastCountDownFocusBandIndex = focusCd;

      if (st.triggered) {
        setText(countDownReadout, bandDisplayName(focusCd) + ' Done');
        setText(countDownLive, bandDisplayName(focusCd) + ' Done');
        setProgress(1);
      } else {
        const leftStr = formatDurationMs(leftMs);
        setText(countDownReadout, bandDisplayName(focusCd) + ' ' + leftStr);
        setText(countDownLive, bandDisplayName(focusCd) + ' ' + leftStr);
        setProgress(goalMs > 0 ? Math.min(1, elapsed / goalMs) : 0);
      }
    } else {
      // No in-range CountDown: show last if available, otherwise Out.
      const last = timersLastCountDownFocusBandIndex;
      if (last >= 0 && last < bands.length) {
        const b = bands[last];
        ensureBandTimerConfig(b);
        const cfg = b.countDown || {};
        const st = b._countDownState;

        const goalSec = clampCountDownGoalSec(cfg.goalSec);
        const goalMs = Math.max(100, Math.round(goalSec * 1000));
        const elapsed = Math.max(0, +st.elapsedMs || 0);
        const leftMs = Math.max(0, goalMs - elapsed);

        if (elapsed > 0) {
          const lastStr = formatDurationMs(leftMs);
          setText(countDownReadout, bandDisplayName(last) + ' Last ' + lastStr);
          setText(countDownLive, bandDisplayName(last) + ' Last ' + lastStr);
          setProgress(goalMs > 0 ? Math.min(1, elapsed / goalMs) : 0);
        } else {
          setText(countDownReadout, 'Out');
          setText(countDownLive, 'Out');
          setProgress(0);
        }
      } else {
        setText(countDownReadout, 'Out');
        setText(countDownLive, 'Out');
        setProgress(0);
      }
    }
  }

  // === Timers config is stored per-band (edited via the active band UI) ===
function ensureBandTimerConfig(band) {
    if (!band || typeof band !== 'object') return;

    if (!band.beepCount || typeof band.beepCount !== 'object') {
      band.beepCount = { enabled: false, intervalSec: 1.0 };
    } else {
      band.beepCount.enabled = !!band.beepCount.enabled;
      if (!(typeof band.beepCount.intervalSec === 'number' && Number.isFinite(band.beepCount.intervalSec))) {
        band.beepCount.intervalSec = 1.0;
      }
    }

    if (!band.countDown || typeof band.countDown !== 'object') {
      band.countDown = { enabled: false, goalSec: 10.0, voice: true };
    } else {
      band.countDown.enabled = !!band.countDown.enabled;
      if (!(typeof band.countDown.goalSec === 'number' && Number.isFinite(band.countDown.goalSec))) {
        band.countDown.goalSec = 10.0;
      }
      if (typeof band.countDown.voice !== 'boolean') band.countDown.voice = true;
    }

    if (!band._beepCountState || typeof band._beepCountState !== 'object') {
      band._beepCountState = {
        wasInRange: false,
        startMs: 0,
        nextBeepMs: 0,
        elapsedMs: 0,
        beepCount: 0,
        lastIntervalMs: 1000
      };
    }

    if (!band._countDownState || typeof band._countDownState !== 'object') {
      band._countDownState = {
        wasInRange: false,
        startMs: 0,
        elapsedMs: 0,
        triggered: false,
        lastGoalMs: 10000,
        voiceLastSpoken: null,
        voiceSpokeDone: false
      };
    }
  }

  function saveTimersToBand(band) {
    if (!band) return;
    ensureBandTimerConfig(band);

    // Settings only (runtime state is per-band and updated continuously).
    band.beepCount.enabled = !!beepTimerEnabled;
    band.beepCount.intervalSec = beepTimerIntervalSec;

    band.countDown.enabled = !!countDownEnabled;
    band.countDown.goalSec = countDownGoalSec;
    band.countDown.voice = !!countDownVoiceEnabled;
  }

  function loadTimersFromBand(band) {
    if (!band) return;
    ensureBandTimerConfig(band);

    // Settings -> UI state (does NOT affect runtime timers, which always follow in-range bands)
    const bc = band.beepCount || {};
    beepTimerEnabled = !!bc.enabled;
    const bcSec = (typeof bc.intervalSec === 'number' && Number.isFinite(bc.intervalSec)) ? bc.intervalSec : 1.0;
    beepTimerIntervalSec = clampBeepIntervalSec(bcSec);
    beepTimerIntervalMs  = Math.max(100, Math.round(beepTimerIntervalSec * 1000));

    const cd = band.countDown || {};
    countDownEnabled = !!cd.enabled;
    const cdSec = (typeof cd.goalSec === 'number' && Number.isFinite(cd.goalSec)) ? cd.goalSec : 10.0;
    countDownGoalSec = clampCountDownGoalSec(cdSec);
    countDownGoalMs  = Math.max(100, Math.round(countDownGoalSec * 1000));
    countDownVoiceEnabled = (typeof cd.voice === 'boolean') ? cd.voice : true;

    // Push to UI controls
    if (timerEnabledCheckbox) timerEnabledCheckbox.checked = !!beepTimerEnabled;
    if (timerIntervalInput) timerIntervalInput.value = String(beepTimerIntervalSec);

    if (countDownEnabledCheckbox) countDownEnabledCheckbox.checked = !!countDownEnabled;
    if (countDownGoalInput) countDownGoalInput.value = String(countDownGoalSec);
    if (countDownVoiceCheckbox) countDownVoiceCheckbox.checked = !!countDownVoiceEnabled;

    // Refresh summaries/labels
    syncBeepTimerSettingsFromUI({ commit:true, force:true });
    syncCountDownSettingsFromUI({ commit:true, force:true });
  }

  // === Settings & overlay state ============================================
let overlayOpen      = false;

// Bottom-sheet sizing (grabber can resize / expand / dismiss)
let sheetHeightPx = null;

function getViewportHeightPx() {
  const vv = (window.visualViewport && Number.isFinite(window.visualViewport.height)) ? window.visualViewport : null;
  const vh = vv ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 800);
  return vh;
}


function getViewportWidthPx() {
  const vv = (window.visualViewport && Number.isFinite(window.visualViewport.width)) ? window.visualViewport : null;
  const vw = vv ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 800);
  return vw;
}

// Treat "landscape" as wide enough to be stable (avoid jitter near square aspect ratios).
function isLandscapeUI() {
  const vw = getViewportWidthPx();
  const vh = getViewportHeightPx();
  return vw > vh * 1.05;
}

function updateOrientationClass() {
  const landscape = isLandscapeUI();
  document.body.classList.toggle('landscape', landscape);

  // Collapse icon direction should match the sheet direction:
  // - Portrait: bottom sheet => down chevron
  // - Landscape: side sheet (panel on the left) => left chevron
  if (overlayCloseBtn) {
    overlayCloseBtn.textContent = landscape ? '◂' : '▾';
  }

  // Keep the scene layout consistent after orientation/layout changes.
  // (updateSceneLayoutForSheet is function-declared below and is hoisted.)
  try { requestAnimationFrame(updateSceneLayoutForSheet); } catch (_) {}
}

// Apply once on load and keep it updated.
updateOrientationClass();
window.addEventListener('resize', updateOrientationClass);
window.addEventListener('orientationchange', updateOrientationClass);
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', updateOrientationClass);
}

function getSheetMaxPx() {
  if (isLandscapeUI()) {
    const vw = getViewportWidthPx();
    // Side sheet: keep 12px gutters on both sides.
    return Math.max(260, vw - 24);
  }
  const vh = getViewportHeightPx();
  // Bottom sheet: the sheet is anchored with bottom: 12px,
  // so we leave exactly that much room to avoid pushing it off-screen.
  return Math.max(240, vh - 12);
}
function getSheetMinPx() {
  if (isLandscapeUI()) {
    const vw = getViewportWidthPx();
    const maxPx = getSheetMaxPx();
    // Minimum usable width for controls in landscape.
    return Math.min(maxPx, Math.max(260, vw * 0.26));
  }
  const vh = getViewportHeightPx();
  const maxPx = getSheetMaxPx();
  return Math.min(maxPx, Math.max(220, vh * 0.32));
}
function getSheetCollapsedPx() {
  const maxPx = getSheetMaxPx();
  const minPx = getSheetMinPx();
  // "Shrink" detent: open to ~half the available size so the user can still
  // see the sphere clearly while adjusting settings.
  return Math.max(minPx, Math.min(maxPx, maxPx * 0.50));
}

// Keep the sphere visible when the sheet is open in "shrink" mode by reserving
// the space above the sheet for the canvas scene.
function updateSceneLayoutForSheet() {
  if (!canvas) return;

  const vh = getViewportHeightPx();
  const vw = getViewportWidthPx();
  const gutter = 10;

  // Default: full scene.
  let targetH = vh;
  let targetW = vw;
  let targetX = 0;

  if (overlayOpen && overlayEl) {
    const maxPx = getSheetMaxPx();
    const collapsed = getSheetCollapsedPx();
    const rect = overlayEl.getBoundingClientRect();

    // In portrait, sheetSize = height. In landscape, sheetSize = width.
    const sheetSize = Number.isFinite(sheetHeightPx)
      ? sheetHeightPx
      : (isLandscapeUI() ? rect.width : rect.height);

    // If the sheet is effectively closed (dragged to ~0), don't reserve space.
    if (sheetSize > 1) {
      if (isLandscapeUI()) {
        const leftInset = 12; // must match CSS: body.landscape #overlay { left: 12px }
        if (sheetSize <= collapsed) {
          // Split view: sphere gets the space to the RIGHT of the side panel.
          const rightSpace = vw - (leftInset + sheetSize) - gutter;
          targetW = Math.max(220, Math.floor(rightSpace));
          targetW = Math.min(vw, targetW);

          // Anchor the scene to the right so the sphere stays on the right half.
          targetX = Math.max(0, Math.floor(vw - targetW));
        } else {
          // Past the half-width detent: grow the scene back toward full width so the
          // "fully expanded" sheet also has the largest sphere behind it.
          const rightSpaceCollapsed = vw - (leftInset + collapsed) - gutter;
          const sceneCollapsed = Math.max(220, Math.floor(rightSpaceCollapsed));

          const denom = Math.max(1e-6, (maxPx - collapsed));
          const t = Math.max(0, Math.min(1, (sheetSize - collapsed) / denom));

          targetW = sceneCollapsed + (vw - sceneCollapsed) * t;
          targetW = Math.min(vw, targetW);
          targetX = Math.max(0, Math.floor(vw - targetW));
        }
        // In landscape the scene uses full height.
        targetH = vh;
      } else {
        const bottomInset = 12; // must match #overlay { bottom: 12px }
        if (sheetSize <= collapsed) {
          // Split view (top half visible): reserve space ABOVE the bottom sheet.
          const topEdge = vh - bottomInset - sheetSize;
          targetH = Math.max(220, Math.floor(topEdge - gutter));
        } else {
          // Past the half-height detent: grow the scene back toward full height so the
          // fully expanded sheet also has the largest sphere behind it.
          const topEdgeCollapsed = vh - bottomInset - collapsed;
          const sceneCollapsed = Math.max(220, Math.floor(topEdgeCollapsed - gutter));

          const denom = Math.max(1e-6, (maxPx - collapsed));
          const t = Math.max(0, Math.min(1, (sheetSize - collapsed) / denom));

          targetH = sceneCollapsed + (vh - sceneCollapsed) * t;
        }
        targetW = vw;
      }
    }
  }

  // Always set explicit px sizes so transitions are smooth and cross-browser.
  canvas.style.setProperty('--sceneH', Math.floor(targetH) + 'px');
  canvas.style.setProperty('--sceneW', Math.floor(targetW) + 'px');
  canvas.style.setProperty('--sceneX', Math.floor(targetX) + 'px');

  // The render loop already calls resizeCanvas() once per frame before drawing.
  // Avoid resizing here (which can clear after a draw in the same frame).
}


function applySheetHeight(px, allowDismiss = false) {
  if (!overlayEl) return;
  const maxPx = getSheetMaxPx();
  // While dragging downward we allow the sheet to go all the way to 0px
  // so the user can dismiss it interactively.
  const minPx = allowDismiss ? 0 : getSheetMinPx();
  const clamped = Math.max(minPx, Math.min(maxPx, px));
  sheetHeightPx = clamped;
  overlayEl.style.setProperty('--sheetMaxH', clamped.toFixed(0) + 'px');

  // Keep the scene layout in sync with the current detent.
  // We defer by one frame so layout has updated before reading rects.
  requestAnimationFrame(updateSceneLayoutForSheet);

  if (sheetGrabber) {
    const collapsed = getSheetCollapsedPx();
    const mid = (collapsed + maxPx) * 0.5;
    const expanded = (clamped >= mid);
    sheetGrabber.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  }
}

function toggleSheetExpanded() {
  if (!overlayOpen || !overlayEl) return;
  const maxPx = getSheetMaxPx();
  const collapsed = getSheetCollapsedPx();
  const h = Number.isFinite(sheetHeightPx) ? sheetHeightPx : overlayEl.getBoundingClientRect()[isLandscapeUI() ? 'width' : 'height'];
  const mid = (collapsed + maxPx) * 0.5;
  const wantExpanded = !(h >= mid);
  applySheetHeight(wantExpanded ? maxPx : collapsed);
  saveSettings();
}

function setOverlayOpen(open) {
  overlayOpen = !!open;
  if (!overlayEl) return;

  if (overlayOpen) {
    overlayEl.classList.add('open');
    document.body.classList.remove('sheet-dragging');

    // When opening, always start at the shrink detent (half screen).
    const collapsed = getSheetCollapsedPx();
    sheetHeightPx = collapsed;
    applySheetHeight(collapsed);
  } else {
    overlayEl.classList.remove('open');
    overlayEl.classList.remove('sheet-dragging');
    document.body.classList.remove('sheet-dragging');

    // Reset height so the next open starts in shrink mode.
    sheetHeightPx = getSheetCollapsedPx();
  }

  // Keep the launcher button in sync (only shown when the sheet is closed).
  
  // --- CountDown -------------------------------------------------------
  if (countDownEnabledCheckbox) {
    countDownEnabledCheckbox.addEventListener('change', () => {
      syncCountDownSettingsFromUI({ commit:true });

      // Apply to the active band's config immediately (runtime follows in-range bands).
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.countDown.enabled = !!countDownEnabled;
          b.countDown.goalSec = countDownGoalSec;
          b.countDown.voice = !!countDownVoiceEnabled;
        }
      } catch (_) {}

      saveSettings();
    });
  }

  if (countDownVoiceCheckbox) {
    countDownVoiceCheckbox.addEventListener('change', () => {
      syncCountDownSettingsFromUI({ commit:true });

      // Apply to the active band's config immediately.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.countDown.enabled = !!countDownEnabled;
          b.countDown.goalSec = countDownGoalSec;
          b.countDown.voice = !!countDownVoiceEnabled;

          // If voice is toggled on mid-run, allow an immediate spoken update.
          if (b._countDownState) {
            b._countDownState.voiceLastSpoken = null;
            b._countDownState.voiceSpokeDone = false;
          }
        }
      } catch (_) {}

      // If we just muted the currently-speaking band, stop speech immediately.
      if (!countDownVoiceEnabled && timersVoiceOwnerBandIndex === activeBandIndex) {
        try { cancelCountDownSpeech(); } catch (_) {}
      }

      saveSettings();
    });
  }

  if (countDownGoalInput) {
    countDownGoalInput.addEventListener('input', () => {
      // Live update without saving on every keystroke.
      syncCountDownSettingsFromUI({ commit:false });

      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.countDown.goalSec = countDownGoalSec;

          // Allow the voice to refresh immediately at the new goal.
          if (b._countDownState) {
            b._countDownState.voiceLastSpoken = null;
            b._countDownState.voiceSpokeDone = false;
          }
        }
      } catch (_) {}

      // (no save on every keystroke)
    });

    countDownGoalInput.addEventListener('change', () => {
      syncCountDownSettingsFromUI({ commit:true });

      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.countDown.goalSec = countDownGoalSec;

          // Refresh voice tracking for the new goal.
          if (b._countDownState) {
            b._countDownState.voiceLastSpoken = null;
            b._countDownState.voiceSpokeDone = false;
          }
        }
      } catch (_) {}

      saveSettings();
    });
  }

  if (countDownResetBtn) {
    countDownResetBtn.addEventListener('click', () => {
      // Reset the active band's CountDown runtime state.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          const st = b._countDownState;
          st.wasInRange = false; // next tick treats it like a fresh entry (if in-range)
          st.elapsedMs = 0;
          st.triggered = false;
          st.voiceLastSpoken = null;
          st.voiceSpokeDone = false;
          st.startMs = performance.now();
        }
      } catch (_) {}

      if (timersVoiceOwnerBandIndex === activeBandIndex) {
        try { cancelCountDownSpeech(); } catch (_) {}
      }
    });
  }

  // Goal presets (5s, 10s, 20s, 60s)
  Array.from(document.querySelectorAll('[data-countdown-preset]')).forEach((btn) => {
    btn.addEventListener('click', () => {
      const v = parseFloat(btn.getAttribute('data-countdown-preset'));
      if (Number.isFinite(v) && countDownGoalInput) {
        countDownGoalInput.value = String(v);
      }
      syncCountDownSettingsFromUI({ commit:true });

      // Apply to the active band's config immediately.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.countDown.enabled = !!countDownEnabled;
          b.countDown.goalSec = countDownGoalSec;
          b.countDown.voice = !!countDownVoiceEnabled;

          // Let voice refresh immediately with the new goal.
          if (b._countDownState) {
            b._countDownState.voiceLastSpoken = null;
            b._countDownState.voiceSpokeDone = false;
          }
        }
      } catch (_) {}

      saveSettings();
    });
  });


if (settingsToggle) {
    settingsToggle.classList.toggle('hidden', overlayOpen);
    settingsToggle.setAttribute('aria-expanded', overlayOpen ? 'true' : 'false');
  }

  // Update the scene reservation immediately on open/close.
  requestAnimationFrame(updateSceneLayoutForSheet);
}


  // --- Sheet navigation (quick jump tabs) -----------------------------------
  function setNavActive(targetId) {
    if (!navTabs || !navTabs.length) return;
    navTabs.forEach(btn => {
      const isActive = (btn.dataset && btn.dataset.target === targetId);
      btn.classList.toggle('active', !!isActive);
    });
  }

  function scrollOverlayToSection(targetId) {
    if (!targetId) return;
    const el = document.getElementById(targetId);
    if (!el) return;
    // Ensure the section is expanded if it's a <details>.
    if (el.tagName && el.tagName.toLowerCase() === 'details') {
      el.open = true;
    }
    el.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
    setNavActive(targetId);
  }

  if (overlayNav && navTabs && navTabs.length) {
    navTabs.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset ? btn.dataset.target : null;
        if (!target) return;
        scrollOverlayToSection(target);
      });
    });

    // Keep the active tab roughly synced with scroll (lightweight).
    if (overlayBody) {
      let raf = 0;
      overlayBody.addEventListener('scroll', () => {
        if (raf) return;
        raf = requestAnimationFrame(() => {
          raf = 0;
          const ids = ['sectionBands', 'sectionBand', 'sectionGraphics', 'sectionInfo'];
          let bestId = ids[0];
          let bestDist = Infinity;
          const bodyRect = overlayBody.getBoundingClientRect();
          for (const id of ids) {
            const sec = document.getElementById(id);
            if (!sec) continue;
            const r = sec.getBoundingClientRect();
            const dist = Math.abs((r.top - bodyRect.top) - 8);
            if (dist < bestDist) {
              bestDist = dist;
              bestId = id;
            }
          }
          setNavActive(bestId);
        });
      }, { passive: true });
    }
  }

  if (activeBandPill) {
    activeBandPill.addEventListener('click', () => scrollOverlayToSection('sectionBands'));
  }


  // --- Bands (multiple independent regions) ---------------------------------
  const SETTINGS_KEY_V2 = 'tiltSphereSettings_v2';
  const SETTINGS_KEY_V1 = 'tiltSphereSettings_v1';
  const SETTINGS_KEY    = SETTINGS_KEY_V2;

  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

  function cssColorFromSrgb01(rgb, a = 0.95) {
    // rgb is expected to be an sRGB triplet in 0..1, but older saves or
    // partially-initialized band objects can be missing it.
    const r = Math.round(clamp01((rgb?.[0]) ?? 0) * 255);
    const g = Math.round(clamp01((rgb?.[1]) ?? 0) * 255);
    const b = Math.round(clamp01((rgb?.[2]) ?? 0) * 255);
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }


  function srgb01ToHex(rgb) {
    const r = Math.round(clamp01((rgb?.[0]) ?? 0) * 255);
    const g = Math.round(clamp01((rgb?.[1]) ?? 0) * 255);
    const b = Math.round(clamp01((rgb?.[2]) ?? 0) * 255);
    const toHex = (v) => v.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  function hexToSrgb01(hex) {
    if (typeof hex !== 'string') return null;
    let h = hex.trim();
    if (!h) return null;
    if (h[0] === '#') h = h.slice(1);
    if (h.length === 3) {
      h = h.split('').map(ch => ch + ch).join('');
    }
    if (h.length !== 6) return null;
    const n = parseInt(h, 16);
    if (!Number.isFinite(n)) return null;
    const r = (n >> 16) & 255;
    const g = (n >> 8) & 255;
    const b = n & 255;
    return [r / 255, g / 255, b / 255];
  }

  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function makeDefaultBand(index = 0) {
    const color = (BAND_COLOR_PALETTE[index % BAND_COLOR_PALETTE.length] || BAND_COLOR_PALETTE[0]).slice();

    const band = {
      enabled: true,
      name: '',
      color,
      monitor: 'pitch',
      handlesByMode: deepClone(DEFAULT_HANDLES_BY_MODE),

      centerPitch: 0,
      centerRoll: 0,
      rotationDeg: 0,

      rectScalePitch: 1,
      rectScaleRoll: 1,
      ellipseScaleX: 1,
      ellipseScaleY: 1,

      polySides: 3,
      polyVerts: new Float32Array(MAX_POLY_SIDES_JS * 2),
      polyPlanes: new Float32Array(MAX_POLY_SIDES_JS * 3),
      polyVertsInner: new Float32Array(MAX_POLY_SIDES_JS * 2),
      polyPlanesInner: new Float32Array(MAX_POLY_SIDES_JS * 3),

      centerDir: [0, 0, 1],
      frameX: [1, 0, 0],
      frameY: [0, 1, 0],

      // Timers (paired with this band)
      beepCount: { enabled: false, intervalSec: 1.0 },
      countDown: { enabled: false, goalSec: 10.0, voice: true },
    };

    // Initialize polygon vertices/planes (outer + inner).
    resetPolyVerts(band.polySides, band.polyVerts, band.polyPlanes);
    resetPolyVerts(band.polySides, band.polyVertsInner, band.polyPlanesInner);

    return band;
  }

  function cloneBand(srcBand, index = 0) {
    const band = makeDefaultBand(index);
    if (!srcBand) return band;

    band.enabled = (srcBand.enabled !== false);
    band.name = (typeof srcBand.name === 'string') ? srcBand.name : '';
    band.color = (Array.isArray(srcBand.color) && srcBand.color.length === 3) ? srcBand.color.slice() : band.color;

    band.monitor = typeof srcBand.monitor === 'string' ? srcBand.monitor : band.monitor;
    band.handlesByMode = srcBand.handlesByMode ? deepClone(srcBand.handlesByMode) : deepClone(DEFAULT_HANDLES_BY_MODE);

    band.centerPitch = +srcBand.centerPitch || 0;
    band.centerRoll = +srcBand.centerRoll || 0;
    band.rotationDeg = +srcBand.rotationDeg || 0;

    band.rectScalePitch = +srcBand.rectScalePitch || 1;
    band.rectScaleRoll = +srcBand.rectScaleRoll || 1;
    band.ellipseScaleX = +srcBand.ellipseScaleX || 1;
    band.ellipseScaleY = +srcBand.ellipseScaleY || 1;

    band.polySides = Math.max(3, Math.min(MAX_POLY_SIDES_JS, (srcBand.polySides | 0) || 3));
    band.polyVerts = new Float32Array(srcBand.polyVerts || band.polyVerts);
    band.polyVertsInner = new Float32Array(srcBand.polyVertsInner || srcBand.polyVerts || band.polyVertsInner);

    // Normalize polygon scaling + rebuild planes (keeps polygon slider degree-true).
    normalizePolygonBandScaling(band);

    band.centerDir = Array.isArray(srcBand.centerDir) && srcBand.centerDir.length === 3 ? srcBand.centerDir.slice() : band.centerDir;
    band.frameX = Array.isArray(srcBand.frameX) && srcBand.frameX.length === 3 ? srcBand.frameX.slice() : band.frameX;
    band.frameY = Array.isArray(srcBand.frameY) && srcBand.frameY.length === 3 ? srcBand.frameY.slice() : band.frameY;

    // Normalize handles.
    for (const k of Object.keys(DEFAULT_HANDLES_BY_MODE)) {
      const h = (band.handlesByMode && Array.isArray(band.handlesByMode[k])) ? band.handlesByMode[k] : deepClone(DEFAULT_HANDLES_BY_MODE[k]);
      band.handlesByMode[k] = normalizeHandlesForMode(k, h);
      if (k === 'pitchOrRoll' || k === 'pitchAndRoll') {
        for (let i = 0; i < band.handlesByMode[k].length; i += 2) band.handlesByMode[k][i] = 0;
      }
    }

    // Timers (settings only; runtime state starts fresh on duplicate)
    if (srcBand.beepCount && typeof srcBand.beepCount === 'object') {
      band.beepCount = {
        enabled: !!srcBand.beepCount.enabled,
        intervalSec: (typeof srcBand.beepCount.intervalSec === 'number' && Number.isFinite(srcBand.beepCount.intervalSec))
          ? srcBand.beepCount.intervalSec
          : band.beepCount.intervalSec
      };
    }
    if (srcBand.countDown && typeof srcBand.countDown === 'object') {
      band.countDown = {
        enabled: !!srcBand.countDown.enabled,
        goalSec: (typeof srcBand.countDown.goalSec === 'number' && Number.isFinite(srcBand.countDown.goalSec))
          ? srcBand.countDown.goalSec
          : band.countDown.goalSec,
        voice: (typeof srcBand.countDown.voice === 'boolean') ? srcBand.countDown.voice : band.countDown.voice
      };
    }

    return band;
  }

  function serializeBand(band) {
    return {
      enabled: !!band.enabled,
      name: band.name,
      color: band.color,
      monitor: band.monitor,
      handlesByMode: band.handlesByMode,
      centerPitch: band.centerPitch,
      centerRoll: band.centerRoll,
      rotationDeg: band.rotationDeg,
      polySides: band.polySides,
      rectScalePitch: band.rectScalePitch,
      rectScaleRoll: band.rectScaleRoll,
      ellipseScaleX: band.ellipseScaleX,
      ellipseScaleY: band.ellipseScaleY,
      polyVerts: Array.from(band.polyVerts || []),
      polyVertsInner: Array.from(band.polyVertsInner || []),
      centerDir: band.centerDir,
      frameX: band.frameX,
      frameY: band.frameY,

      // Timers (per-band)
      beepCount: band.beepCount || { enabled: false, intervalSec: 1.0 },
      countDown: band.countDown || { enabled: false, goalSec: 10.0, voice: true },
    };
  }

  function deserializeBand(obj, index = 0) {
    const band = makeDefaultBand(index);
    if (!obj || typeof obj !== 'object') return band;

    band.enabled = (obj.enabled !== false);
    if (typeof obj.name === 'string') band.name = obj.name;
    if (Array.isArray(obj.color) && obj.color.length === 3) band.color = obj.color.slice();

    if (typeof obj.monitor === 'string') band.monitor = obj.monitor;

    if (obj.handlesByMode && typeof obj.handlesByMode === 'object') {
      band.handlesByMode = deepClone(DEFAULT_HANDLES_BY_MODE);
      for (const k of Object.keys(DEFAULT_HANDLES_BY_MODE)) {
        const h = Array.isArray(obj.handlesByMode[k]) ? obj.handlesByMode[k] : DEFAULT_HANDLES_BY_MODE[k];
        band.handlesByMode[k] = normalizeHandlesForMode(k, h);
        if (k === 'pitchOrRoll' || k === 'pitchAndRoll') {
          for (let i = 0; i < band.handlesByMode[k].length; i += 2) band.handlesByMode[k][i] = 0;
        }
      }
    }

    if (Number.isFinite(+obj.centerPitch)) band.centerPitch = +obj.centerPitch;
    if (Number.isFinite(+obj.centerRoll)) band.centerRoll = +obj.centerRoll;

    const rot = (obj.rotationDeg != null) ? +obj.rotationDeg : (obj.bandRotationDeg != null ? +obj.bandRotationDeg : 0);
    band.rotationDeg = Number.isFinite(rot) ? rot : 0;

    if (Number.isFinite(+obj.rectScalePitch)) band.rectScalePitch = +obj.rectScalePitch;
    if (Number.isFinite(+obj.rectScaleRoll)) band.rectScaleRoll = +obj.rectScaleRoll;
    if (Number.isFinite(+obj.ellipseScaleX)) band.ellipseScaleX = +obj.ellipseScaleX;
    if (Number.isFinite(+obj.ellipseScaleY)) band.ellipseScaleY = +obj.ellipseScaleY;

    const sides = (obj.polySides | 0) || 3;
    band.polySides = Math.max(3, Math.min(MAX_POLY_SIDES_JS, sides));

    // Verts (outer)
    if (Array.isArray(obj.polyVerts) && obj.polyVerts.length >= 6) {
      band.polyVerts.set(obj.polyVerts.slice(0, band.polyVerts.length));
    } else if (Array.isArray(obj.polyApothemsOuter) && obj.polyApothemsOuter.length >= 3) {
      const apO = obj.polyApothemsOuter;
      for (let i = 0; i < MAX_POLY_SIDES_JS; i++) {
        const idx = i * 2;
        const apo = (i < band.polySides && Number.isFinite(+apO[i])) ? +apO[i] : 0;
        const theta = (2 * Math.PI * i) / band.polySides;
        band.polyVerts[idx + 0] = Math.cos(theta) * apo;
        band.polyVerts[idx + 1] = Math.sin(theta) * apo;
      }
    } else if (Array.isArray(obj.polyApothems) && obj.polyApothems.length >= 3) {
      const apO = obj.polyApothems;
      for (let i = 0; i < MAX_POLY_SIDES_JS; i++) {
        const idx = i * 2;
        const apo = (i < band.polySides && Number.isFinite(+apO[i])) ? +apO[i] : 0;
        const theta = (2 * Math.PI * i) / band.polySides;
        band.polyVerts[idx + 0] = Math.cos(theta) * apo;
        band.polyVerts[idx + 1] = Math.sin(theta) * apo;
      }
    } else {
      resetPolyVerts(band.polySides, band.polyVerts, band.polyPlanes);
    }

    // Verts (inner)
    if (Array.isArray(obj.polyVertsInner) && obj.polyVertsInner.length >= 6) {
      band.polyVertsInner.set(obj.polyVertsInner.slice(0, band.polyVertsInner.length));
    } else if (Array.isArray(obj.polyApothemsInner) && obj.polyApothemsInner.length >= 3) {
      const apI = obj.polyApothemsInner;
      for (let i = 0; i < MAX_POLY_SIDES_JS; i++) {
        const idx = i * 2;
        const apo = (i < band.polySides && Number.isFinite(+apI[i])) ? +apI[i] : 0;
        const theta = (2 * Math.PI * i) / band.polySides;
        band.polyVertsInner[idx + 0] = Math.cos(theta) * apo;
        band.polyVertsInner[idx + 1] = Math.sin(theta) * apo;
      }
    } else if (Array.isArray(obj.polyVerts) && obj.polyVerts.length >= 6) {
      band.polyVertsInner.set(obj.polyVerts.slice(0, band.polyVertsInner.length));
    } else {
      resetPolyVerts(band.polySides, band.polyVertsInner, band.polyPlanesInner);
    }

    // Planes (normalized so polygon slider stays degree-true)
    normalizePolygonBandScaling(band);

    // Orientation frame (optional; helps preserve polygon orientation).
    if (Array.isArray(obj.centerDir) && obj.centerDir.length === 3) band.centerDir = obj.centerDir.slice();
    if (Array.isArray(obj.frameX) && obj.frameX.length === 3) band.frameX = obj.frameX.slice();
    if (Array.isArray(obj.frameY) && obj.frameY.length === 3) band.frameY = obj.frameY.slice();

    // Timers (paired with this band)
    band._timersFromStorage = band._timersFromStorage || {};

    if (obj.beepCount && typeof obj.beepCount === 'object') {
      band.beepCount = {
        enabled: !!obj.beepCount.enabled,
        intervalSec: (typeof obj.beepCount.intervalSec === 'number' && Number.isFinite(obj.beepCount.intervalSec))
          ? obj.beepCount.intervalSec
          : band.beepCount.intervalSec
      };
      band._timersFromStorage.beepCount = true;
    } else {
      band._timersFromStorage.beepCount = false;
    }

    if (obj.countDown && typeof obj.countDown === 'object') {
      band.countDown = {
        enabled: !!obj.countDown.enabled,
        goalSec: (typeof obj.countDown.goalSec === 'number' && Number.isFinite(obj.countDown.goalSec))
          ? obj.countDown.goalSec
          : band.countDown.goalSec,
        voice: (typeof obj.countDown.voice === 'boolean') ? obj.countDown.voice : band.countDown.voice
      };
      band._timersFromStorage.countDown = true;
    } else {
      band._timersFromStorage.countDown = false;
    }

    // Ensure runtime timer state holders exist
    ensureBandTimerConfig(band);

    return band;
  }

  function commitActiveBandFromUI() {
    const band = bands[activeBandIndex];
    if (!band) return;

    band.enabled = !!(bandEnabledCheckbox && bandEnabledCheckbox.checked);

    if (bandNameInput) band.name = (bandNameInput.value || '').slice(0, 24);
    if (bandColorInput) {
      const c = hexToSrgb01(bandColorInput.value);
      if (c) band.color = c;
    }

    band.monitor = monitorSelect.value;
    band.handlesByMode = handlesByMode;

    band.centerPitch = parseFloat(centerPitchInput.value) || 0;
    band.centerRoll = parseFloat(centerRollInput.value) || 0;
    band.rotationDeg = parseFloat(bandRotationInput.value) || 0;
    band.polySides = parseInt(polySidesInput.value) || 3;

    band.rectScalePitch = rectScalePitch;
    band.rectScaleRoll = rectScaleRoll;
    band.ellipseScaleX = ellipseScaleX;
    band.ellipseScaleY = ellipseScaleY;

    band.polyVerts = polyVerts;
    band.polyPlanes = polyPlanes;
    band.polyVertsInner = polyVertsInner;
    band.polyPlanesInner = polyPlanesInner;

    band.centerDir = bandCenterDir.slice();
    band.frameX = bandFrameX.slice();
    band.frameY = bandFrameY.slice();

    // Per-band timers (BeepCount / CountDown)
    try {
      syncBeepTimerSettingsFromUI({ commit:false });
      syncCountDownSettingsFromUI({ commit:false });
      saveTimersToBand(band);
    } catch (_) {}
  }

  function applyBandToUI(band) {
    if (!band) return;

    // Active selection data
    handlesByMode = band.handlesByMode || deepClone(DEFAULT_HANDLES_BY_MODE);

    // Inputs
    monitorSelect.value = band.monitor || 'pitch';
    centerPitchInput.value = (band.centerPitch ?? 0);
    centerRollInput.value  = (band.centerRoll ?? 0);
    polySidesInput.value   = (band.polySides ?? 3);
    bandRotationInput.value = (band.rotationDeg ?? 0);

    // Geometry
    rectScalePitch = band.rectScalePitch ?? 1;
    rectScaleRoll  = band.rectScaleRoll  ?? 1;
    ellipseScaleX  = band.ellipseScaleX  ?? 1;
    ellipseScaleY  = band.ellipseScaleY  ?? 1;

    polyVerts = band.polyVerts || polyVerts;
    polyPlanes = band.polyPlanes || polyPlanes;
    polyVertsInner = band.polyVertsInner || polyVertsInner;
    polyPlanesInner = band.polyPlanesInner || polyPlanesInner;

    // Orientation frame
    if (Array.isArray(band.centerDir) && band.centerDir.length === 3) {
      bandCenterDir = band.centerDir.slice();
      bandFrameX = (Array.isArray(band.frameX) && band.frameX.length === 3) ? band.frameX.slice() : bandFrameX;
      bandFrameY = (Array.isArray(band.frameY) && band.frameY.length === 3) ? band.frameY.slice() : bandFrameY;
    } else {
      bandCenterDir = tiltToDir(parseFloat(centerPitchInput.value), parseFloat(centerRollInput.value));
      updateBandFrameFromDir(bandCenterDir);
    }

    if (bandEnabledCheckbox) bandEnabledCheckbox.checked = (band.enabled !== false);
    if (bandNameInput) bandNameInput.value = (typeof band.name === 'string') ? band.name : '';
    if (bandColorInput) bandColorInput.value = srgb01ToHex(band.color || BAND_COLOR_PALETTE[0]);

    // UI refresh
    setActiveModeChip(monitorSelect.value);
    updateBandSizeUIFromState();
    updateBandRotationUIFromState();
    updateBandRotationSliderBackground();
    renderMultiSlider();
    updateBandHandles();

    // Load this band's BeepCount / CountDown settings into the timer UI/state
    try { loadTimersFromBand(band); } catch (_) {}
  }

  function ensureBandsInitialized() {
    if (!Array.isArray(bands) || bands.length === 0) {
      bands = [makeDefaultBand(0)];
      activeBandIndex = 0;
    }
    activeBandIndex = Math.max(0, Math.min(activeBandIndex | 0, bands.length - 1));
  }


  function updateActiveBandPill(inRangeSet = null) {
    if (!activeBandPill || !activeBandPillLabel) return;
    const band = bands[activeBandIndex];
    if (!band) {
      activeBandPillLabel.textContent = '';
      return;
    }

    const hasName = (typeof band.name === 'string') && band.name.trim().length;
    const name = hasName ? band.name.trim() : '';
    const labelText = hasName ? (`B${activeBandIndex + 1} · ` + name) : (`Band ${activeBandIndex + 1}`);

    activeBandPillLabel.textContent = labelText;
    activeBandPill.title = hasName ? (`Active band: ` + name) : (`Active band: B${activeBandIndex + 1}`);

    activeBandPill.style.setProperty('--bandColor', cssColorFromSrgb01(band.color));
    activeBandPill.classList.toggle('disabled', band.enabled === false);
    activeBandPill.classList.toggle('in-range', !!(inRangeSet && inRangeSet.has(activeBandIndex)));
  }

  function modeLabelShort(modeStr) {
    switch (modeStr) {
      case 'pitch':        return 'Pitch';
      case 'roll':         return 'Roll';
      case 'pitchOrRoll':  return 'OR';
      case 'pitchAndRoll': return 'AND';
      case 'circle':       return 'Circle';
      case 'polygon':      return 'Polygon';
      default:             return 'Pitch';
    }
  }

  // Cache band UI DOM so we don't rebuild it every UI tick (only when the band set changes).
  let lastBandsUiSignature = '';
  let bandChipButtons = [];
  let bandListItems  = []; // { row, statusEl }

  function computeBandsUiSignature() {
    // Include activeBandIndex so the "active row actions" move correctly without extra code.
    let sig = `${bands.length}|${activeBandIndex}|`;
    for (let i = 0; i < bands.length; i++) {
      const b = bands[i] || {};
      const en = (b.enabled === false) ? '0' : '1';
      const mon = b.monitor || '';
      const name = (typeof b.name === 'string') ? b.name : '';
      const col = Array.isArray(b.color) ? b.color.map(v => Math.round((+v || 0) * 255)).join('.') : '';
      sig += `${en},${mon},${name},${col};`;
    }
    return sig;
  }

  function renderBandChips(inRangeSet = null) {
    const sig = computeBandsUiSignature();

    const needRebuild =
      sig !== lastBandsUiSignature ||
      (bandChipsContainer && bandChipsContainer.children.length !== bands.length) ||
      (bandListContainer  && bandListContainer.children.length !== bands.length);

    if (needRebuild) {
      lastBandsUiSignature = sig;
      bandChipButtons = [];
      bandListItems = [];

      // --- Rebuild chips (compact quick switch) -----------------------------
      if (bandChipsContainer) {
        bandChipsContainer.innerHTML = '';
        bands.forEach((band, i) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'mode-chip band-chip';

          const dot = document.createElement('span');
          dot.className = 'band-chip-dot';
          dot.style.setProperty('--bandColor', cssColorFromSrgb01(band.color));
          btn.appendChild(dot);

          const hasName = (typeof band.name === 'string') && band.name.trim().length;
          const labelText = hasName ? band.name.trim() : String(i + 1);
          const label = document.createElement('span');
          label.className = 'band-chip-label';
          label.textContent = labelText;
          btn.title = hasName ? (`Band ${i + 1}: ` + band.name.trim()) : (`Band ${i + 1}`);
          btn.appendChild(label);

          btn.addEventListener('click', () => selectBand(i));
          bandChipsContainer.appendChild(btn);
          bandChipButtons.push(btn);
        });
      }

      // --- Rebuild list (primary band manager) ------------------------------
      if (bandListContainer) {
        bandListContainer.innerHTML = '';

        bands.forEach((band, i) => {
          const row = document.createElement('div');
          row.className = 'band-row';
          row.tabIndex = 0;
          row.setAttribute('role', 'button');
          row.setAttribute('aria-label', `Select band ${i + 1}`);
          row.addEventListener('click', () => selectBand(i));
          row.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              selectBand(i);
            }
          });

          const dot = document.createElement('span');
          dot.className = 'band-row-dot';
          dot.style.setProperty('--bandColor', cssColorFromSrgb01(band.color));
          row.appendChild(dot);

          const textWrap = document.createElement('div');
          textWrap.className = 'band-row-text';

          const hasName = (typeof band.name === 'string') && band.name.trim().length;
          const name = hasName ? band.name.trim() : '';
          const title = document.createElement('div');
          title.className = 'band-row-title';
          title.textContent = hasName ? (`B${i + 1} · ${name}`) : (`Band ${i + 1}`);
          textWrap.appendChild(title);

          const sub = document.createElement('div');
          sub.className = 'band-row-sub';
          const modeStr = band.monitor || 'pitch';
          const ranges = getRangesForBand(band, modeStr);
          const rc = ranges.length;
          sub.textContent = `${modeLabelShort(modeStr)} · ${rc} range${rc === 1 ? '' : 's'}`;
          textWrap.appendChild(sub);

          row.appendChild(textWrap);

          const right = document.createElement('div');
          right.className = 'band-row-right';

          const status = document.createElement('span');
          status.className = 'band-row-status';
          status.textContent = (band.enabled === false) ? 'OFF' : 'OUT';
          right.appendChild(status);

          const actions = document.createElement('div');
          actions.className = 'band-row-actions';

          // Active band gets quick actions inline (keeps the list clean).
          if (i === activeBandIndex) {
            const upBtn = document.createElement('button');
            upBtn.type = 'button';
            upBtn.className = 'band-row-action';
            upBtn.textContent = '↑';
            upBtn.title = 'Move band up';
            upBtn.disabled = (bands.length <= 1 || activeBandIndex <= 0);
            upBtn.addEventListener('click', (e) => { e.stopPropagation(); moveActiveBand(-1); });
            actions.appendChild(upBtn);

            const downBtn = document.createElement('button');
            downBtn.type = 'button';
            downBtn.className = 'band-row-action';
            downBtn.textContent = '↓';
            downBtn.title = 'Move band down';
            downBtn.disabled = (bands.length <= 1 || activeBandIndex >= bands.length - 1);
            downBtn.addEventListener('click', (e) => { e.stopPropagation(); moveActiveBand(1); });
            actions.appendChild(downBtn);

            const dupBtn = document.createElement('button');
            dupBtn.type = 'button';
            dupBtn.className = 'band-row-action';
            dupBtn.textContent = '⎘';
            dupBtn.title = 'Duplicate band';
            dupBtn.addEventListener('click', (e) => { e.stopPropagation(); duplicateActiveBand(); });
            actions.appendChild(dupBtn);

            const delBtn = document.createElement('button');
            delBtn.type = 'button';
            delBtn.className = 'band-row-action danger';
            delBtn.textContent = '🗑';
            delBtn.title = 'Remove band';
            delBtn.disabled = (bands.length <= 1);
            delBtn.addEventListener('click', (e) => { e.stopPropagation(); removeActiveBand(); });
            actions.appendChild(delBtn);
          }

          const enableWrap = document.createElement('label');
          enableWrap.className = 'mini-switch';
          enableWrap.title = 'Enable/disable band';

          const enable = document.createElement('input');
          enable.type = 'checkbox';
          enable.checked = (band.enabled !== false);
          enable.addEventListener('click', (e) => e.stopPropagation());
          enable.addEventListener('change', () => {
            band.enabled = !!enable.checked;
            if (i === activeBandIndex && bandEnabledCheckbox) bandEnabledCheckbox.checked = !!enable.checked;
            renderBandChips(inRangeSet);
            saveSettings();
            updateUI();
          });
          enableWrap.appendChild(enable);
          actions.appendChild(enableWrap);

          right.appendChild(actions);
          row.appendChild(right);

          bandListContainer.appendChild(row);
          bandListItems.push({ row, statusEl: status });
        });
      }
    }

    // --- Lightweight updates (active / enabled / in-range) ------------------
    for (let i = 0; i < bands.length; i++) {
      const band = bands[i] || {};
      const inRange = !!(inRangeSet && inRangeSet.has(i));
      const enabled = (band.enabled !== false);

      const chipBtn = bandChipButtons[i];
      if (chipBtn) {
        chipBtn.classList.toggle('active', i === activeBandIndex);
        chipBtn.classList.toggle('disabled', !enabled);
        chipBtn.classList.toggle('in-range', inRange);
      }

      const item = bandListItems[i];
      if (item && item.row) {
        item.row.classList.toggle('active', i === activeBandIndex);
        item.row.classList.toggle('disabled', !enabled);

        if (item.statusEl) {
          if (!enabled) {
            item.statusEl.textContent = 'OFF';
            item.statusEl.classList.remove('in', 'out');
            item.statusEl.classList.add('off');
          } else if (inRange) {
            item.statusEl.textContent = 'IN';
            item.statusEl.classList.remove('out', 'off');
            item.statusEl.classList.add('in');
          } else {
            item.statusEl.textContent = 'OUT';
            item.statusEl.classList.remove('in', 'off');
            item.statusEl.classList.add('out');
          }
        }
      }
    }

    // Disable destructive / move controls when not applicable (legacy toolbar).
    if (removeBandBtn) removeBandBtn.disabled = (bands.length <= 1);
    if (moveBandUpBtn) moveBandUpBtn.disabled = (bands.length <= 1 || activeBandIndex <= 0);
    if (moveBandDownBtn) moveBandDownBtn.disabled = (bands.length <= 1 || activeBandIndex >= bands.length - 1);

    if (bandsSummaryEl) {
      const n = bands.length;
      bandsSummaryEl.textContent = `${n} band${n === 1 ? '' : 's'}`;
    }

    updateActiveBandPill(inRangeSet);
  }

  function selectBand(index) {
    if (!Number.isFinite(index)) return;
    const idx = Math.max(0, Math.min(index | 0, bands.length - 1));
    if (idx === activeBandIndex) return;

    commitActiveBandFromUI();
    activeBandIndex = idx;
    applyBandToUI(bands[activeBandIndex]);
    renderBandChips();
    saveSettings();
  }

  function addNewBand() {
    commitActiveBandFromUI();
    const band = makeDefaultBand(bands.length);
    bands.push(band);
    activeBandIndex = bands.length - 1;
    applyBandToUI(band);
    renderBandChips();
    saveSettings();
  }

  function duplicateActiveBand() {
    commitActiveBandFromUI();
    const src = bands[activeBandIndex];
    const band = cloneBand(src, bands.length);
    if (band.name) band.name = (band.name + ' copy').slice(0, 24);
    // Give duplicates a fresh palette color so overlaps are visually distinct.
    band.color = (BAND_COLOR_PALETTE[bands.length % BAND_COLOR_PALETTE.length] || band.color).slice();
    bands.push(band);
    activeBandIndex = bands.length - 1;
    applyBandToUI(band);
    renderBandChips();
    saveSettings();
  }

  function removeActiveBand() {
    if (bands.length <= 1) return;
    commitActiveBandFromUI();
    bands.splice(activeBandIndex, 1);
    activeBandIndex = Math.max(0, Math.min(activeBandIndex, bands.length - 1));
    applyBandToUI(bands[activeBandIndex]);
    renderBandChips();
    saveSettings();
  }


  function moveActiveBand(delta) {
    if (!Number.isFinite(delta)) return;
    if (!Array.isArray(bands) || bands.length <= 1) return;

    const from = activeBandIndex | 0;
    const step = (delta < 0) ? -1 : 1;
    const to = Math.max(0, Math.min(from + step, bands.length - 1));
    if (to === from) return;

    commitActiveBandFromUI();

    const tmp = bands[from];
    bands[from] = bands[to];
    bands[to] = tmp;
    activeBandIndex = to;

    applyBandToUI(bands[activeBandIndex]);
    renderBandChips();
    saveSettings();
    updateUI();
  }

  function getRangesForBand(band, modeStr) {
    const ms = modeStr || band.monitor || 'pitch';
    const raw = (band.handlesByMode && Array.isArray(band.handlesByMode[ms])) ? band.handlesByMode[ms] : DEFAULT_HANDLES_BY_MODE[ms];
    const handles = normalizeHandlesForMode(ms, raw);
    const ranges = [];
    for (let i = 0; i + 1 < handles.length; i += 2) {
      let a = handles[i];
      let b = handles[i + 1];
      if (ms === 'pitchOrRoll' || ms === 'pitchAndRoll') a = 0; // locked
      ranges.push({ min: a, max: b });
    }
    return ranges.length ? ranges : [{ min: 0, max: 1 }];
  }

  function getBandSettingsForBand(band) {
    const modeStr = band.monitor || 'pitch';
    const modeIndex = ({ pitch: 0, roll: 1, pitchOrRoll: 2, pitchAndRoll: 3, circle: 4, polygon: 5 })[modeStr] ?? 0;
    const ranges = getRangesForBand(band, modeStr);
    const first = ranges[0] || { min: 0, max: 1 };

    return {
      modeStr,
      modeIndex,
      ranges,
      minAngle: first.min,
      maxAngle: first.max,
      centerPitch: band.centerPitch ?? 0,
      centerRoll: band.centerRoll ?? 0,
      rotationDeg: band.rotationDeg ?? 0,
      polySides: band.polySides ?? 3,
      enabled: (band.enabled !== false),
      color: band.color || BAND_COLOR_PALETTE[0],
      rectScalePitch: band.rectScalePitch ?? 1,
      rectScaleRoll: band.rectScaleRoll ?? 1,
      ellipseScaleX: band.ellipseScaleX ?? 1,
      ellipseScaleY: band.ellipseScaleY ?? 1,
      centerDir: band.centerDir || [0,0,1],
      frameX: band.frameX || [1,0,0],
      frameY: band.frameY || [0,1,0],
      polyVerts: band.polyVerts,
      polyVertsInner: band.polyVertsInner,
      polyPlanes: band.polyPlanes,
      polyPlanesInner: band.polyPlanesInner,
    };
  }

  function getBandSettings() {
    const rawMonitorType = monitorSelect.value;
    const allowedMonitors = [
      'pitch','roll','pitchOrRoll','pitchAndRoll','circle','polygon'
    ];
    const modeStr = allowedMonitors.includes(rawMonitorType) ? rawMonitorType : 'pitch';

    // Ranges come from the multi-handle slider state.
    const ranges = getRanges(modeStr);

    // Legacy min/max still exist (first stripe) for compatibility.
    let minVal = 0;
    let maxVal = 0;
    if (ranges.length) {
      minVal = ranges[0].min;
      maxVal = ranges[0].max;
    }

    let centerPitch = parseFloat(centerPitchInput.value);
    if (Number.isNaN(centerPitch)) centerPitch = 0;
    let centerRoll  = parseFloat(centerRollInput.value);
    if (Number.isNaN(centerRoll)) centerRoll = 0;

    let polySides = parseFloat(polySidesInput.value);
    if (!Number.isFinite(polySides)) polySides = 3;
    polySides = Math.max(3, Math.min(24, Math.round(polySides)));

    // Rotation is represented on a 0..360° axis (no negatives).
    // Keep 360 as a valid value (equivalent to 0) so the slider doesn't snap.
    let rotationDeg = parseFloat(bandRotationInput.value);
    if (Number.isNaN(rotationDeg)) rotationDeg = 0;
    let rotNorm = wrap360(rotationDeg);
    if (Math.abs(rotNorm) < 1e-9 && Math.abs(rotationDeg) > 1e-9) rotNorm = 360;
    rotationDeg = rotNorm;

    let modeIndex;
    switch (modeStr) {
      case 'pitch':        modeIndex = 0; break;
      case 'roll':         modeIndex = 1; break;
      case 'pitchOrRoll':  modeIndex = 2; break;
      case 'pitchAndRoll': modeIndex = 3; break;
      case 'circle':       modeIndex = 4; break;
      case 'polygon':      modeIndex = 5; break;
      default:             modeIndex = 0; break;
    }

    return {
      min: minVal,
      max: maxVal,
      ranges,
      modeIndex,
      modeStr,
      polySides,
      centerPitch,
      centerRoll,
      rotationDeg
    };
  }

  function loadSettings() {
    // Defaults
    ensureBandsInitialized();

    let wantOverlayOpen = false;

    // Try v2 first
    try {
      const rawV2 = localStorage.getItem(SETTINGS_KEY_V2);
      if (rawV2) {
        const data = JSON.parse(rawV2);
        if (data && typeof data === 'object' && Array.isArray(data.bands) && data.bands.length) {
          bands = data.bands.map((b, i) => deserializeBand(b, i));
          activeBandIndex = Number.isFinite(data.activeBandIndex) ? Math.max(0, Math.min((data.activeBandIndex | 0), bands.length - 1)) : 0;

          if (typeof data.camCrossYawDeg === 'number') camCrossYawDeg = data.camCrossYawDeg;
          if (typeof data.camAttachYawOffsetDeg === 'number') camAttachYawOffsetDeg = data.camAttachYawOffsetDeg;

          if (typeof data.sound === 'boolean') soundCheckbox.checked = data.sound;
          wantOverlayOpen = !!data.overlayOpen;
          // BeepCount / CountDown are stored per-band. Migrate legacy global
          // values (if present) into bands that don't already have per-band settings.
          const bcGlobal = (data.beepCount && typeof data.beepCount === 'object')
                        ? data.beepCount
                        : (data.timer && typeof data.timer === 'object') ? data.timer : null;

          if (bcGlobal) {
            const enabled = !!bcGlobal.enabled;
            const intervalSec = (typeof bcGlobal.intervalSec === 'number' && Number.isFinite(bcGlobal.intervalSec))
              ? bcGlobal.intervalSec
              : 1.0;

            for (const b of bands) {
              if (!b) continue;
              if (!b._timersFromStorage || b._timersFromStorage.beepCount !== true) {
                b.beepCount = { enabled, intervalSec };
              }
              ensureBandTimerConfig(b);
            }
          } else {
            for (const b of bands) ensureBandTimerConfig(b);
          }

          if (data.countDown && typeof data.countDown === 'object') {
            const enabled = !!data.countDown.enabled;
            const goalSec = (typeof data.countDown.goalSec === 'number' && Number.isFinite(data.countDown.goalSec))
              ? data.countDown.goalSec
              : 10.0;
            const voice = (typeof data.countDown.voice === 'boolean') ? data.countDown.voice : true;

            const ab = bands[activeBandIndex];
            if (ab && (!ab._timersFromStorage || ab._timersFromStorage.countDown !== true)) {
              ab.countDown = { enabled, goalSec, voice };
              ensureBandTimerConfig(ab);
            }
          }

          // Graphics (optional)
          if (data.gfx && typeof data.gfx === 'object') {
            if (typeof data.gfx.quality === 'string') gfxQuality = data.gfx.quality;
            if (typeof data.gfx.renderScale === 'number' && Number.isFinite(data.gfx.renderScale)) {
              gfxRenderScale = Math.max(0.5, Math.min(1.0, data.gfx.renderScale));
            }
          }
          applyGfxPreset(gfxQuality, { keepScale: true });
          if (gfxResScaleSlider) gfxResScaleSlider.value = String(gfxRenderScale);


          ensureBandsInitialized();
          applyBandToUI(bands[activeBandIndex]);
          renderBandChips();
          setOverlayOpen(wantOverlayOpen);
          return;
        }
      }
    } catch (e) {
      // ignore and fall back to legacy
    }

    // Fallback to legacy v1 (single band)
    try {
      const rawV1 = localStorage.getItem(SETTINGS_KEY_V1);
      if (rawV1) {
        const data = JSON.parse(rawV1);
        if (data && typeof data === 'object') {
          const legacyBand = {
            enabled: true,
            monitor: data.monitor,
            handlesByMode: data.handlesByMode,
            centerPitch: data.centerPitch,
            centerRoll: data.centerRoll,
            bandRotationDeg: data.bandRotationDeg,
            polySides: data.polySides,
            rectScalePitch: data.rectScalePitch,
            rectScaleRoll: data.rectScaleRoll,
            ellipseScaleX: data.ellipseScaleX,
            ellipseScaleY: data.ellipseScaleY,
            polyVerts: data.polyVerts,
            polyVertsInner: data.polyVertsInner,
            polyApothemsOuter: data.polyApothemsOuter,
            polyApothemsInner: data.polyApothemsInner,
            centerDir: data.centerDir,
            frameX: data.frameX,
            frameY: data.frameY,
          };

          bands = [deserializeBand(legacyBand, 0)];
          activeBandIndex = 0;

          if (typeof data.camCrossYawDeg === 'number') camCrossYawDeg = data.camCrossYawDeg;
          if (typeof data.camAttachYawOffsetDeg === 'number') camAttachYawOffsetDeg = data.camAttachYawOffsetDeg;

          if (typeof data.sound === 'boolean') soundCheckbox.checked = data.sound;
          wantOverlayOpen = !!data.overlayOpen;
          // BeepCount / CountDown per-band migration from legacy v1.

          const bc = (data.beepCount && typeof data.beepCount === 'object')
                   ? data.beepCount
                   : (data.timer && typeof data.timer === 'object') ? data.timer : null;

          if (bc) {
            const enabled = !!bc.enabled;
            const intervalSec = (typeof bc.intervalSec === 'number' && Number.isFinite(bc.intervalSec)) ? bc.intervalSec : 1.0;
            if (bands[0]) {
              bands[0].beepCount = { enabled, intervalSec };
              ensureBandTimerConfig(bands[0]);
            }
          } else {
            if (bands[0]) ensureBandTimerConfig(bands[0]);
          }

          if (data.countDown && typeof data.countDown === 'object') {
            const enabled = !!data.countDown.enabled;
            const goalSec = (typeof data.countDown.goalSec === 'number' && Number.isFinite(data.countDown.goalSec)) ? data.countDown.goalSec : 10.0;
            const voice = (typeof data.countDown.voice === 'boolean') ? data.countDown.voice : true;
            if (bands[0]) {
              bands[0].countDown = { enabled, goalSec, voice };
              ensureBandTimerConfig(bands[0]);
            }
          }

// Graphics (optional)
          if (data.gfx && typeof data.gfx === 'object') {
            if (typeof data.gfx.quality === 'string') gfxQuality = data.gfx.quality;
            if (typeof data.gfx.renderScale === 'number' && Number.isFinite(data.gfx.renderScale)) {
              gfxRenderScale = Math.max(0.5, Math.min(1.0, data.gfx.renderScale));
            }
          }
          applyGfxPreset(gfxQuality, { keepScale: true });
          if (gfxResScaleSlider) gfxResScaleSlider.value = String(gfxRenderScale);


          ensureBandsInitialized();
          applyBandToUI(bands[activeBandIndex]);
          renderBandChips();
          setOverlayOpen(wantOverlayOpen);

          // Migrate to v2 for next time.
          saveSettings();
          return;
        }
      }
    } catch (e) {
      // ignore
    }

    // Nothing stored: default to 1 band and a closed overlay.
    applyGfxPreset(gfxQuality, { keepScale: true });
    if (gfxResScaleSlider) gfxResScaleSlider.value = String(gfxRenderScale);
    ensureBandsInitialized();
    applyBandToUI(bands[activeBandIndex]);
    renderBandChips();
    syncBeepTimerSettingsFromUI();
    syncCountDownSettingsFromUI();
    setOverlayOpen(false);
  }

  function saveSettings() {
    try {
      ensureBandsInitialized();
      commitActiveBandFromUI();
      const data = {
        version: 2,
        activeBandIndex,
        bands: bands.map(serializeBand),

        camCrossYawDeg,
        camAttachYawOffsetDeg,

        gfx: {
          quality: gfxQuality,
          renderScale: gfxRenderScale,
        },
        timer: {
          enabled: !!beepTimerEnabled,
          intervalSec: beepTimerIntervalSec,
        },

        sound: !!soundCheckbox.checked,
        overlayOpen: (overlayEl ? overlayEl.classList.contains('open') : false),
      };

      localStorage.setItem(SETTINGS_KEY_V2, JSON.stringify(data));
    } catch (e) {
      // ignore
    }
  }

  // Multi-handle slider UI sync (replaces the old single range slider)
  function updateBandSizeUIFromState() {
    renderMultiSlider();
  }

  // Backward-compat stub (the old slider called this).
  function applyBandSizeFromSlider() {
    // No-op: multi-handle slider directly edits ranges.
  }

    // Helper: keep the mode chips visually in sync when mode changes programmatically.
  function setActiveModeChip(mode) {
    if (!modeChipsContainer) return;
    const chips = modeChipsContainer.querySelectorAll('.mode-chip');
    chips.forEach(chip => {
      if (chip.dataset.mode === mode) chip.classList.add('active');
      else chip.classList.remove('active');
    });
  }

function setMode(mode, opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const recenter = options.recenter !== false;

    const allowed = ['pitch','roll','pitchOrRoll','pitchAndRoll','circle','polygon'];
    if (!allowed.includes(mode)) mode = 'pitch';
    monitorSelect.value = mode;
    if (modeChipsContainer) {
      const chips = modeChipsContainer.querySelectorAll('.mode-chip');
      chips.forEach(chip => {
        if (chip.dataset.mode === mode) chip.classList.add('active');
        else chip.classList.remove('active');
      });
    }

    updateBandSizeUIFromState();
    updateBandRotationUIFromState();
    updateUI();
    saveSettings();
  }

  // Mode selection handlers (fix: mode could appear \"stuck\")
  if (modeChipsContainer) {
    modeChipsContainer.addEventListener('click', (ev) => {
      const btn = ev.target && ev.target.closest ? ev.target.closest('.mode-chip') : null;
      if (!btn || !btn.dataset) return;
      const mode = btn.dataset.mode;
      if (mode) setMode(mode);
    });
  }

  // Keep the hidden <select> in sync if something changes it (e.g. accessibility tools)
  if (monitorSelect) {
    monitorSelect.addEventListener('change', () => {
      setMode(monitorSelect.value);
    });
  }

  function updateBandRotationUIFromState() {
    if (!bandRotationSlider) return;
    const band = getBandSettings();
    let angle = band.rotationDeg || 0;
    if (!Number.isFinite(angle)) angle = 0;
    // 0..360 UI (allow 360).
    let norm = wrap360(angle);
    if (Math.abs(norm) < 1e-9 && Math.abs(angle) > 1e-9) norm = 360;
    angle = Math.max(0, Math.min(360, norm));
    bandRotationSlider.value = angle;
    bandRotationValue.textContent = angle.toFixed(0) + '°';
  }

  function updateBandRotationSliderBackground() {
    // NOTE: Some earlier refactors used this to draw a filled track.
    // In this unified UI build, it is safe to be a no-op, but we keep it
    // to avoid runtime errors on mobile and to optionally support CSS vars.
    if (!bandRotationSlider) return;

    const min = parseFloat(bandRotationSlider.min || '0') || 0;
    const max = parseFloat(bandRotationSlider.max || '360') || 360;
    const val = parseFloat(bandRotationSlider.value) || 0;

    const t = (max > min) ? (val - min) / (max - min) : 0;
    const pct = Math.max(0, Math.min(1, t)) * 100;

    // Expose a CSS variable that can be used by styling if desired.
    bandRotationSlider.style.setProperty('--fillPct', pct.toFixed(2) + '%');
  }


  function updateCamAttachYawOffsetUIFromState() {
    if (!camAttachYawOffsetSlider || !camAttachYawOffsetValue) return;
    const a = wrap360(camAttachYawOffsetDeg || 0);
    camAttachYawOffsetSlider.value = a;
    camAttachYawOffsetValue.textContent = a.toFixed(0) + '°';
  }

  // Center from current tilt
  if (centerFromCurrentBtn) {
    
  function applyCenterFromTiltInclYaw({ announce = false } = {}) {
    const band = getBandSettings();
    const mode = band.modeStr;

    // Use the current *gravity direction* and derive canonical pitch/roll.
    // This keeps pitch in [-90, 90] even when the device is upside-down and
    // matches the shader's pitch/roll computation.
    const prTilt = dirToPitchRollDeg(gravityDir);
    const pitchVal = prTilt.pitch;
    const rollVal  = prTilt.roll;

    centerPitchInput.value = pitchVal.toFixed(2);
    centerRollInput.value  = rollVal.toFixed(2);
    bandCenterDir = gravityDir.slice();
    updateBandFrameFromDir(bandCenterDir);

    // Include yaw: map device yaw (CW+) to band rotation (CCW+)
    const yawDeg = (Number.isFinite(deviceYawDeg) ? deviceYawDeg : camCrossYawDeg);
    // Map yaw (CW+) to band rotation (CCW+) on a 0..360° axis.
    bandRotationInput.value = wrap360(-yawDeg).toFixed(2);

    // For pitch/roll-only modes, keep the same width and just recenter the range.
    const halfWidth = (band.max - band.min) * 0.5;
    if (mode === 'pitch') {
      setHandles('pitch', [pitchVal - halfWidth, pitchVal + halfWidth], { save:false, update:false, render:false });
    } else if (mode === 'roll') {
      setHandles('roll',  [rollVal  - halfWidth, rollVal  + halfWidth], { save:false, update:false, render:false });
    }

    updateBandSizeUIFromState();
    saveSettings();
    updateUI();

    if (announce) flashMessage('Centered to current tilt');
  }

centerFromCurrentBtn.addEventListener('click', () => {
      applyCenterFromTiltInclYaw({ announce:true });
    });
  }

  // Center from camera (also used by long-press)
  function applyCenterFromCamera(opts) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const announce = options.announce === true;

    const camAngles = computeCrossAngles(lastCamCenter, lastCamUp);
    if (!camAngles) {
      if (announce) flashStatus('Camera center unavailable.');
      return false;
    }

    const band = getBandSettings();
    const mode = band.modeStr;
    const pitchVal = camAngles.pitchDeg;
    const rollVal  = camAngles.yawDeg;

    centerPitchInput.value = pitchVal.toFixed(1);
    centerRollInput.value  = rollVal.toFixed(1);

    // If we're in Polygon mode, treat the camera "roll" (rotation of the camera's up
    // vector around the view axis) as the polygon's rotation about its center.
    // This makes the band rotation follow the camera when you "Use current view".
    if (mode === 'polygon' && bandRotationInput) {
      let rot = (typeof camAngles.rollDeg === 'number') ? camAngles.rollDeg : 0;
      if (!Number.isFinite(rot)) rot = 0;
      rot = wrap360(-rot);
      bandRotationInput.value = rot.toFixed(0);
      updateBandRotationUIFromState();
    }

    bandCenterDir = normalize3(lastCamCenter.slice());
    updateBandFrameFromDir();

    let minVal    = band.min;
    let maxVal    = band.max;
    let halfWidth = (maxVal - minVal) * 0.5;
    if (!(halfWidth > 0)) {
      let fallback = 1;
      // Fallback: use half-width of the first stripe (or 1°).
      const rr = band.ranges || getRanges(mode);
      if (rr && rr.length) {
        const hw = Math.abs(rr[0].max - rr[0].min) * 0.5;
        if (Number.isFinite(hw) && hw > 0) fallback = hw;
      }
      halfWidth = fallback;
    }

    if (mode === 'pitch') {
      const center = pitchVal;
      setHandles('pitch', [center - halfWidth, center + halfWidth], { save:false, update:false, render:false });
    } else if (mode === 'roll') {
      const center = rollVal;
      setHandles('roll', [center - halfWidth, center + halfWidth], { save:false, update:false, render:false });
    }

    updateBandSizeUIFromState();
    saveSettings();
    updateUI();

    if (announce) flashStatus('Band center set to camera.');
    return true;
  }

  // Center from camera (button)
  if (centerFromCameraBtn) {
    centerFromCameraBtn.addEventListener('click', () => {
      applyCenterFromCamera({ announce:false });
    });
  }


  if (centerResetBtn) {
    centerResetBtn.addEventListener('click', () => {
      centerPitchInput.value = 0;
      centerRollInput.value  = 0;
      bandCenterDir = [0,0,1];
      updateBandFrameFromDir();
      saveSettings();
      updateUI();
    });
  }

  if (polySidesSlider) {
    polySidesSlider.addEventListener('input', () => {
      const val = parseInt(polySidesSlider.value, 10) || 3;
      polySidesInput.value = val;
      if (polySidesValue) polySidesValue.textContent = val + '‑gon';

      // IMPORTANT:
      // Polygon mode is now stored as explicit vertices (polyVerts) + derived half-planes (polyPlanes).
      // So when the user changes the number of sides, we must also regenerate the polygon geometry,
      // otherwise we'll keep rendering the previous (e.g. 3-gon) shape but tell the shader to use N sides.
      resetPolyVerts(val, polyVerts, polyPlanes);
      resetPolyVerts(val, polyVertsInner, polyPlanesInner);
      polyVertsLoaded = true;
      polyVertsInnerLoaded = true;
      saveSettings();
      updateUI();
    });
  }

  if (bandRotationSlider) {
    bandRotationSlider.addEventListener('input', () => {
      const val = parseFloat(bandRotationSlider.value) || 0;
      bandRotationInput.value = val.toFixed(0);
      bandRotationValue.textContent = val.toFixed(0) + '°';
      saveSettings();
      updateUI();
    });
  }

  if (camAttachYawOffsetSlider) {
    camAttachYawOffsetSlider.addEventListener('input', () => {
      const val = parseFloat(camAttachYawOffsetSlider.value) || 0;
      camAttachYawOffsetDeg = wrap360(val);
      if (camAttachYawOffsetValue) camAttachYawOffsetValue.textContent = camAttachYawOffsetDeg.toFixed(0) + '°';
      saveSettings();
    });
  }


  // --- Graphics controls ----------------------------------------------------
  function updateGfxSummaryUI() {
    if (gfxSummaryEl) {
      gfxSummaryEl.textContent = (gfxQuality === 'high') ? 'High' : (gfxQuality === 'performance') ? 'Performance' : 'Balanced';
    }
  }

  if (gfxQualitySelect) {
    gfxQualitySelect.addEventListener('change', () => {
      applyGfxPreset(gfxQualitySelect.value, { keepScale: false });
      // Preset may change the slider; keep the internal scale in sync.
      applyGfxScaleFromUI();
      updateGfxSummaryUI();
      saveSettings();
    });
  }

  if (gfxResScaleSlider) {
    gfxResScaleSlider.addEventListener('input', () => {
      applyGfxScaleFromUI();
      saveSettings();
    });
  }

  bandRotationInput.addEventListener('change', () => {
    updateBandRotationUIFromState();
    saveSettings();
    updateUI();
  });

  if (soundToggle) {
    soundToggle.addEventListener('click', () => {
      soundCheckbox.checked = !soundCheckbox.checked;
      updateSoundToggleUI();
      saveSettings();
      if (!soundCheckbox.checked) stopWarningTone();
    });
  }

  // minAngle/maxAngle are kept only as legacy/debug values; slider owns ranges now.

  centerPitchInput.addEventListener('change', () => {
    const band = getBandSettings();
    bandCenterDir = tiltToDir(band.centerPitch, band.centerRoll);
    updateBandFrameFromDir();
    saveSettings();
    updateUI();
  });
  centerRollInput.addEventListener('change', () => {
    const band = getBandSettings();
    bandCenterDir = tiltToDir(band.centerPitch, band.centerRoll);
    updateBandFrameFromDir();
    saveSettings();
    updateUI();
  });

  polySidesInput.addEventListener('change', () => {
    const n = parseFloat(polySidesInput.value);
    resetPolyVerts(n, polyVerts, polyPlanes);
    resetPolyVerts(n, polyVertsInner, polyPlanesInner);
    polyVertsLoaded = true;
    polyVertsInnerLoaded = true;
    saveSettings();
    updateUI();
  });

  soundCheckbox.addEventListener('change', () => {
    saveSettings();
    updateSoundToggleUI();
    if (!soundCheckbox.checked) stopWarningTone();
  });


  // --- Timer / beeps -------------------------------------------------------
  if (timerEnabledCheckbox) {
    timerEnabledCheckbox.addEventListener('change', () => {
      syncBeepTimerSettingsFromUI({ commit:true });

      // Apply to the active band's config immediately (runtime follows in-range bands).
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.beepCount.enabled = !!beepTimerEnabled;
          b.beepCount.intervalSec = beepTimerIntervalSec;
        }
      } catch (_) {}

      saveSettings();
    });
  }

  if (timerIntervalInput) {
    timerIntervalInput.addEventListener('input', () => {
      // Update cadence live without saving on every keystroke.
      syncBeepTimerSettingsFromUI({ commit:false });

      // Apply to the active band's config immediately so runtime follows it.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.beepCount.enabled = !!beepTimerEnabled;
          b.beepCount.intervalSec = beepTimerIntervalSec;
        }
      } catch (_) {}

      // (no save on every keystroke)
    });

    timerIntervalInput.addEventListener('change', () => {
      // On commit (blur / enter), normalize the text and persist.
      syncBeepTimerSettingsFromUI({ commit:true });

      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.beepCount.enabled = !!beepTimerEnabled;
          b.beepCount.intervalSec = beepTimerIntervalSec;
        }
      } catch (_) {}

      saveSettings();
    });
  }

  if (timerResetBtn) {
    timerResetBtn.addEventListener('click', () => {
      // Reset the active band's BeepCount runtime state.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          const st = b._beepCountState;
          st.wasInRange = false; // next tick treats it like a fresh entry (if in-range)
          st.elapsedMs = 0;
          st.beepCount = 0;
          st.startMs = performance.now();
          st.nextBeepMs = 0;
        }
      } catch (_) {}
    });
  }

  // Interval presets (⅓s, ½s, 1s, 2s)
  Array.from(document.querySelectorAll('[data-timer-preset]')).forEach((btn) => {
    btn.addEventListener('click', () => {
      const v = parseFloat(btn.getAttribute('data-timer-preset'));
      if (Number.isFinite(v) && timerIntervalInput) {
        timerIntervalInput.value = String(v);
      }
      syncBeepTimerSettingsFromUI({ commit:true });

      // Apply to the active band's config immediately.
      try {
        const b = (Array.isArray(bands) && activeBandIndex >= 0 && activeBandIndex < bands.length) ? bands[activeBandIndex] : null;
        if (b) {
          ensureBandTimerConfig(b);
          b.beepCount.enabled = !!beepTimerEnabled;
          b.beepCount.intervalSec = beepTimerIntervalSec;
        }
      } catch (_) {}

      saveSettings();
    });
  });

  if (settingsToggle) {
    // Start sensors/audio on the earliest possible user gesture.
    // (Important on iOS and some WebViews: motion permissions must be requested
    // directly inside a user gesture event. Pointer events are the most reliable.)
    settingsToggle.addEventListener('pointerdown', () => {
      try { handleFirstUserInteraction(); } catch (_) {}
    }, { passive: true });
    settingsToggle.addEventListener('touchstart', () => {
      try { handleFirstUserInteraction(); } catch (_) {}
    }, { passive: true });

    settingsToggle.addEventListener('click', () => {
      const willOpen = !overlayOpen;
      // iOS requires a user gesture before motion sensors can be enabled.
      // Opening the settings panel is the earliest reliable gesture.
      if (willOpen) {
        try { handleFirstUserInteraction(); } catch (_) {}
      }
      setOverlayOpen(willOpen);
      saveSettings();
    });
  }


  // Band controls
  if (addBandBtn) {
    addBandBtn.addEventListener('click', addNewBand);
  }
  if (dupBandBtn) {
    dupBandBtn.addEventListener('click', duplicateActiveBand);
  }
  if (removeBandBtn) {
    removeBandBtn.addEventListener('click', removeActiveBand);
  }
  if (bandEnabledCheckbox) {
    bandEnabledCheckbox.addEventListener('change', () => {
      const band = bands[activeBandIndex];
      if (!band) return;
      band.enabled = !!bandEnabledCheckbox.checked;
      renderBandChips();
      saveSettings();
      updateUI();
    });
  }

  if (moveBandUpBtn) {
    moveBandUpBtn.addEventListener('click', () => moveActiveBand(-1));
  }
  if (moveBandDownBtn) {
    moveBandDownBtn.addEventListener('click', () => moveActiveBand(1));
  }
  if (bandNameInput) {
    bandNameInput.addEventListener('input', () => {
      const band = bands[activeBandIndex];
      if (!band) return;
      band.name = (bandNameInput.value || '').slice(0, 24);
      renderBandChips();
      saveSettings();
    });
  }
  if (bandColorInput) {
    bandColorInput.addEventListener('input', () => {
      const band = bands[activeBandIndex];
      if (!band) return;
      const c = hexToSrgb01(bandColorInput.value);
      if (c) band.color = c;
      renderBandChips();
      saveSettings();
      updateUI();
    });
  }
  if (overlayCloseBtn) {
    overlayCloseBtn.addEventListener('click', () => {
      setOverlayOpen(false);
      saveSettings();
    });
  }

// Sheet grabber: drag to resize, tap to expand/collapse, drag down to close.
let sheetDragActive = false;
let sheetDragStartPos = 0;
let sheetDragStartH = 0;
let sheetDragMoved  = false;
let sheetIgnoreClick = false;

function settleSheetAfterDrag() {
  if (!overlayEl) return;
  const maxPx = getSheetMaxPx();
  const minPx = getSheetMinPx();
  const collapsed = getSheetCollapsedPx();
  const h = Number.isFinite(sheetHeightPx) ? sheetHeightPx : overlayEl.getBoundingClientRect()[isLandscapeUI() ? 'width' : 'height'];

  // Only three stable states:
  // 1) Closed (sheet dismissed)
  // 2) Shrink (collapsed detent)
  // 3) Full (expanded detent)
  //
  // During the drag we may pass through intermediate heights, but on release we
  // always snap to one of the three.
  const closeThresh = (minPx + collapsed) * 0.5;
  const mid = (collapsed + maxPx) * 0.5;

  if (h <= closeThresh) {
    // Reset to the shrink detent so the next open starts sane.
    sheetHeightPx = collapsed;
    setOverlayOpen(false);
    return;
  }

  applySheetHeight(h >= mid ? maxPx : collapsed);
}

if (sheetGrabber) {
  // Click toggles expanded/collapsed (unless the click was generated by a drag).
  sheetGrabber.addEventListener('click', (e) => {
    if (sheetIgnoreClick) return;
    if (!overlayOpen) return;
    toggleSheetExpanded();
    e.preventDefault();
  });

  sheetGrabber.addEventListener('pointerdown', (e) => {
    if (!overlayOpen || !overlayEl) return;
    sheetDragActive = true;
    sheetDragMoved = false;
    sheetIgnoreClick = false;

    overlayEl.classList.add('sheet-dragging');
    document.body.classList.add('sheet-dragging');

    sheetDragStartPos = isLandscapeUI() ? e.clientX : e.clientY;
    sheetDragStartH = overlayEl.getBoundingClientRect()[isLandscapeUI() ? 'width' : 'height'];

    try { sheetGrabber.setPointerCapture(e.pointerId); } catch (_) {}
    e.preventDefault();
  });

  sheetGrabber.addEventListener('pointermove', (e) => {
    if (!sheetDragActive) return;
    const cur = isLandscapeUI() ? e.clientX : e.clientY;
    const delta = isLandscapeUI() ? (cur - sheetDragStartPos) : (sheetDragStartPos - cur);
    if (Math.abs(delta) > 4) sheetDragMoved = true;

    applySheetHeight(sheetDragStartH + delta, true);

    if (sheetDragMoved) sheetIgnoreClick = true;
    e.preventDefault();
  });

  sheetGrabber.addEventListener('pointerup', (e) => {
    if (!sheetDragActive) return;
    sheetDragActive = false;

    try { sheetGrabber.releasePointerCapture(e.pointerId); } catch (_) {}

    // Re-enable height transition for the snap animation.
    if (overlayEl) overlayEl.classList.remove('sheet-dragging');
    document.body.classList.remove('sheet-dragging');

    if (sheetDragMoved) {
      // Prevent the synthetic click that follows a drag from toggling expand/collapse.
      sheetIgnoreClick = true;
      // iOS can dispatch the synthetic click noticeably later than desktop.
      setTimeout(() => { sheetIgnoreClick = false; }, 350);

      // Snap to the nearest detent on the next frame (so transitions are active).
      requestAnimationFrame(() => {
        settleSheetAfterDrag();
        saveSettings();
      });

      e.preventDefault();
    }
  });

  sheetGrabber.addEventListener('pointercancel', (e) => {
    if (!sheetDragActive) return;
    sheetDragActive = false;
    if (overlayEl) overlayEl.classList.remove('sheet-dragging');
    document.body.classList.remove('sheet-dragging');
    document.body.classList.remove('sheet-dragging');
    try { sheetGrabber.releasePointerCapture(e.pointerId); } catch (_) {}
    settleSheetAfterDrag();
    saveSettings();
    sheetIgnoreClick = true;
    setTimeout(() => { sheetIgnoreClick = false; }, 350);
    e.preventDefault();
  });
}

// Keep the sheet height sane on rotation / resize.
window.addEventListener('resize', () => {
  if (!overlayOpen) return;
  const maxPx = getSheetMaxPx();
  const collapsed = getSheetCollapsedPx();
  const expanded = (sheetGrabber && sheetGrabber.getAttribute('aria-expanded') === 'true');
  sheetHeightPx = expanded ? maxPx : collapsed;
  applySheetHeight(sheetHeightPx);
});

  // === Band membership test ================================================
  // Shared hit-test used by UI logic, timers, and tap-to-select.
  function isInBand(settings, pitchDeg, rollDeg) {
    const mode = settings.modeStr;
    const ranges = settings.ranges || [{ min: 0, max: 1 }];

    if (mode === 'pitch') {
      return valueInRangesLinear(pitchDeg, ranges);
    }
    if (mode === 'roll') {
      return valueInRangesAngle360(rollDeg, ranges);
    }
    if (mode === 'pitchOrRoll' || mode === 'pitchAndRoll') {
      const pitchRel = pitchDeg - (settings.centerPitch || 0);
      const rollRel  = wrap180(rollDeg - (settings.centerRoll || 0));

      const sp = Math.max(1e-6, (settings.rectScalePitch != null ? settings.rectScalePitch : rectScalePitch));
      const sr = Math.max(1e-6, (settings.rectScaleRoll  != null ? settings.rectScaleRoll  : rectScaleRoll));

      const pitchScaled = Math.abs(pitchRel) / sp;
      const rollScaled  = Math.abs(rollRel) / sr;

      for (const r of ranges) {
        const lo = Math.min(r.min, r.max);
        const hi = Math.max(r.min, r.max);

        const outer = (mode === 'pitchOrRoll') ? (pitchScaled <= hi || rollScaled <= hi) : (pitchScaled <= hi && rollScaled <= hi);
        const hole  = (lo > 1e-6) && (pitchScaled < lo && rollScaled < lo);

        if (outer && !hole) return true;
      }
      return false;
    }
    if (mode === 'circle') {
      const centerDir = normalize3(settings.centerDir || bandCenterDir);
      const devDir = tiltToDir(pitchDeg, rollDeg);
      const d = clamp(dot3(centerDir, devDir), -1, 1);
      const radiusDeg = Math.acos(d) * (180 / Math.PI);
      return valueInRangesLinear(radiusDeg, ranges);
    }
    if (mode === 'polygon') {
      const centerDir = normalize3(settings.centerDir || bandCenterDir);
      let frameX = (Array.isArray(settings.frameX) ? settings.frameX.slice() : bandFrameX.slice());
      let frameY = (Array.isArray(settings.frameY) ? settings.frameY.slice() : bandFrameY.slice());

      // Orthonormalize frame: project away the center direction.
      frameX = normalize3(sub3(frameX, mul3(centerDir, dot3(frameX, centerDir))));
      frameY = normalize3(sub3(frameY, mul3(centerDir, dot3(frameY, centerDir))));
      frameY = normalize3(sub3(frameY, mul3(frameX, dot3(frameY, frameX))));

      const devDir = tiltToDir(pitchDeg, rollDeg);

      const pLocalX = dot3(devDir, frameX);
      const pLocalY = dot3(devDir, frameY);
      const theta0 = Math.atan2(pLocalY, pLocalX);

      const rotRad = (settings.rotationDeg || 0) * (Math.PI / 180);
      const theta  = theta0 - rotRad;

      const dArc = clamp(dot3(devDir, centerDir), -1, 1);
      const radiusDeg = Math.acos(dArc) * (180 / Math.PI);

      const x = radiusDeg * Math.cos(theta);
      const y = radiusDeg * Math.sin(theta);

      const sides = Math.max(3, Math.min(MAX_POLY_SIDES_JS, (settings.polySides | 0) || 3));
      const planesOuter = settings.polyPlanes || polyPlanes;
      const planesInner = settings.polyPlanesInner || polyPlanesInner;

      let dOuter = -Infinity;
      for (let i = 0; i < sides; i++) {
        const nx = planesOuter[i * 3 + 0];
        const ny = planesOuter[i * 3 + 1];
        const c  = planesOuter[i * 3 + 2];
        dOuter = Math.max(dOuter, x * nx + y * ny + c);
      }

      let dInner = -Infinity;
      for (let i = 0; i < sides; i++) {
        const nx = planesInner[i * 3 + 0];
        const ny = planesInner[i * 3 + 1];
        const c  = planesInner[i * 3 + 2];
        dInner = Math.max(dInner, -(x * nx + y * ny + c));
      }

      const minDistToRing = Math.max(dOuter, dInner);
      if (minDistToRing > 0) return false;

      const polyGauge = Math.min(-dOuter, -dInner);
      return valueInRangesLinear(polyGauge, ranges);
    }

    return false;
  }


  // === UI update ============================================================
  function updateUI() {
    const camAngles = computeCrossAngles(lastCamCenter, lastCamUp);

    // Camera "Rot" in two forms:
    //  - camRotText: the camera label's 0..360 rot readout
    //  - camRotBandText: the sign convention used when showing camera-derived Rot
    //    inside the gravity label while the camera is *attached*.
    let camRotText = 'n/a';
    let camRotBandText = 'n/a';
    if (camAngles && Number.isFinite(camAngles.rollDeg)) {
      camRotText = formatAngle360(camAngles.rollDeg, 1);
      camRotBandText = formatAngle360(-camAngles.rollDeg, 1);
    }

    // Canonical gravity tilt angles derived from the gravity direction.
    // This prevents "upside-down" cases (beta>90) from breaking band membership.
    const tiltPR = dirToPitchRollDeg(gravityDir);
    const tiltPitch = tiltPR.pitch;
    const tiltRoll  = tiltPR.roll;

    // Keep readouts + crosshair labels up to date
    if (screenEl) screenEl.textContent = getScreenOrientationDegrees() + '°';

    if (gravityTiltLabel) {
      if (haveSensorData) {
        const yText = (deviceYawDeg != null && !Number.isNaN(deviceYawDeg))
          ? ((((deviceYawDeg % 360) + 360) % 360).toFixed(1) + '°')
          : 'n/a';

        // Keep camera rotation visible even when the camera label fades (when the
        // camera crosshair is too close to the gravity crosshair).
        //
        // - If the camera is *attached*: show the band-rotation sign convention.
        // - If not attached but the crosses are merging: fade-in the camera rot value
        //   inside the gravity label as the camera label fades out.
        let rotHtml = '';
        if (camAngles) {
          if (cameraAttachedToGravity) {
            rotHtml = `  <span class="cam-attached-val">Rot ${camRotBandText}</span>`;
          } else if (camToGravMergeFactor > 0.001) {
            const op = Math.min(1, Math.max(0, camToGravMergeFactor));
            rotHtml = `  <span class="cam-attached-val" style="opacity:${op.toFixed(2)}">Rot ${camRotText}</span>`;
          }
        }

        const gHtml =
          `P ${tiltPitch.toFixed(1)}°  ` +
          `R ${tiltRoll.toFixed(1)}°  ` +
          `Y ${yText}` +
          rotHtml;
        setTiltLabelHtmlAnimated(gravityTiltLabel, gHtml);
      } else {
        setTiltLabelTextAnimated(gravityTiltLabel, 'Tilt: n/a');
      }
    }

    if (cameraTiltLabel) {
      if (camAngles) {
        const rotText = formatAngle360(camAngles.rollDeg, 1);

        const camLabelText =
          `View P ${camAngles.pitchDeg.toFixed(1)}°  ` +
          `R ${camAngles.yawDeg.toFixed(1)}°  ` +
          `Rot ${rotText}`;
        setTiltLabelTextAnimated(cameraTiltLabel, camLabelText);
      } else {
        setTiltLabelTextAnimated(cameraTiltLabel, 'View: n/a');
      }
    }

    const yaw = deviceYawDeg;
    const pitch = tiltPitch;
    const roll = tiltRoll;

    // camera direction in world (horizontal yaw with extra offset)
    const yawCam = (yaw + camAttachYawOffsetDeg) * (Math.PI / 180);
    const camDir = normalize3([Math.sin(yawCam), 0, Math.cos(yawCam)]);

    // gravity direction in world from pitch & roll
    const gravDir = tiltToDir(pitch, roll);

    // update camera center text + patch centers
    const cameraCenterPitch = Math.asin(clamp(camDir[1], -1, 1)) * (180 / Math.PI);
    const cameraCenterRoll  = Math.atan2(camDir[0], camDir[2]) * (180 / Math.PI);

    let patchCenters = '';
    for (let dx of [-1, 0, 1]) {
      for (let dy of [-1, 0, 1]) {
        const x = dx * 45;
        const y = dy * 45;
        const dPitch = (pitch - x);
        const dRoll  = wrap180(roll - y);
        const d2 = dPitch * dPitch + dRoll * dRoll;
        patchCenters += `(${x},${y}) d=${Math.sqrt(d2).toFixed(1)}<br>`;
      }
    }
    patchCentersText.innerHTML = patchCenters;

    const camCrossPitch = Math.asin(clamp(camDir[1], -1, 1)) * (180 / Math.PI);
    const camCrossRoll  = Math.atan2(camDir[0], camDir[2]) * (180 / Math.PI);
    if (camCrossText) camCrossText.innerHTML = `Camera Cross: Pitch ${camCrossPitch.toFixed(1)}°, Roll ${camCrossRoll.toFixed(1)}°`;

    const gravCrossPitch = Math.asin(clamp(gravDir[1], -1, 1)) * (180 / Math.PI);
    const gravCrossRoll  = Math.atan2(gravDir[0], gravDir[2]) * (180 / Math.PI);
    if (gravCrossText) gravCrossText.innerHTML = `Gravity Cross: Pitch ${gravCrossPitch.toFixed(1)}°, Roll ${gravCrossRoll.toFixed(1)}°`;

    // --- Band status (multiple bands, union) --------------------------------
    ensureBandsInitialized();
    commitActiveBandFromUI();

    const enabledCount = bands.reduce((acc, b) => acc + (b && b.enabled !== false ? 1 : 0), 0);

    
    const activeBand = bands[activeBandIndex];
    const activeSettings = getBandSettingsForBand(activeBand);

    const rangeDisp = getRangeDisplay(activeSettings.modeStr, activeSettings.ranges || [], activeSettings);

    // Keep the range readout in sync even when the band is stretched via on-sphere handles
    // (which can change rect/ellipse scales or polygon vertices without touching the slider handles).
    if (bandSizeValue) bandSizeValue.textContent = rangeDisp.compact;

    // Keep slider handle labels in sync with current stretch (edge/corner handle drags can
    // change the mapping from raw slider values to effective degrees).
    updateMultiSliderHandleLabels(activeSettings);

    const rangeLinesHtml = (rangeDisp.lines && rangeDisp.lines.length)
      ? rangeDisp.lines.join('<br>')
      : '[—]';

    const modeName = {
      pitch: 'Pitch',
      roll: 'Roll',
      pitchOrRoll: 'Pitch OR Roll',
      pitchAndRoll: 'Pitch AND Roll',
      circle: 'Circle',
      polygon: 'Polygon',
    }[activeSettings.modeStr] || activeSettings.modeStr;

    const enabledLabel = (activeBand && activeBand.enabled === false) ? '<span class="status-off">disabled</span>' : '<span class="status-on">enabled</span>';

    bandText.innerHTML =
      `Band ${activeBandIndex + 1}/${bands.length} (${enabledLabel})<br>` +
      `<small>${modeName} • ${enabledCount} enabled<br>${rangeLinesHtml}</small>`;

    if (bandSummaryEl) {
      const rn = (activeSettings.ranges && activeSettings.ranges.length) ? activeSettings.ranges.length : 0;
      bandSummaryEl.textContent = `${modeName} • ${rn} range${rn === 1 ? '' : 's'}`;
    }



    let unionInRange = false;
    let distanceNorm = 1.0;
    let bestBand = -1;
    const inRangeSet = new Set();

    if (haveSensorData) {
      for (let i = 0; i < bands.length; i++) {
        const b = bands[i];
        if (!b || b.enabled === false) continue;

        const s = getBandSettingsForBand(b);
        const inBand = isInBand(s, pitch, roll);
        if (!inBand) continue;

        unionInRange = true;
        inRangeSet.add(i);

        const dn = computeAudioDistanceNormalized(s, pitch, roll);
        if (dn < distanceNorm) {
          distanceNorm = dn;
          bestBand = i;
        }
      }
    }

    renderBandChips(inRangeSet);

    if (!haveSensorData) {
      rangeStatus.innerHTML = '<span class="status-off">NO SENSOR DATA</span>';
    } else if (unionInRange) {
      const list = Array.from(inRangeSet).map(i => `B${i + 1}`).join(', ');
      const suffix = (inRangeSet.size <= 1) ? ` (${list})` : ` (${inRangeSet.size} bands: ${list})`;
      rangeStatus.innerHTML = `<span class="status-on">IN RANGE</span>${suffix}`;
    } else {
      rangeStatus.innerHTML = '<span class="status-off">OUT OF RANGE</span>';
    }

    globalInRange = unionInRange;
    activeBandInRange = !!(haveSensorData && inRangeSet && inRangeSet.has(activeBandIndex));

    const nowMs = performance.now();
    tickTimersAllBands(nowMs, inRangeSet, haveSensorData);
    updateTimersReadouts(nowMs, inRangeSet, haveSensorData);

    updateWarningTone(distanceNorm, haveSensorData, unionInRange);
  }

  function updateLabels(eye, right, up, forward, halfHeight, halfWidth, gCenter, camCenter) {
    // Defensive: updateLabels is sometimes called from UI code without a valid view state.
    // In that case, just skip instead of crashing on eye[0].
    if (!eye || !right || !up || !forward || eye.length < 3 || right.length < 3 || up.length < 3 || forward.length < 3) return;
    const eyeDir = normalize3(eye);
    const width  = canvas.clientWidth || window.innerWidth;
    const height = canvas.clientHeight || window.innerHeight;
    const rect = (lastViewState && lastViewState.rect) ? lastViewState.rect : canvas.getBoundingClientRect();
    const offX = rect ? rect.left : 0;
    const offY = rect ? rect.top : 0;
    const band   = 0.3;

    // Axis labels
    for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      const dir   = normalize3(label.dir);
      const pos   = dir;
      const toPoint = sub3(pos, eye);
      const planeX  = dot3(toPoint, right);
      const planeY  = dot3(toPoint, up);
      const ndcX    = planeX / halfWidth;
      const ndcY    = planeY / halfHeight;
      if (Math.abs(ndcX) > 1.1 || Math.abs(ndcY) > 1.1) {
        label.el.style.opacity = '0';
        continue;
      }
      const sx = (ndcX * 0.5 + 0.5) * width;
      const sy = (1 - (ndcY * 0.5 + 0.5)) * height;
      const d = dot3(dir, eyeDir);
      let alpha;
      if (d >= band) alpha = 1.0;
      else if (d <= -band) alpha = 0.0;
      else alpha = (d + band) / (2.0 * band);
      if (alpha <= 0.001) {
        label.el.style.opacity = '0';
        continue;
      }
      label.el.style.left      = (offX + sx) + 'px';
      label.el.style.top       = (offY + sy) + 'px';
      label.el.style.transform = 'translate(-50%, -50%)';
      label.el.style.opacity   = alpha.toFixed(3);
    }

    function projectCross(dir) {
      if (!dir) return { valid: false };
      const dNorm = normalize3(dir);
      const pos   = dNorm;
      const toPoint = sub3(pos, eye);
      const planeX  = dot3(toPoint, right);
      const planeY  = dot3(toPoint, up);
      const ndcX    = planeX / halfWidth;
      const ndcY    = planeY / halfHeight;

      const ax = (ndcX * 0.5 + 0.5) * width;
      const ay = (1 - (ndcY * 0.5 + 0.5)) * height;

      const d = dot3(dNorm, eyeDir);
      const fadeBand = 0.15;
      let alpha;
      if (d >= fadeBand) alpha = 1.0;
      else if (d <= -fadeBand) alpha = 0.0;
      else alpha = (d + fadeBand) / (2.0 * fadeBand);

      const onScreen = Math.abs(ndcX) <= 1.1 && Math.abs(ndcY) <= 1.1;
      return { valid: true, ax, ay, alpha, onScreen };
    }

    const gCenterProj = projectCross(gCenter);
    const cCenterProj = projectCross(camCenter);

    // Alignment / merge
    let alignedCrosses = false;
    let mergeFactor    = 0.0;
    if (gCenter && camCenter) {
      const ng = normalize3(gCenter);
      const nc = normalize3(camCenter);
      let d  = dot3(ng, nc);
      d = Math.max(-1, Math.min(1, d));
      const angleDeg = Math.acos(d) * 180 / Math.PI;
      const MERGE_FULL_DEG  = 0.5;
      const MERGE_START_DEG = 5.0;
      if (angleDeg <= MERGE_FULL_DEG) {
        alignedCrosses = true;
        mergeFactor = 1.0;
      } else if (angleDeg <= MERGE_START_DEG) {
        const tRaw = (angleDeg - MERGE_FULL_DEG) / (MERGE_START_DEG - MERGE_FULL_DEG);
        const t = Math.min(Math.max(tRaw, 0.0), 1.0);
        const s = t*t*(3.0 - 2.0*t);
        mergeFactor = 1.0 - s;
      }
    }

    // Expose mergeFactor to the UI text updater so it can keep "Rot" visible
    // inside the gravity label as the camera label fades away near the crosshair.
    camToGravMergeFactor = mergeFactor;

    let gHasAnchor = !!(gCenterProj.valid && gravityTiltLabel);
    let cHasAnchor = !!(cCenterProj.valid && cameraTiltLabel);

    if (!gHasAnchor && !cHasAnchor) {
      gravityTiltLabel.style.opacity = '0';
      cameraTiltLabel.style.opacity  = '0';
    }

    function getHalfSize(el) {
      let hx = 32, hy = 10;
      if (!el) return {hx,hy};
      const rect = el.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        hx = rect.width  * 0.5;
        hy = rect.height * 0.5;
      }
      return {hx,hy};
    }

    function clampLabelWithinScreen(x, y, hx, hy) {
      const width  = canvas.clientWidth || window.innerWidth;
      const height = canvas.clientHeight || window.innerHeight;
      const margin = 4;
      let minX = hx + margin;
      let maxX = width  - hx - margin;
      let minY = hy + margin;
      let maxY = height - hy - margin;
      if (minX > maxX) { const cx=width*0.5; minX=maxX=cx; }
      if (minY > maxY) { const cy=height*0.5; minY=maxY=cy; }
      const clampedX = Math.min(Math.max(x, minX), maxX);
      const clampedY = Math.min(Math.max(y, minY), maxY);
      return { x: clampedX, y: clampedY };
    }

    function computeScreenInterval(crossX, crossY, dirX, dirY, hx, hy, maxOffset) {
      const width  = canvas.clientWidth || window.innerWidth;
      const height = canvas.clientHeight || window.innerHeight;
      const eps = 1e-4;
      const screenMargin = 2;
      const HX = hx + screenMargin;
      const HY = hy + screenMargin;

      let sMin = 0;
      let sMax = maxOffset;
      let valid = true;

      function applyIneq(A, B, isGreater) {
        if (!valid) return;
        if (Math.abs(A) < eps) {
          const lhs = 0;
          if (isGreater && lhs < B) valid = false;
          else if (!isGreater && lhs > B) valid = false;
          return;
        }
        const sEdge = B / A;
        if (isGreater) {
          if (A > 0) { if (sEdge > sMin) sMin = sEdge; }
          else       { if (sEdge < sMax) sMax = sEdge; }
        } else {
          if (A > 0) { if (sEdge < sMax) sMax = sEdge; }
          else       { if (sEdge > sMin) sMin = sEdge; }
        }
      }

      applyIneq(dirX, HX - crossX, true);
      applyIneq(dirX, (width - HX) - crossX, false);
      applyIneq(dirY, HY - crossY, true);
      applyIneq(dirY, (height - HY) - crossY, false);

      if (!valid) return { valid:false, sMin:0, sMax:maxOffset };
      sMin = Math.max(sMin, 0);
      sMax = Math.min(sMax, maxOffset);
      if (sMax < sMin) valid = false;
      return { valid, sMin, sMax };
    }

    const marginSelf       = 14;
    const marginOtherCross = 10;
    const marginLL         = 2;
    const MAX_OFFSET       = 120;

    let gInfo = { visible:false };
    let cInfo = { visible:false };

    if (gHasAnchor && cHasAnchor) {
      const {hx: hxG, hy: hyG} = getHalfSize(gravityTiltLabel);
      const {hx: hxC, hy: hyC} = getHalfSize(cameraTiltLabel);

      let dx = gCenterProj.ax - cCenterProj.ax;
      let dy = gCenterProj.ay - cCenterProj.ay;
      let distCG = Math.sqrt(dx*dx + dy*dy);

      // Separation direction between the two label anchors (in screen space).
      // When the two crosses coincide (distCG→0), the direction becomes undefined.
      // A hard fallback can cause a *visible snap* exactly at alignment (notably while
      // attaching the camera). Keep the last stable direction so placement stays
      // continuous, and smoothly bias toward the final "docked" side as the crosses merge.
      let nx, ny;
      if (distCG >= 1e-3) {
        nx = dx/distCG;
        ny = dy/distCG;

        // Remember the last stable direction so we don't jump when distCG becomes ~0.
        labelSepDirState.has = true;
        labelSepDirState.x = nx;
        labelSepDirState.y = ny;
      } else {
        if (labelSepDirState && labelSepDirState.has) {
          nx = labelSepDirState.x;
          ny = labelSepDirState.y;
        } else {
          // Initial fallback: point away from screen center, or right if we're at the center.
          const width  = canvas.clientWidth || window.innerWidth;
          const height = canvas.clientHeight || window.innerHeight;
          const midX = (gCenterProj.ax + cCenterProj.ax) * 0.5;
          const midY = (gCenterProj.ay + cCenterProj.ay) * 0.5;
          let vx = midX - width*0.5;
          let vy = midY - height*0.5;
          let len = Math.sqrt(vx*vx + vy*vy);
          if (len < 1e-3) { nx = 1; ny = 0; }
          else { nx = vx/len; ny = vy/len; }
          labelSepDirState.has = true;
          labelSepDirState.x = nx;
          labelSepDirState.y = ny;
        }
        distCG = 0;
      }

      // When the camera is attaching/attached and the crosses are merging, smoothly bias the
      // separation direction toward the "docked" right-hand side so the gravity label glides
      // into its final anchored place (instead of snapping at perfect alignment).
      const dockW = (cameraAttachedToGravity ? mergeFactor : 0.0);
      if (dockW > 0.0001) {
        const bx = nx * (1.0 - dockW) + 1.0 * dockW;
        const by = ny * (1.0 - dockW) + 0.0 * dockW;
        const bl = Math.sqrt(bx*bx + by*by);
        if (bl > 1e-4) { nx = bx/bl; ny = by/bl; }
      }

      const axX = Math.abs(nx);
      const axY = Math.abs(ny);
      const EPS = 1e-4;

      const dCx = -nx, dCy = -ny;
      const dGx =  nx, dGy =  ny;

      function selfOffset(hx, hy) {
        const Lx = hx + marginSelf;
        const Ly = hy + marginSelf;
        const candidates = [];
        if (axX > EPS) candidates.push(Lx/axX);
        if (axY > EPS) candidates.push(Ly/axY);
        if (!candidates.length) return Math.max(Lx,Ly);
        let t = Math.min.apply(null, candidates);
        if (!Number.isFinite(t) || t < 0) t = 0;
        return t;
      }
      function otherCrossOffset(hx, hy) {
        if (distCG < 1e-3) return 0;
        const Lx = hx + marginOtherCross;
        const Ly = hy + marginOtherCross;
        const candidates = [];
        if (axX > EPS) candidates.push(Lx/axX);
        if (axY > EPS) candidates.push(Ly/axY);
        if (!candidates.length) return 0;
        let neededLen = Math.min.apply(null, candidates);
        if (!Number.isFinite(neededLen)) return 0;
        const off = neededLen - distCG;
        return off > 0 ? off : 0;
      }

      const baseSelfC  = selfOffset(hxC, hyC);
      const baseSelfG  = selfOffset(hxG, hyG);
      const baseOtherC = otherCrossOffset(hxC, hyC);
      const baseOtherG = otherCrossOffset(hxG, hyG);

      const screenC = computeScreenInterval(
        cCenterProj.ax, cCenterProj.ay,
        dCx, dCy,
        hxC, hyC,
        MAX_OFFSET
      );
      const screenG = computeScreenInterval(
        gCenterProj.ax, gCenterProj.ay,
        dGx, dGy,
        hxG, hyG,
        MAX_OFFSET
      );

      let sC_lower = Math.max(0, baseSelfC, baseOtherC);
      let sG_lower = Math.max(0, baseSelfG, baseOtherG);
      let sC_upper = MAX_OFFSET;
      let sG_upper = MAX_OFFSET;

      if (screenC.valid) {
        sC_lower = Math.max(sC_lower, screenC.sMin);
        sC_upper = Math.min(sC_upper, screenC.sMax);
      }
      if (screenG.valid) {
        sG_lower = Math.max(sG_lower, screenG.sMin);
        sG_upper = Math.min(sG_upper, screenG.sMax);
      }
      if (sC_upper < sC_lower) { const mid=Math.max(0,Math.min(MAX_OFFSET,sC_lower)); sC_lower=sC_upper=mid; }
      if (sG_upper < sG_lower) { const mid=Math.max(0,Math.min(MAX_OFFSET,sG_lower)); sG_lower=sG_upper=mid; }

      const Hx = hxC + hxG + marginLL;
      const Hy = hyC + hyG + marginLL;
      let Lneeded = 0;
      const llCandidates = [];
      if (axX > EPS) llCandidates.push(Hx/axX);
      if (axY > EPS) llCandidates.push(Hy/axY);
      if (llCandidates.length) {
        Lneeded = Math.min.apply(null, llCandidates);
        if (!Number.isFinite(Lneeded) || Lneeded < 0) Lneeded = 0;
      }

      let S_min = Lneeded - distCG;
      if (S_min < 0) S_min = 0;

      let sC = sC_lower;
      let sG = sG_lower;

      const baseSum = sC_lower + sG_lower;
      if (baseSum < S_min) {
        const neededExtra = S_min - baseSum;
        let remC = Math.max(0, sC_upper - sC_lower);
        let remG = Math.max(0, sG_upper - sG_lower);
        let totalRem = remC + remG;
        if (totalRem > 0) {
          let addC = neededExtra * (remC / totalRem);
          let addG = neededExtra * (remG / totalRem);
          if (addC > remC) addC = remC;
          if (addG > remG) addG = remG;
          sC = sC_lower + addC;
          sG = sG_lower + addG;
        }
      }

      sC = Math.max(sC_lower, Math.min(sC, sC_upper));
      sG = Math.max(sG_lower, Math.min(sG, sG_upper));

      let camX  = cCenterProj.ax + dCx * sC;
      let camY  = cCenterProj.ay + dCy * sC;
      let gravX = gCenterProj.ax + dGx * sG;
      let gravY = gCenterProj.ay + dGy * sG;

      const cClamp = clampLabelWithinScreen(camX, camY, hxC, hyC);
      const gClamp = clampLabelWithinScreen(gravX, gravY, hxG, hyG);
      camX  = cClamp.x; camY  = cClamp.y;
      gravX = gClamp.x; gravY = gClamp.y;

      const gravAlpha = 0.35 + 0.65 * gCenterProj.alpha;
      const camAlpha  = (cCenterProj.onScreen ? cCenterProj.alpha : 0.0);

      gInfo = { visible:true, x:gravX, y:gravY, alpha:gravAlpha };
      cInfo = { visible:camAlpha>0.001, x:camX, y:camY, alpha:camAlpha };

    } else if (gHasAnchor && !cHasAnchor) {
      const {hx: hxG, hy: hyG} = getHalfSize(gravityTiltLabel);
      const width  = canvas.clientWidth || window.innerWidth;
      const height = canvas.clientHeight || window.innerHeight;
      const centerX = width*0.5;
      const centerY = height*0.5;
      let vx = gCenterProj.ax - centerX;
      let vy = gCenterProj.ay - centerY;
      let len = Math.sqrt(vx*vx + vy*vy);
      if (len < 1e-3) { vx=0; vy=-1; len=1; }
      const nx = vx/len;
      const ny = vy/len;

      const axX = Math.abs(nx);
      const axY = Math.abs(ny);
      const EPS2= 1e-4;

      const Lx = hxG + marginSelf;
      const Ly = hyG + marginSelf;
      const selfCandidates = [];
      if (axX > EPS2) selfCandidates.push(Lx/axX);
      if (axY > EPS2) selfCandidates.push(Ly/axY);
      let baseSelfG = selfCandidates.length ? Math.min.apply(null,selfCandidates) : Math.max(Lx,Ly);
      if (!Number.isFinite(baseSelfG) || baseSelfG < 0) baseSelfG = 0;

      const screenG = computeScreenInterval(
        gCenterProj.ax, gCenterProj.ay,
        nx, ny,
        hxG, hyG,
        MAX_OFFSET
      );

      let sG_lower = Math.max(0, baseSelfG);
      let sG_upper = MAX_OFFSET;
      if (screenG.valid) {
        sG_lower = Math.max(sG_lower, screenG.sMin);
        sG_upper = Math.min(sG_upper, screenG.sMax);
      }
      if (sG_upper < sG_lower) {
        const mid=Math.max(0,Math.min(MAX_OFFSET,sG_lower));
        sG_lower=sG_upper=mid;
      }

      let sG = sG_lower;
      let gravX = gCenterProj.ax + nx*sG;
      let gravY = gCenterProj.ay + ny*sG;

      const gClamp = clampLabelWithinScreen(gravX, gravY, hxG, hyG);
      gravX = gClamp.x;
      gravY = gClamp.y;

      const gravAlpha = 0.35 + 0.65 * gCenterProj.alpha;
      gInfo = { visible:true, x:gravX, y:gravY, alpha:gravAlpha };
      cInfo = { visible:false };

    } else if (cHasAnchor && !gHasAnchor) {
      const {hx: hxC, hy: hyC} = getHalfSize(cameraTiltLabel);

      const width  = canvas.clientWidth || window.innerWidth;
      const height = canvas.clientHeight || window.innerHeight;
      const centerX = width*0.5;
      const centerY = height*0.5;
      let vx = cCenterProj.ax - centerX;
      let vy = cCenterProj.ay - centerY;
      let len = Math.sqrt(vx*vx + vy*vy);
      if (len < 1e-3) { vx=0; vy=-1; len=1; }
      const nx = vx/len;
      const ny = vy/len;

      const axX = Math.abs(nx);
      const axY = Math.abs(ny);
      const EPS2= 1e-4;

      const Lx = hxC + marginSelf;
      const Ly = hyC + marginSelf;
      const selfCandidates = [];
      if (axX > EPS2) selfCandidates.push(Lx/axX);
      if (axY > EPS2) selfCandidates.push(Ly/axY);
      let baseSelfC = selfCandidates.length ? Math.min.apply(null,selfCandidates) : Math.max(Lx,Ly);
      if (!Number.isFinite(baseSelfC) || baseSelfC < 0) baseSelfC = 0;

      const screenC = computeScreenInterval(
        cCenterProj.ax, cCenterProj.ay,
        nx, ny,
        hxC, hyC,
        MAX_OFFSET
      );

      let sC_lower = Math.max(0, baseSelfC);
      let sC_upper = MAX_OFFSET;
      if (screenC.valid) {
        sC_lower = Math.max(sC_lower, screenC.sMin);
        sC_upper = Math.min(sC_upper, screenC.sMax);
      }
      if (sC_upper < sC_lower) {
        const mid=Math.max(0,Math.min(MAX_OFFSET,sC_lower));
        sC_lower=sC_upper=mid;
      }

      let sC = sC_lower;
      let camX = cCenterProj.ax + nx*sC;
      let camY = cCenterProj.ay + ny*sC;

      const cClamp = clampLabelWithinScreen(camX, camY, hxC, hyC);
      camX = cClamp.x;
      camY = cClamp.y;

      const camAlpha = (cCenterProj.onScreen ? cCenterProj.alpha : 0.0);
      cInfo = { visible:camAlpha>0.001, x:camX, y:camY, alpha:camAlpha };
      gInfo = { visible:false };
    }

    if (gravityTiltLabel) {
      if (gInfo.visible) {
        const gPos = tweenLabelPos('grav', gInfo.x, gInfo.y);
        gravityTiltLabel.style.left      = (offX + gPos.x) + 'px';
        gravityTiltLabel.style.top       = (offY + gPos.y) + 'px';
        gravityTiltLabel.style.transform = 'translate(-50%, -50%)';
        gravityTiltLabel.style.opacity   = gInfo.alpha.toFixed(3);
      } else {
        gravityTiltLabel.style.opacity = '0';
      }
    }

    if (cameraTiltLabel) {
      let visible = cInfo.visible;
      let extraTransform = '';
      if (mergeFactor > 0 && cInfo.visible) {
        const scale = 1 - 0.25 * mergeFactor;
        cInfo.alpha *= (1 - mergeFactor);
        extraTransform = ` scale(${scale.toFixed(3)})`;
        visible = cInfo.alpha > 0.01;
      }
      if (alignedCrosses) visible = false;

      if (visible) {
        const cPos = tweenLabelPos('cam', cInfo.x, cInfo.y);
        cameraTiltLabel.style.left      = (offX + cPos.x) + 'px';
        cameraTiltLabel.style.top       = (offY + cPos.y) + 'px';
        cameraTiltLabel.style.transform = 'translate(-50%, -50%)' + extraTransform;
        cameraTiltLabel.style.opacity   = cInfo.alpha.toFixed(3);
      } else {
        cameraTiltLabel.style.opacity = '0';
      }
    }

  }
  // ======================== Band resize handles (drag edges / corners)
  // A separate overlay layer so the handles stay visible above the WebGL canvas.
  const handleEls = new Map();     // key -> element
  const handleDescs = new Map();   // key -> descriptor (used during pointer events)
  let lastViewState = null;

  // Active drag state
  let activeHandle = null;

  const HANDLE_BACKFACE_DOT = 0.02; // hide when behind sphere (dot <= this)

  function unwrapNear(deg, refDeg) {
    let a = deg;
    while (a - refDeg > 180) a -= 360;
    while (a - refDeg < -180) a += 360;
    return a;
  }

  function angleAdd(baseDeg, deltaDeg) {
    return wrap180(baseDeg + deltaDeg);
  }

  function dirToPitchRollDeg(dir) {
    const pitch = radToDeg(Math.asin(clamp(dir[1], -1, 1)));
    const roll  = radToDeg(Math.atan2(dir[0], dir[2]));
    return { pitch, roll };
  }

  function dirFromTangentOffset(centerDir, axisX, axisY, dxDeg, dyDeg) {
    const dx = degToRad(dxDeg);
    const dy = degToRad(dyDeg);
    const v = add3(scale3(axisX, dx), scale3(axisY, dy));
    const L = length3(v);
    if (L < 1e-8) return centerDir.slice();
    const vHat = scale3(v, 1 / L);
    const c = Math.cos(L);
    const s = Math.sin(L);
    return normalize3(add3(scale3(centerDir, c), scale3(vHat, s)));
  }

  function dirToLocalXYDeg(dir, centerDir, axisX, axisY) {
    const z = clamp(dot3(dir, centerDir), -1, 1);
    const radiusDeg = radToDeg(Math.acos(z));
    const xComp = dot3(dir, axisX);
    const yComp = dot3(dir, axisY);
    const theta = Math.atan2(yComp, xComp);
    const xDeg = radiusDeg * Math.cos(theta);
    const yDeg = radiusDeg * Math.sin(theta);
    return { radiusDeg, theta, xDeg, yDeg };
  }

  function projectDirToScreen(dir) {
    if (!lastViewState) return null;
    const { eye, right, up, halfWidth, halfHeight, rect } = lastViewState;

    const toPoint = [dir[0] - eye[0], dir[1] - eye[1], dir[2] - eye[2]];
    const planeX = dot3(toPoint, right);
    const planeY = dot3(toPoint, up);

    const ndcX = planeX / halfWidth;
    const ndcY = planeY / halfHeight;

    const x = rect.left + (ndcX * 0.5 + 0.5) * rect.width;
    const y = rect.top + (1 - (ndcY * 0.5 + 0.5)) * rect.height;

    return { x, y, ndcX, ndcY };
  }

  function screenToSphereDir(clientX, clientY) {
    if (!lastViewState) return null;
    const { eye, right, up, forward, halfWidth, halfHeight, rect } = lastViewState;

    const nx = ((clientX - rect.left) / rect.width) * 2 - 1;
    const ny = (1 - (clientY - rect.top) / rect.height) * 2 - 1;

    const planeX = nx * halfWidth;
    const planeY = ny * halfHeight;

    const ro = add3(add3(eye, scale3(right, planeX)), scale3(up, planeY));
    const rd = forward;

    const b = dot3(ro, rd);
    const c = dot3(ro, ro) - 1.0;
    const disc = b * b - c;
    if (disc < 0) return null;

    const t = -b - Math.sqrt(disc);
    if (t < 0) return null;

    const hit = add3(ro, scale3(rd, t));
    return normalize3(hit);
  }

  // --- Tap-to-select band on the sphere ------------------------------------
  // A quick "pick" that lets you tap a colored band region on the sphere to make
  // that band the active/editable one (so its handles appear).
  //
  // If multiple bands overlap at the tapped point, repeated taps cycle through
  // the candidates at that spot.
  let pendingTapSelectTimer = null;   // delayed to avoid interfering with double-tap
  let lastSpherePickInfo = null;      // { key, qx, qy, index, time }
  let lastTapBandPick = null;         // { time, prevIndex, newIndex, x, y }

  function cancelPendingTapBandPick() {
    if (pendingTapSelectTimer) {
      clearTimeout(pendingTapSelectTimer);
      pendingTapSelectTimer = null;
    }
  }

  function pickBandAtScreen(clientX, clientY) {
    if (!Array.isArray(bands) || bands.length === 0) return null;

    const dir = screenToSphereDir(clientX, clientY);
    if (!dir) return null; // tapped outside the sphere

    const pr = dirToPitchRollDeg(dir);
    const pitchDeg = pr.pitch;
    const rollDeg  = pr.roll;

    const candidates = [];
    for (let i = 0; i < bands.length; i++) {
      const b = bands[i];
      if (!b || b.enabled === false) continue;
      const s = getBandSettingsForBand(b);
      if (isInBand(s, pitchDeg, rollDeg)) candidates.push(i);
    }
    if (candidates.length === 0) return null;

    // Prefer "topmost" (latest) by default for overlaps.
    candidates.sort((a, b) => b - a);

    let chosen = candidates[0];
    let cycled = false;

    if (candidates.length > 1) {
      const key = candidates.join(',');
      const qx = Math.round(clientX / 18);
      const qy = Math.round(clientY / 18);
      const now = performance.now();


      if (lastSpherePickInfo &&
          lastSpherePickInfo.key === key &&
          lastSpherePickInfo.qx === qx &&
          lastSpherePickInfo.qy === qy &&
          (now - lastSpherePickInfo.time) < 1800) {
        const pos = candidates.indexOf(lastSpherePickInfo.index);
        chosen = candidates[(pos + 1) % candidates.length];
        cycled = true;
      }

      lastSpherePickInfo = { key, qx, qy, index: chosen, time: now };
    } else {
      lastSpherePickInfo = {
        key: String(chosen),
        qx: Math.round(clientX / 18),
        qy: Math.round(clientY / 18),
        index: chosen,
        time: performance.now()
      };
    }

    return { index: chosen, candidates, pitchDeg, rollDeg, dir, cycled };
  }


  function scheduleTapSelectBand(clientX, clientY) {
    // Immediate selection for snappy cycling through overlapping bands.
    const hit = pickBandAtScreen(clientX, clientY);
    if (!hit) return;

    const prev = activeBandIndex;
    selectBand(hit.index);
    const next = activeBandIndex;

    lastTapBandPick = {
      time: performance.now(),
      prevIndex: prev,
      newIndex: next,
      x: clientX,
      y: clientY
    };

    const label = bandDisplayName(hit.index);
    if (hit.candidates && hit.candidates.length > 1) {
      const list = hit.candidates.map(i => bandDisplayName(i)).join(', ');
      setStatus(`Selected ${label} (tap again to cycle: ${list})`);
    } else {
      setStatus(`Selected ${label}`);
    }
  }

  function ensureHandleEl(key, classes) {
    let el = handleEls.get(key);
    if (!el) {
      el = document.createElement('div');
      el.className = 'band-handle ' + classes;
      el.dataset.key = key;

      el.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        e.stopPropagation();

        const desc = handleDescs.get(key);
        if (!desc) return;

        // Snapshot state for this drag
        const band = getBandSettings();
        const tOuter = desc.tOuter;

        activeHandle = {
          key,
          pointerId: e.pointerId,
          desc,
          tOuter,
          startBand: band,
          startHandles: (handlesByMode[band.modeStr] || []).slice(),
          startCenterPitch: parseFloat(centerPitchInput.value),
          startCenterRoll:  parseFloat(centerRollInput.value),
          startBandCenterDir: bandCenterDir.slice(),
          startBandFrameX: bandFrameX.slice(),
          startBandFrameY: bandFrameY.slice(),
          startRotationDeg: parseFloat(bandRotationInput.value) || 0,
          startRectScalePitch: rectScalePitch,
          startRectScaleRoll:  rectScaleRoll,
          startEllipseScaleX:  ellipseScaleX,
          startEllipseScaleY:  ellipseScaleY,
          startPolyVerts: new Float32Array(polyVerts),
          startPolyPlanes: new Float32Array(polyPlanes),
          startPolyVertsInner: new Float32Array(polyVertsInner),
          startPolyPlanesInner: new Float32Array(polyPlanesInner)
        };

        el.setPointerCapture(e.pointerId);
      });

      el.addEventListener('pointermove', (e) => {
        if (!activeHandle || activeHandle.key !== key) return;
        if (e.pointerId !== activeHandle.pointerId) return;

        const dir = screenToSphereDir(e.clientX, e.clientY);
        if (!dir) return;

        applyHandleDrag(activeHandle, dir);

        // Keep UI + visuals in sync while dragging
        updateUI();
      });

      el.addEventListener('pointerup', (e) => {
        if (!activeHandle || activeHandle.key !== key) return;
        if (e.pointerId !== activeHandle.pointerId) return;

        el.releasePointerCapture(e.pointerId);
        activeHandle = null;
        saveSettings();
      });

      el.addEventListener('pointercancel', () => {
        activeHandle = null;
      });

      handlesLayer.appendChild(el);
      handleEls.set(key, el);
    }
    return el;
  }

  function removeUnusedHandles(keepKeys) {
    for (const [key, el] of handleEls.entries()) {
      if (!keepKeys.has(key)) {
        el.remove();
        handleEls.delete(key);
        handleDescs.delete(key);
      }
    }
  }

  function computeOuterT(band) {
    let t = 0;
    for (const r of band.ranges) {
      t = Math.max(t, Math.abs(r.min), Math.abs(r.max));
    }
    return Math.max(1e-6, t);
  }

  // Inner boundary scale for polygon/circle "rings".
  // We use the smallest positive boundary across all ranges.
  function computeInnerT(band) {
    let t = Infinity;
    for (const r of band.ranges) {
      const a = Math.abs(r.min);
      const b = Math.abs(r.max);
      const m = Math.min(a, b);
      if (m > 1e-6) t = Math.min(t, m);
    }
    return Number.isFinite(t) ? t : 0;
  }

  function computePolygonVertices2D(n, rotationRad, distDegs) {
    const verts = [];
    const sector = (Math.PI * 2) / n;
    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;

      const phi1 = rotationRad + i * sector;
      const phi2 = rotationRad + j * sector;

      const c1 = Math.cos(phi1), s1 = Math.sin(phi1);
      const c2 = Math.cos(phi2), s2 = Math.sin(phi2);

      const d1 = distDegs[i];
      const d2 = distDegs[j];

      const det = c1 * s2 - s1 * c2;
      if (Math.abs(det) < 1e-8) continue;

      const x = (d1 * s2 - s1 * d2) / det;
      const y = (c1 * d2 - d1 * c2) / det;

      verts.push({ x, y });
    }
    return verts;
  }

  function polygonCentroid2D(verts) {
    const m = verts.length;
    if (m < 3) return { x: 0, y: 0, area: 0 };

    let A2 = 0;
    let Cx6A = 0;
    let Cy6A = 0;

    for (let i = 0; i < m; i++) {
      const j = (i + 1) % m;
      const xi = verts[i].x, yi = verts[i].y;
      const xj = verts[j].x, yj = verts[j].y;
      const cross = xi * yj - xj * yi;
      A2 += cross;
      Cx6A += (xi + xj) * cross;
      Cy6A += (yi + yj) * cross;
    }

    if (Math.abs(A2) < 1e-8) return { x: 0, y: 0, area: 0 };
    const inv6A = 1 / (3 * A2); // since 6A = 3*A2
    return { x: Cx6A * inv6A, y: Cy6A * inv6A, area: A2 * 0.5 };
  }

  function setCenterFromDir(dir) {
    bandCenterDir = normalize3(dir);
    const { pitch, roll } = dirToPitchRollDeg(bandCenterDir);
    centerPitchInput.value = pitch.toFixed(2);
    centerRollInput.value  = roll.toFixed(2);
    updateBandFrameFromDir(bandCenterDir);
  }

  function applyHandleDrag(state, dir) {
    const desc = state.desc;
    const mode = desc.mode;
    const tOuter = state.tOuter;

    if (mode === 'pitch') {
      // Move a pitch boundary
      const { pitch } = dirToPitchRollDeg(dir);
      const newHandles = state.startHandles.slice();
      newHandles[desc.handleIndex] = pitch;
      setHandles('pitch', newHandles, { save:false, update:false, render:false });
      updateBandSizeUIFromState();
      return;
    }

    if (mode === 'roll') {
      // Move a roll boundary
      const { roll } = dirToPitchRollDeg(dir);
      const newHandles = state.startHandles.slice();
      newHandles[desc.handleIndex] = roll;
      setHandles('roll', newHandles, { save:false, update:false, render:false });
      updateBandSizeUIFromState();
      return;
    }

    if (mode === 'pitchOrRoll' || mode === 'pitchAndRoll') {
      // Rect / cross: edges modify rectScalePitch/rectScaleRoll + shift center; corners scale the ranges.
      const { pitch, roll } = dirToPitchRollDeg(dir);

      if (desc.kind === 'edge') {
        if (desc.edge === 'top' || desc.edge === 'bottom') {
          const t = tOuter;
          const startC = state.startCenterPitch;
          const startS = state.startRectScalePitch;
          const topFixed    = startC + t * startS;
          const bottomFixed = startC - t * startS;

          if (desc.edge === 'top') {
            const topNew = pitch;
            const newCenter = 0.5 * (topNew + bottomFixed);
            const newHalf   = 0.5 * (topNew - bottomFixed);
            rectScalePitch = Math.max(1e-6, newHalf / t);
            centerPitchInput.value = clamp(newCenter, -89.999, 89.999).toFixed(2);
          } else {
            const bottomNew = pitch;
            const newCenter = 0.5 * (topFixed + bottomNew);
            const newHalf   = 0.5 * (topFixed - bottomNew);
            rectScalePitch = Math.max(1e-6, newHalf / t);
            centerPitchInput.value = clamp(newCenter, -89.999, 89.999).toFixed(2);
          }
        } else if (desc.edge === 'left' || desc.edge === 'right') {
          const t = tOuter;
          const C0 = state.startCenterRoll;
          const S0 = state.startRectScaleRoll;
          const half0 = t * S0;

          const leftFixedAbs  = angleAdd(C0, -half0);
          const rightFixedAbs = angleAdd(C0, +half0);

          const leftFixedU  = unwrapNear(leftFixedAbs, C0);
          const rightFixedU = unwrapNear(rightFixedAbs, C0);
          const rollU       = unwrapNear(roll, C0);

          if (desc.edge === 'right') {
            const newCenterU = 0.5 * (rollU + leftFixedU);
            const newHalf    = 0.5 * (rollU - leftFixedU);
            rectScaleRoll = Math.max(1e-6, newHalf / t);
            centerRollInput.value = wrap180(newCenterU).toFixed(2);
          } else {
            const newCenterU = 0.5 * (rightFixedU + rollU);
            const newHalf    = 0.5 * (rightFixedU - rollU);
            rectScaleRoll = Math.max(1e-6, newHalf / t);
            centerRollInput.value = wrap180(newCenterU).toFixed(2);
          }
        }

        // Update center direction + frame after pitch/roll update
        const cp = parseFloat(centerPitchInput.value);
        const cr = parseFloat(centerRollInput.value);
        setCenterFromDir(tiltToDir(cp, cr));
        return;
      }

      // corner: scale all ranges uniformly (preserve proportions)
      const cp0 = state.startCenterPitch;
      const cr0 = state.startCenterRoll;
      const pDiff = pitch - cp0;
      const rDiff = wrap180(roll - cr0);
      const metric = Math.max(Math.abs(pDiff) / Math.max(1e-6, state.startRectScalePitch),
                              Math.abs(rDiff) / Math.max(1e-6, state.startRectScaleRoll));
      const s = metric / tOuter;

      const newHandles = state.startHandles.map(v => v * s);
      setHandles(mode, newHandles, { save:false, update:false, render:false });
      updateBandSizeUIFromState();
      return;
    }

    if (mode === 'circle') {
      // Ellipse (circle mode): edges modify ellipseScaleX/Y + shift center; corners scale ranges.
      const t = tOuter;
      const rotRad = degToRad(state.startRotationDeg);
      const cosR = Math.cos(rotRad);
      const sinR = Math.sin(rotRad);

      const bx = state.startBandFrameX;
      const by = state.startBandFrameY;

      const axisX = normalize3(add3(scale3(bx, cosR), scale3(by, sinR)));
      const axisY = normalize3(add3(scale3(bx, -sinR), scale3(by, cosR)));

      const local = dirToLocalXYDeg(dir, state.startBandCenterDir, axisX, axisY);

      if (desc.kind === 'edge') {
        if (desc.edge === 'right' || desc.edge === 'left') {
          const half0 = t * state.startEllipseScaleX;
          const westFixed = -half0;
          const eastFixed = +half0;

          if (desc.edge === 'right') {
            const eastNew = local.xDeg;
            const cShift = 0.5 * (eastNew + westFixed);
            const newHalf = 0.5 * (eastNew - westFixed);
            ellipseScaleX = Math.max(1e-6, newHalf / t);
            const newCenterDir = dirFromTangentOffset(state.startBandCenterDir, axisX, axisY, cShift, 0);
            setCenterFromDir(newCenterDir);
          } else {
            const westNew = local.xDeg;
            const cShift = 0.5 * (eastFixed + westNew);
            const newHalf = 0.5 * (eastFixed - westNew);
            ellipseScaleX = Math.max(1e-6, newHalf / t);
            const newCenterDir = dirFromTangentOffset(state.startBandCenterDir, axisX, axisY, cShift, 0);
            setCenterFromDir(newCenterDir);
          }
        } else if (desc.edge === 'top' || desc.edge === 'bottom') {
          const half0 = t * state.startEllipseScaleY;
          const southFixed = -half0;
          const northFixed = +half0;

          if (desc.edge === 'top') {
            const northNew = local.yDeg;
            const cShift = 0.5 * (northNew + southFixed);
            const newHalf = 0.5 * (northNew - southFixed);
            ellipseScaleY = Math.max(1e-6, newHalf / t);
            const newCenterDir = dirFromTangentOffset(state.startBandCenterDir, axisX, axisY, 0, cShift);
            setCenterFromDir(newCenterDir);
          } else {
            const southNew = local.yDeg;
            const cShift = 0.5 * (northFixed + southNew);
            const newHalf = 0.5 * (northFixed - southNew);
            ellipseScaleY = Math.max(1e-6, newHalf / t);
            const newCenterDir = dirFromTangentOffset(state.startBandCenterDir, axisX, axisY, 0, cShift);
            setCenterFromDir(newCenterDir);
          }
        }
        return;
      }

      // corner: scale all ranges based on ellipse metric
      const sx = Math.max(1e-6, state.startEllipseScaleX);
      const sy = Math.max(1e-6, state.startEllipseScaleY);
      const metric = Math.sqrt((local.xDeg / sx) * (local.xDeg / sx) + (local.yDeg / sy) * (local.yDeg / sy));
      const s = metric / tOuter;

      const newHandles = state.startHandles.map(v => v * s);
      setHandles(mode, newHandles, { save:false, update:false, render:false });
      updateBandSizeUIFromState();
      return;
    }

    if (mode === 'polygon') {
      const band = state.startBand;
      const n = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(band.polySides || 6)));
      const outer = Math.max(1e-6, tOuter);

      const whichPoly = (desc.which === 'inner') ? 'inner' : 'outer';
      const startVerts = (whichPoly === 'inner') ? state.startPolyVertsInner : state.startPolyVerts;
      const startPlanes = (whichPoly === 'inner') ? state.startPolyPlanesInner : state.startPolyPlanes;

      const rotRad = degToRad(state.startRotationDeg);
      const cosR = Math.cos(rotRad);
      const sinR = Math.sin(rotRad);

      // Pointer location in the tangent plane at drag-start center.
      const local = dirToLocalXYDeg(
        dir,
        state.startBandCenterDir,
        state.startBandFrameX,
        state.startBandFrameY
      );

      // The polygon itself is rotated in-shader by uBandRotationRad.
      // Convert the pointer from the *rotated* plane back to the base (unrotated) polygon space.
      const xPlane = local.xDeg;
      const yPlane = local.yDeg;
      const xBase  = xPlane * cosR + yPlane * sinR;   // R(-rot) * (xPlane,yPlane)
      const yBase  = -xPlane * sinR + yPlane * cosR;

      // Start from drag-start polygon so we don't accumulate drift during pointermove.
      const verts = new Float32Array(startVerts);

      if (desc.kind === 'corner') {
        // Free vertex drag: move ONLY that corner.
        const k = desc.cornerIndex;
        if (k == null || k < 0 || k >= n) return;
        verts[k * 2]     = xBase / outer;
        verts[k * 2 + 1] = yBase / outer;
      } else if (desc.kind === 'edge') {
        // Edge drag: translate the edge parallel to itself (moves its two endpoints).
        const k = desc.edgeIndex;
        if (k == null || k < 0 || k >= n) return;

        const o = k * 3;
        const nx = startPlanes[o];
        const ny = startPlanes[o + 1];
        const d0 = Math.max(1e-6, startPlanes[o + 2]);

        const distOuter = xBase * nx + yBase * ny; // dot(p_outer, n)
        const dNew = Math.max(1e-6, distOuter / outer);
        const delta = dNew - d0;

        const k1 = (k + 1) % n;
        verts[k * 2]     += delta * nx;
        verts[k * 2 + 1] += delta * ny;
        verts[k1 * 2]     += delta * nx;
        verts[k1 * 2 + 1] += delta * ny;
      } else {
        return;
      }

      // Keep the polygon convex + CCW so the GPU half-plane representation stays valid.
      if (!polyIsConvexCCW2D(n, verts)) return;

      // Inner polygon edit: commit directly (do NOT recenter the band center).
      // This allows the hole boundary to be shaped independently without moving the
      // outer boundary.
      if (whichPoly === 'inner') {
        // Constrain the inner polygon to remain inside the outer boundary at the
        // outermost scale, so the ring stays well-formed.
        const outerScale = computeOuterT(band);
        if (!polyAllVertsInside(n, verts, outer, state.startPolyPlanes, outerScale)) return;

        // Normalize inner polygon so the slider values stay aligned with the actual boundary.
        // We keep stored verts at max-radius = 1 and push the scale into the range mins
        // (inner boundary degrees).
        let scale = 1;
        for (let i = 0; i < n; i++) {
          const r = Math.hypot(verts[i * 2], verts[i * 2 + 1]);
          if (r > scale) scale = r;
        }
        if (!Number.isFinite(scale) || scale < 1e-6) scale = 1;

        if (Math.abs(scale - 1) > 1e-6) {
          for (let i = 0; i < n; i++) {
            verts[i * 2]     /= scale;
            verts[i * 2 + 1] /= scale;
          }

          // Update slider mins to match the new inner boundary placement.
          const spec = getSliderSpec('polygon');
          const step = spec.step || 1;
          const hNew = (state.startHandles || []).slice();

          for (let i = 0; i + 1 < hNew.length; i += 2) {
            const lo0 = Number.isFinite(hNew[i]) ? hNew[i] : spec.min;
            const hi0 = Number.isFinite(hNew[i + 1]) ? hNew[i + 1] : spec.max;
            hNew[i] = clamp(snapToStep(lo0 * scale, step), spec.min, hi0 - step);
          }
          for (let i = 1; i < hNew.length; i += 2) {
            const hi0 = Number.isFinite(hNew[i]) ? hNew[i] : spec.max;
            hNew[i] = clamp(snapToStep(hi0, step), spec.min, spec.max);
          }

          // Push handle updates to the UI immediately (so the numbers match what you see).
          setHandles('polygon', hNew, { save: false, update: false, render: true });
        }

        for (let i = 0; i < n; i++) {
          polyVertsInner[i * 2]     = verts[i * 2];
          polyVertsInner[i * 2 + 1] = verts[i * 2 + 1];
        }
        for (let i = n; i < MAX_POLY_SIDES_JS; i++) {
          polyVertsInner[i * 2] = 0;
          polyVertsInner[i * 2 + 1] = 0;
        }

        rebuildPolyPlanes(n, polyVertsInner, polyPlanesInner);
        polyVertsInnerLoaded = true;
        return;
      }

      // --- Recentre to centroid (keeps the stored band center at the true COM) ----
      const cent = polyCentroid2D(n, verts);
      const cxN = Number.isFinite(cent.x) ? cent.x : 0;
      const cyN = Number.isFinite(cent.y) ? cent.y : 0;

      // Move the band center in the plane by centroid *at the outer scale*.
      const cScaledBaseX = cxN * outer;
      const cScaledBaseY = cyN * outer;
      const cPlane = rotate2D(cScaledBaseX, cScaledBaseY, rotRad);

      if (Math.abs(cPlane.x) > 1e-8 || Math.abs(cPlane.y) > 1e-8) {
        const newCenter = dirFromTangentOffset(
          state.startBandCenterDir,
          state.startBandFrameX,
          state.startBandFrameY,
          cPlane.x,
          cPlane.y
        );
        bandCenterDir = normalize3(newCenter);
      } else {
        bandCenterDir = normalize3(state.startBandCenterDir);
      }

      // Parallel transport the drag-start frame from the old center to the new center.
      const a = normalize3(state.startBandCenterDir);
      const b = bandCenterDir;
      const rotAB = rotationFromTo(a, b);

      let xAxis = rotateAroundAxis(state.startBandFrameX, rotAB.axis, rotAB.angle);
      xAxis = projectOntoTangent(xAxis, bandCenterDir);
      if (!xAxis) {
        xAxis =
          projectOntoTangent(state.startBandFrameX, bandCenterDir) ||
          projectOntoTangent(state.startBandFrameY, bandCenterDir);
      }
      if (!xAxis) {
        updateBandFrameFromDir();
      } else {
        bandFrameX = xAxis;
        bandFrameY = normalize3(cross3(bandCenterDir, bandFrameX));
      }

      // Update UI center fields (doesn't trigger change handlers).
      const pr = dirToPitchRollDeg(bandCenterDir);
      centerPitchInput.value = clamp(pr.pitch, -89.999, 89.999).toFixed(2);
      centerRollInput.value  = wrap180(pr.roll).toFixed(2);

      // Recentre polygon vertices around the centroid in base space.
      for (let i = 0; i < n; i++) {
        verts[i * 2]     -= cxN;
        verts[i * 2 + 1] -= cyN;
      }

      // Commit updated polygon + derived planes.
      // Normalize outer polygon so the slider values stay aligned with the actual boundary.
      // We keep stored verts at max-radius = 1 and push the scale into the range maxes
      // (outer boundary degrees).
      let scale = 1;
      for (let i = 0; i < n; i++) {
        const r = Math.hypot(verts[i * 2], verts[i * 2 + 1]);
        if (r > scale) scale = r;
      }
      if (!Number.isFinite(scale) || scale < 1e-6) scale = 1;

      if (Math.abs(scale - 1) > 1e-6) {
        for (let i = 0; i < n; i++) {
          verts[i * 2]     /= scale;
          verts[i * 2 + 1] /= scale;
        }

        // Update slider maxes to match the new outer boundary placement.
        const spec = getSliderSpec('polygon');
        const step = spec.step || 1;
        const hNew = (state.startHandles || []).slice();

        for (let i = 1; i < hNew.length; i += 2) {
          const lo0 = Number.isFinite(hNew[i - 1]) ? hNew[i - 1] : spec.min;
          const hi0 = Number.isFinite(hNew[i]) ? hNew[i] : spec.min;
          hNew[i] = clamp(snapToStep(hi0 * scale, step), lo0 + step, spec.max);
        }
        for (let i = 0; i + 1 < hNew.length; i += 2) {
          const lo0 = Number.isFinite(hNew[i]) ? hNew[i] : spec.min;
          const hi0 = Number.isFinite(hNew[i + 1]) ? hNew[i + 1] : spec.max;
          hNew[i] = clamp(snapToStep(lo0, step), spec.min, hi0 - step);
        }

        // Push handle updates to the UI immediately (so the numbers match what you see).
        setHandles('polygon', hNew, { save: false, update: false, render: true });
      }

      for (let i = 0; i < n; i++) {
        polyVerts[i * 2]     = verts[i * 2];
        polyVerts[i * 2 + 1] = verts[i * 2 + 1];
      }
      for (let i = n; i < MAX_POLY_SIDES_JS; i++) {
        polyVerts[i * 2] = 0;
        polyVerts[i * 2 + 1] = 0;
      }

      rebuildPolyPlanes(n);

      return;
    }
  }

  function updateBandHandles() {
    if (!handlesLayer) return;
    if (!lastViewState) return;

    const band = getBandSettings();
    const mode = band.modeStr;


    const keep = new Set();

    // Front-facing check helper
    const eyeDir = lastViewState.eyeDir;

    if (mode === 'pitch') {
      const rollFront = radToDeg(Math.atan2(eyeDir[0], eyeDir[2]));
      const handles = handlesByMode.pitch || [];
      for (let i = 0; i < handles.length; i++) {
        const pitch = handles[i];
        const dir = tiltToDir(pitch, rollFront);

        const key = `pitch-edge-${i}`;
        keep.add(key);
        handleDescs.set(key, { mode, kind:'edge', handleIndex: i, tOuter: 1 });
        const el = ensureHandleEl(key, 'edge');

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }
      removeUnusedHandles(keep);
      return;
    }

    if (mode === 'roll') {
      const pitchFront = radToDeg(Math.asin(clamp(eyeDir[1], -1, 1)));
      const handles = handlesByMode.roll || [];
      for (let i = 0; i < handles.length; i++) {
        const roll = handles[i];
        const dir = tiltToDir(pitchFront, roll);

        const key = `roll-edge-${i}`;
        keep.add(key);
        handleDescs.set(key, { mode, kind:'edge', handleIndex: i, tOuter: 1 });
        const el = ensureHandleEl(key, 'edge');

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }
      removeUnusedHandles(keep);
      return;
    }

    const tOuter = computeOuterT(band);

    if (mode === 'pitchOrRoll' || mode === 'pitchAndRoll') {
      const cP = band.centerPitch;
      const cR = band.centerRoll;
      const hP = tOuter * rectScalePitch;
      const hR = tOuter * rectScaleRoll;

      const pts = [
        { key:'rect-edge-top',    kind:'edge', edge:'top',    pitch:cP + hP, roll:cR },
        { key:'rect-edge-bottom', kind:'edge', edge:'bottom', pitch:cP - hP, roll:cR },
        { key:'rect-edge-left',   kind:'edge', edge:'left',   pitch:cP, roll:angleAdd(cR, -hR) },
        { key:'rect-edge-right',  kind:'edge', edge:'right',  pitch:cP, roll:angleAdd(cR, +hR) },

        { key:'rect-corner-tr', kind:'corner', pitch:cP + hP, roll:angleAdd(cR, +hR) },
        { key:'rect-corner-tl', kind:'corner', pitch:cP + hP, roll:angleAdd(cR, -hR) },
        { key:'rect-corner-br', kind:'corner', pitch:cP - hP, roll:angleAdd(cR, +hR) },
        { key:'rect-corner-bl', kind:'corner', pitch:cP - hP, roll:angleAdd(cR, -hR) }
      ];

      for (const pt of pts) {
        const dir = tiltToDir(pt.pitch, pt.roll);
        const key = `${mode}-${pt.key}`;

        keep.add(key);
        handleDescs.set(key, { mode, kind: pt.kind, edge: pt.edge, tOuter });

        const el = ensureHandleEl(key, pt.kind);

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }

      removeUnusedHandles(keep);
      return;
    }

    if (mode === 'circle') {
      const rotRad = degToRad(band.rotationDeg);
      const cosR = Math.cos(rotRad);
      const sinR = Math.sin(rotRad);

      const axisX = normalize3(add3(scale3(bandFrameX, cosR), scale3(bandFrameY, sinR)));
      const axisY = normalize3(add3(scale3(bandFrameX, -sinR), scale3(bandFrameY, cosR)));

      const sx = tOuter * ellipseScaleX;
      const sy = tOuter * ellipseScaleY;

      const invSqrt2 = 0.7071067811865476;

      const points = [
        // edges
        { key:'ell-edge-right',  kind:'edge', edge:'right',  dx:sx, dy:0 },
        { key:'ell-edge-left',   kind:'edge', edge:'left',   dx:-sx, dy:0 },
        { key:'ell-edge-top',    kind:'edge', edge:'top',    dx:0, dy:sy },
        { key:'ell-edge-bottom', kind:'edge', edge:'bottom', dx:0, dy:-sy },
        // corners (points on ellipse at 45°)
        { key:'ell-corner-tr', kind:'corner', dx:sx * invSqrt2, dy:sy * invSqrt2 },
        { key:'ell-corner-tl', kind:'corner', dx:-sx * invSqrt2, dy:sy * invSqrt2 },
        { key:'ell-corner-br', kind:'corner', dx:sx * invSqrt2, dy:-sy * invSqrt2 },
        { key:'ell-corner-bl', kind:'corner', dx:-sx * invSqrt2, dy:-sy * invSqrt2 }
      ];

      for (const pt of points) {
        const dir = dirFromTangentOffset(bandCenterDir, axisX, axisY, pt.dx, pt.dy);
        const key = `${mode}-${pt.key}`;

        keep.add(key);
        handleDescs.set(key, { mode, kind: pt.kind, edge: pt.edge, tOuter });

        const el = ensureHandleEl(key, pt.kind);

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }

      removeUnusedHandles(keep);
      return;
    }

    if (mode === 'polygon') {
      const n = Math.max(3, Math.min(MAX_POLY_SIDES_JS, Math.floor(band.polySides || 6)));
      const rotRad = degToRad(band.rotationDeg);
      const cosR = Math.cos(rotRad);
      const sinR = Math.sin(rotRad);

      // Inner boundary scale (hole). If there's no hole (min==0), skip inner handles.
      const tInner = computeInnerT(band);

      // --- INNER handles ----------------------------------------------------
      // Inner handles behave like the outer ones, but operate on a separate
      // polygon (polyVertsInner / polyPlanesInner) so the inner edge can be
      // edited independently.
      if (tInner > 1e-6 && tInner < tOuter - 1e-6) {
        // Edge handles (inner): midpoints between adjacent inner corners.
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          const x0 = polyVertsInner[i * 2];
          const y0 = polyVertsInner[i * 2 + 1];
          const x1 = polyVertsInner[j * 2];
          const y1 = polyVertsInner[j * 2 + 1];

          const mxBase = 0.5 * (x0 + x1) * tInner;
          const myBase = 0.5 * (y0 + y1) * tInner;

          const dx = mxBase * cosR - myBase * sinR;
          const dy = mxBase * sinR + myBase * cosR;

          const dir = dirFromTangentOffset(bandCenterDir, bandFrameX, bandFrameY, dx, dy);
          const key = `${mode}-poly-inner-edge-${i}`;

          keep.add(key);
          handleDescs.set(key, { mode, kind:'edge', edgeIndex: i, tOuter: tInner, which:'inner' });
          const el = ensureHandleEl(key, 'edge inner');

          const dp = dot3(dir, eyeDir);
          if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

          const p = projectDirToScreen(dir);
          if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

          el.style.display = 'block';
          el.style.left = `${p.x}px`;
          el.style.top  = `${p.y}px`;
        }

        // Corner handles (inner): actual inner polygon vertices.
        for (let i = 0; i < n; i++) {
          const vx = polyVertsInner[i * 2] * tInner;
          const vy = polyVertsInner[i * 2 + 1] * tInner;

          const dx = vx * cosR - vy * sinR;
          const dy = vx * sinR + vy * cosR;

          const dir = dirFromTangentOffset(bandCenterDir, bandFrameX, bandFrameY, dx, dy);
          const key = `${mode}-poly-inner-corner-${i}`;

          keep.add(key);
          handleDescs.set(key, { mode, kind:'corner', cornerIndex: i, tOuter: tInner, which:'inner' });
          const el = ensureHandleEl(key, 'corner inner');

          const dp = dot3(dir, eyeDir);
          if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

          const p = projectDirToScreen(dir);
          if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

          el.style.display = 'block';
          el.style.left = `${p.x}px`;
          el.style.top  = `${p.y}px`;
        }
      }

      // Edge handles: midpoint between the two adjacent corner vertices (stable for irregular polygons).
      // IMPORTANT: using the line's closest point to origin is unstable once vertices move independently;
      // the foot of the perpendicular can slide toward a vertex or even outside the segment.
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const x0 = polyVerts[i * 2];
        const y0 = polyVerts[i * 2 + 1];
        const x1 = polyVerts[j * 2];
        const y1 = polyVerts[j * 2 + 1];

        // Midpoint in *base* (unrotated) polygon space.
        const mxBase = 0.5 * (x0 + x1) * tOuter;
        const myBase = 0.5 * (y0 + y1) * tOuter;

        // Apply the band rotation so the handle matches the rendered polygon orientation.
        const dx = mxBase * cosR - myBase * sinR;
        const dy = mxBase * sinR + myBase * cosR;

        const dir = dirFromTangentOffset(bandCenterDir, bandFrameX, bandFrameY, dx, dy);
        const key = `${mode}-poly-edge-${i}`;

        keep.add(key);
        handleDescs.set(key, { mode, kind:'edge', edgeIndex: i, tOuter });
        const el = ensureHandleEl(key, 'edge');

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display = 'none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }

      // Corner handles: actual polygon vertices.
      for (let i = 0; i < n; i++) {
        const vx = polyVerts[i * 2] * tOuter;
        const vy = polyVerts[i * 2 + 1] * tOuter;

        const dx = vx * cosR - vy * sinR;
        const dy = vx * sinR + vy * cosR;

        const dir = dirFromTangentOffset(bandCenterDir, bandFrameX, bandFrameY, dx, dy);
        const key = `${mode}-poly-corner-${i}`;

        keep.add(key);
        handleDescs.set(key, { mode, kind:'corner', cornerIndex: i, tOuter });
        const el = ensureHandleEl(key, 'corner');

        const dp = dot3(dir, eyeDir);
        if (dp <= HANDLE_BACKFACE_DOT) { el.style.display='none'; continue; }

        const p = projectDirToScreen(dir);
        if (!p || Math.abs(p.ndcX) > 1.2 || Math.abs(p.ndcY) > 1.2) { el.style.display='none'; continue; }

        el.style.display = 'block';
        el.style.left = `${p.x}px`;
        el.style.top  = `${p.y}px`;
      }

      removeUnusedHandles(keep);
      return;
    }

    // default: no handles
    removeUnusedHandles(keep);
  }


  // === Inertial gravity =====================================================
  function stepInertialAngles(dt) {
    if (!haveSensorData || dt <= 0) return;
    const omega = INERTIA_NATURAL_FREQ;
    const zeta  = INERTIA_DAMPING;
    if (!inertialInitialized) {
      inertialPitchDeg = targetPitchDeg;
      inertialRollDeg  = targetRollDeg;
      inertialPitchVel = 0;
      inertialRollVel  = 0;
      inertialInitialized = true;
      return;
    }
    const pitchError = inertialPitchDeg - targetPitchDeg;
    const pitchAccel = -omega*omega*pitchError - 2*zeta*omega*inertialPitchVel;
    inertialPitchVel += pitchAccel * dt;
    inertialPitchDeg += inertialPitchVel * dt;

    const rollError = inertialRollDeg - targetRollDeg;
    const rollAccel = -omega*omega*rollError - 2*zeta*omega*inertialRollVel;
    inertialRollVel += rollAccel * dt;
    inertialRollDeg += inertialRollVel * dt;
  }

  // === Camera attach to gravity ============================================
  function attachCameraToGravity(dt) {
    const g = normalize3(gravityDir);
    const desiredForward = [-g[0], -g[1], -g[2]];

    const fy = desiredForward[1];
    const clampedFy = Math.max(-1, Math.min(1, fy));
    const desiredPitch = Math.asin(clampedFy);
    const cp = Math.cos(desiredPitch);

    let desiredYaw;
    if (Math.abs(cp) < 1e-5) desiredYaw = yaw;
    else desiredYaw = Math.atan2(desiredForward[0], desiredForward[2]);

    if (!attachTransitionActive) {
      yaw   = desiredYaw;
      pitch = desiredPitch;
    } else {
      if (ATTACH_TRANSITION_DURATION <= 0) {
        attachTransitionActive = false;
        yaw   = desiredYaw;
        pitch = desiredPitch;
      } else {
        attachTransitionTime += dt;
        let t = attachTransitionTime / ATTACH_TRANSITION_DURATION;
        if (t >= 1.0) { t = 1.0; attachTransitionActive = false; }
        const s = t*t*(3.0 - 2.0*t);
        yaw   = lerpAngle(attachFromYaw,   desiredYaw,   s);
        pitch = lerp(     attachFromPitch, desiredPitch, s);
      }
    }

    yawVel = 0;
    pitchVel = 0;
  }

  // === Touch input only =====================================================
  function touchDistance(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  
  function touchAngle(a, b) {
    const dx = a.clientX - b.clientX;
    const dy = a.clientY - b.clientY;
    return Math.atan2(dy, dx);
  }


  // Tap-to-select state (canvas): treated as a tap if the finger didn't move much.
  const TAP_SELECT_MAX_MOVE = 12; // px
  let tapSelectArmed = false;
  let tapSelectMoved = false;
  let tapSelectStartX = 0;
  let tapSelectStartY = 0;
  let tapSelectStartMs = 0;

function handleFirstUserInteraction() {
    if (userActivated) return;
    userActivated = true;
    initAudio();
    initSensors();
  }

  canvas.addEventListener('touchstart', (e) => {
    handleFirstUserInteraction();
    const now = performance.now();

    clearLongPress();
    twoLongPressArmed = false;
    clearTimeout(twoLongPressTimer);
    longPressFired = false;

    if (e.touches.length === 1) {
      const t = e.touches[0];
      const dx = t.clientX - lastTapX;
      const dy = t.clientY - lastTapY;
      const dtTap = now - lastTapTime;

      const maxMoveSq = DOUBLE_TAP_MAX_MOVE * DOUBLE_TAP_MAX_MOVE;
      const distSq = dx*dx + dy*dy;

      if (dtTap <= DOUBLE_TAP_MAX_DELAY && distSq <= maxMoveSq) {
        // If the first tap selected a band, undo that selection so double‑tap
        // remains a camera attach/detach gesture (no band-cycling side effect).
        if (lastTapBandPick && (now - lastTapBandPick.time) <= (DOUBLE_TAP_MAX_DELAY + 80)) {
          const ddx = t.clientX - lastTapBandPick.x;
          const ddy = t.clientY - lastTapBandPick.y;
          if (ddx*ddx + ddy*ddy <= DOUBLE_TAP_MAX_MOVE * DOUBLE_TAP_MAX_MOVE) {
            selectBand(lastTapBandPick.prevIndex);
          }
          lastTapBandPick = null;
        }

        lastTapTime = 0;
        isDragging = false;
        isPinching = false;
        lastDragTime = null;
        yawVel = pitchVel = 0;

        cameraAttachedToGravity = !cameraAttachedToGravity;
        startLabelPosTween('grav');
        startLabelPosTween('cam');
        if (cameraAttachedToGravity) {
          attachTransitionActive = true;
          attachTransitionTime = 0;
          attachFromYaw   = yaw;
          attachFromPitch = pitch;
          setStatus('Camera attaching to gravity… Pinch to zoom. Double‑tap to detach.');
        } else {
          attachTransitionActive = false;
          attachTransitionTime = 0;
          setStatus('Camera free. Drag to rotate. Pinch to zoom. Double‑tap to attach.');
        }
        return;
      }

      lastTapTime = now;
      lastTapX = t.clientX;
      lastTapY = t.clientY;

      // Arm a potential tap-to-select. We'll only select if the finger
      // doesn't move and it's not part of a double-tap.
      tapSelectArmed = true;
      tapSelectMoved = false;
      tapSelectStartX = t.clientX;
      tapSelectStartY = t.clientY;
      tapSelectStartMs = now;

      isDragging = true;
      isPinching = false;
      lastX = t.clientX;
      lastY = t.clientY;
      yawVel = pitchVel = 0;
      lastDragTime = now;


      // Arm long-press: hold without moving to set band center from camera
      longPressArmed = true;
      longPressStartX = t.clientX;
      longPressStartY = t.clientY;
      longPressTimer = setTimeout(() => {
        if (!longPressArmed) return;
        longPressArmed = false;
        longPressTimer = null;
        longPressFired = true;
        // Avoid rotating the view after a long-press action.
        isDragging = false;
        lastDragTime = null;
        yawVel = pitchVel = 0;
        applyCenterFromCamera({ announce:true });
      }, LONG_PRESS_MS);

    } else if (e.touches.length === 2) {
      isDragging = false;
      isPinching = true;

      lastPinchDist = touchDistance(e.touches[0], e.touches[1]);
      lastPinchAngle = touchAngle(e.touches[0], e.touches[1]);

      // Arm a two-finger long-press to "center to current tilt" (including yaw).
      twoLongPressArmed = true;
      twoLongPressStartDist = lastPinchDist;
      twoLongPressStartX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
      twoLongPressStartY = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;

      clearTimeout(twoLongPressTimer);
      twoLongPressTimer = setTimeout(() => {
        if (!twoLongPressArmed) return;
        applyCenterFromTiltInclYaw();
        twoLongPressArmed = false;
      }, LONG_PRESS_MS);

      yawVel = pitchVel = 0;
      lastDragTime = null;
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', (e) => {
    // Cancel long-press if the finger moves (or if this becomes a multi-touch gesture).
    if (longPressArmed) {
      if (e.touches.length !== 1) {
        clearLongPress();
      } else {
        const t0 = e.touches[0];
        const dx0 = t0.clientX - longPressStartX;
        const dy0 = t0.clientY - longPressStartY;
        if (dx0*dx0 + dy0*dy0 > LONG_PRESS_MAX_MOVE * LONG_PRESS_MAX_MOVE) {
          clearLongPress();
        }
      }
    }

    // If this started as a tap-to-select, mark it as moved once the finger drifts.
    if (tapSelectArmed) {
      if (e.touches.length !== 1) {
        tapSelectMoved = true;
      } else {
        const t0 = e.touches[0];
        const dx0 = t0.clientX - tapSelectStartX;
        const dy0 = t0.clientY - tapSelectStartY;
        if (dx0*dx0 + dy0*dy0 > TAP_SELECT_MAX_MOVE * TAP_SELECT_MAX_MOVE) {
          tapSelectMoved = true;
        }
      }
    }

    if (e.touches.length === 1 && isDragging && !cameraAttachedToGravity) {
      e.preventDefault();
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;

      const yawSign = Math.cos(pitch) >= 0 ? 1 : -1;
      const sensitivity = getRotationSensitivity();
      const yawDelta   =  dx * BASE_ROTATION_SPEED * sensitivity * yawSign;
      const pitchDelta = -dy * BASE_ROTATION_SPEED * sensitivity;

      yaw   += yawDelta;
      pitch += pitchDelta;

      const now = performance.now();
      if (lastDragTime != null) {
        let dt = (now - lastDragTime) * 0.001;
        if (dt > 0 && dt < 0.1) {
          yawVel   = yawDelta   / dt;
          pitchVel = pitchDelta / dt;
        }
      }
      lastDragTime = now;

    } else if (e.touches.length === 2) {
      e.preventDefault();

      const dist = touchDistance(e.touches[0], e.touches[1]);
      const ang  = touchAngle(e.touches[0], e.touches[1]);

      // Cancel the two-finger long-press if the user actually pinches/twists/moves.
      if (twoLongPressArmed) {
        const midX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
        const midMove = Math.hypot(midX - twoLongPressStartX, midY - twoLongPressStartY);
        const distMove = Math.abs(dist - twoLongPressStartDist);
        const angMove  = Math.abs(wrapPi(ang - lastPinchAngle));
        if (midMove > 10 || distMove > 10 || angMove > 0.15) {
          twoLongPressArmed = false;
          clearTimeout(twoLongPressTimer);
        }
      }

      if (isPinching) {
        const delta = dist - lastPinchDist;
        const dAng  = wrapPi(ang - lastPinchAngle);

        lastPinchDist = dist;
        lastPinchAngle = ang;

        // Pinch zoom
        const factor = Math.exp(-delta * 0.005);
        zoomScale *= factor;
        zoomScale = Math.max(MIN_ZOOM, Math.min(zoomScale, 2.0));

        // Twist = manual yaw for the camera crosshair
        // Clockwise twist should increase degrees (same convention as compass heading).
        camCrossYawDeg = wrap360(camCrossYawDeg - radToDeg(dAng));
        saveSettings();
      } else {
        isPinching = true;
        isDragging = false;
        lastPinchDist = dist;
        lastPinchAngle = ang;
      }

      yawVel = pitchVel = 0;
    }
  }, { passive:false });

  canvas.addEventListener('touchend', (e) => {
    const wasPinching = isPinching;
    clearLongPress();
    if (e.touches.length === 0) {
      isDragging = false;
      isPinching = false;
      lastDragTime = null;
    } else if (e.touches.length === 1) {
      isPinching = false;
      isDragging = false;
      lastDragTime = null;
      const t = e.touches[0];
      lastX = t.clientX;
      lastY = t.clientY;
    }
    if (wasPinching && e.touches.length < 2) {
      justEndedPinch = true;
      yawVel = pitchVel = 0;
    }

    // Single-tap (without moving) selects the band under the finger.
    if (!wasPinching && tapSelectArmed && !tapSelectMoved && !longPressFired && e.touches.length === 0) {
      const ct = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
      if (ct) scheduleTapSelectBand(ct.clientX, ct.clientY);
    }

    tapSelectArmed = false;
  });

  canvas.addEventListener('touchcancel', () => {
    clearLongPress();
    cancelPendingTapBandPick();
    tapSelectArmed = false;
    tapSelectMoved = false;
    isDragging = false;
    isPinching = false;
    lastDragTime = null;
    justEndedPinch = true;
    yawVel = pitchVel = 0;
  });

  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  // Start sensors/audio on the first user gesture anywhere (touch OR pointer).
  // Use capture so stopPropagation on UI elements can't block it.
  document.addEventListener('touchstart', handleFirstUserInteraction, { passive:true, capture:true });
  document.addEventListener('pointerdown', handleFirstUserInteraction, { passive:true, capture:true });
  document.addEventListener('mousedown', handleFirstUserInteraction, { passive:true, capture:true });
  window.addEventListener('orientationchange', () => {
    screenEl.textContent = getScreenOrientationDegrees() + '°';
  });

  // === Render loop ==========================================================
  let lastUiUpdateTime = 0;
  const UI_UPDATE_MS = 50;

  function render(timestamp) {
    requestAnimationFrame(render);

    let dt = 0;
    if (typeof timestamp === 'number') {
      if (lastFrameTime == null) dt = 0;
      else {
        dt = (timestamp - lastFrameTime) * 0.001;
        if (dt > 0.05) dt = 0.05;
      }
      lastFrameTime = timestamp;
    }

    stepInertialAngles(dt);
    updateGravityDirection();

    // --- Compass smoothing / hysteresis (prevents flicker) -------------------
    const nowMs = (typeof timestamp === 'number') ? timestamp : performance.now();
    const compassActive =
      compassInitialized && (nowMs - lastCompassMs) <= COMPASS_HOLD_MS;

    if (compassActive) {
      // Exponential smoothing on a circle (angle-aware).
      if (dt > 0 && COMPASS_SMOOTH_TAU > 0) {
        const t = 1 - Math.exp(-dt / COMPASS_SMOOTH_TAU);
        compassFilteredRad = lerpAngle(compassFilteredRad, compassTargetRad, t);
      } else {
        compassFilteredRad = compassTargetRad;
      }
      // Keep in a reasonable range to avoid numeric drift.
      while (compassFilteredRad > Math.PI)  compassFilteredRad -= Math.PI * 2;
      while (compassFilteredRad < -Math.PI) compassFilteredRad += Math.PI * 2;

      let hd = radToDeg(compassFilteredRad);
      hd = ((hd % 360) + 360) % 360;
      deviceYawDeg = hd;
    } else {
      deviceYawDeg = null;
    }

    if (cameraAttachedToGravity) attachCameraToGravity(dt);

    const atMaxZoom = zoomScale <= MIN_ZOOM * 1.0001;
    if (!cameraAttachedToGravity &&
        !atMaxZoom &&
        !isDragging &&
        !isPinching &&
        dt > 0 &&
        !justEndedPinch) {
      const friction = getCamFriction();
      const decay = Math.exp(-friction * dt);
      yawVel   *= decay;
      pitchVel *= decay;
      if (Math.abs(yawVel)   < 1e-4) yawVel   = 0;
      if (Math.abs(pitchVel) < 1e-4) pitchVel = 0;
      yaw   += yawVel * dt;
      pitch += pitchVel * dt;
    } else {
      if (atMaxZoom || justEndedPinch) { yawVel = pitchVel = 0; }
      justEndedPinch = false;
    }

    resizeCanvas();
    if (!canvas.width || !canvas.height) return;

    const width  = canvas.width;
    const height = canvas.height;
    const aspect = width / height;

    if (yaw >  Math.PI) yaw -= Math.PI * 2;
    else if (yaw < -Math.PI) yaw += Math.PI * 2;
    if (pitch >  Math.PI) pitch -= Math.PI * 2;
    else if (pitch < -Math.PI) pitch += Math.PI * 2;

    const cy = Math.cos(yaw);
    const sy = Math.sin(yaw);
    const cp = Math.cos(pitch);
    const sp = Math.sin(pitch);

    const forward = [sy*cp, sp, cy*cp];
    const right   = [cy, 0, -sy];
    const up      = [-sp*sy, cp, -sp*cy];
    const eye     = scale3(forward, -camDist);
    const worldUp = [0,1,0];

    // Keep the sphere's *absolute* on-screen size stable (in CSS pixels).
    //
    // Split layouts change the canvas CSS width/height. If we size the sphere from
    // the current canvas dimensions, the sphere appears to shrink/grow as the UI
    // opens/closes or swaps portrait/landscape.
    //
    // Instead, use a fixed reference radius captured from the *full viewport* and
    // compute uOrthoScale from the current scene rect so the sphere keeps the same
    // CSS-pixel radius. (We only shrink if the scene rect is too small to fit.)
    const baseRadiusCss = ensureSphereBaseRadiusCss(); // radius at zoomScale=1
    const z = Math.max(zoomScale, MIN_ZOOM);
    const desiredRadiusCss = baseRadiusCss / z;

    const sceneWcss = canvas.clientWidth  || 1;
    const sceneHcss = canvas.clientHeight || 1;
    const fitRadiusCss = 0.5 * Math.min(sceneWcss, sceneHcss) - 2.0;
    let radiusCss = desiredRadiusCss;
    // Keep the default sphere fully visible when zoomScale >= 1,
    // but allow zoom-in (zoomScale < 1) to exceed the fit and crop as needed.
    if (z >= 1.0) radiusCss = Math.min(radiusCss, fitRadiusCss);
    radiusCss = Math.max(1.0, radiusCss);

    const halfHeight = sceneHcss / (2.0 * radiusCss);
    const halfWidth  = halfHeight * aspect;

    lastForward   = forward.slice();
    const camCenter = [-forward[0], -forward[1], -forward[2]];
    lastCamCenter = camCenter.slice();

    gl.viewport(0,0,width,height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);

    gl.uniform3f(uEyeLoc, eye[0], eye[1], eye[2]);
    gl.uniform3f(uForwardLoc, forward[0], forward[1], forward[2]);
    gl.uniform3f(uRightLoc,   right[0], right[1], right[2]);
    gl.uniform3f(uUpLoc,      up[0], up[1], up[2]);
    gl.uniform1f(uOrthoScaleLoc, halfHeight);
    gl.uniform1f(uAspectLoc, aspect);

    const baseCrossWidth = 0.01;
    const crossWidth = baseCrossWidth * zoomScale;
    gl.uniform1f(uCrossWidthLoc, crossWidth);

    // --- Gravity + camera cross uniforms -----------------------------------
    const gCenter = normalize3(gravityDir);

    // TT_STABLE_TANGENT_FRAME_v1
    // Prevent snap-rotations when crossing poles/hemispheres by using a
    // rotation-minimizing (transported) tangent frame, then *gently* re-aligning
    // toward the world-up/heading frame away from poles.
    const prevGravityUp = lastGravityUp.slice();
    const prevCamUp     = lastCamUp.slice();

    const ttSmoothstep01 = (e0, e1, x) => {
      const t = clamp((x - e0) / (e1 - e0), 0, 1);
      return t * t * (3 - 2 * t);
    };

    const ttStabilizeUp = (center, prevUp, targetUp) => {
      // Start from transported previous up (project onto the new tangent plane).
      let up = projectOntoTangent(prevUp, center);

      // If projection degenerates (rare), fall back to targetUp or a deterministic axis.
      if (!up) up = targetUp;
      if (!up) {
        let fb = (Math.abs(center[2]) < 0.9) ? [0, 0, 1] : [1, 0, 0];
        up = projectOntoTangent(fb, center) || [0, 1, 0];
      }

      // Optionally pull toward targetUp (but avoid poles where target can get unstable).
      if (targetUp) {
        // Put target in the same hemisphere as current up (avoids 180° flips).
        if (dot3(targetUp, up) < 0) targetUp = [-targetUp[0], -targetUp[1], -targetUp[2]];

        // 0 near poles (projection length ~0), 1 away from poles.
        const d = clamp(dot3(worldUp, center), -1, 1);
        const projLen = Math.sqrt(Math.max(0, 1 - d * d));
        const align = ttSmoothstep01(0.08, 0.25, projLen);

        // Time-based smoothing so even a noisy target can't snap the frame.
        const dtSafe = (typeof dt === "number" && isFinite(dt) && dt > 0) ? dt : 0.016;
        const w = (1 - Math.exp(-12.0 * dtSafe)) * align;

        up = normalize3([
          up[0] * (1 - w) + targetUp[0] * w,
          up[1] * (1 - w) + targetUp[1] * w,
          up[2] * (1 - w) + targetUp[2] * w,
        ]);

        up = projectOntoTangent(up, center) || up;
      }

      // Final continuity check vs previous up (can still be needed after projection).
      if (dot3(up, prevUp) < 0) up = [-up[0], -up[1], -up[2]];
      return up;
    };

    // ---------------- Gravity cross (magenta) ----------------
    // Base tangent frame (world-up projected onto the tangent plane).
    let baseUp = projectOntoTangent(worldUp, gCenter);
    if (!baseUp) {
      baseUp = (Math.abs(gCenter[2]) < 0.9) ? [0, 0, 1] : [1, 0, 0];
      baseUp = projectOntoTangent(baseUp, gCenter) || [0, 0, 1];
    }
    let baseRight = normalize3(cross3(baseUp, gCenter));

    // Use compass heading to rotate the gravity cross around the gravity axis.
    let yawRad = 0;
    if (deviceYawDeg != null && !Number.isNaN(deviceYawDeg)) {
      yawRad = degToRad(deviceYawDeg);
      while (yawRad > Math.PI)  yawRad -= Math.PI * 2;
      while (yawRad < -Math.PI) yawRad += Math.PI * 2;
    }

    const cosA = Math.cos(yawRad);
    const sinA = Math.sin(yawRad);

    let gUpTarget = [
      baseUp[0] * cosA + baseRight[0] * sinA,
      baseUp[1] * cosA + baseRight[1] * sinA,
      baseUp[2] * cosA + baseRight[2] * sinA
    ];
    gUpTarget = projectOntoTangent(gUpTarget, gCenter) || baseUp;

    const gUp = ttStabilizeUp(gCenter, prevGravityUp, gUpTarget);
    const gRight = normalize3(cross3(gUp, gCenter));
    lastGravityUp = gUp.slice();

    gl.uniform3f(uGravityCenterLoc, gCenter[0], gCenter[1], gCenter[2]);
    gl.uniform3f(uGravityUpLoc,     gUp[0],     gUp[1],     gUp[2]);
    gl.uniform3f(uGravityRightLoc,  gRight[0],  gRight[1],  gRight[2]);

    // ---------------- View/Camera cross (cyan) ----------------
    const cCenter = normalize3(camCenter);

    let camBaseUp = projectOntoTangent(worldUp, cCenter);
    if (!camBaseUp) {
      camBaseUp = (Math.abs(cCenter[2]) < 0.9) ? [0, 0, 1] : [1, 0, 0];
      camBaseUp = projectOntoTangent(camBaseUp, cCenter) || [0, 0, 1];
    }
    let camBaseRight = normalize3(cross3(camBaseUp, cCenter));

    // User-controlled twist (camCrossYawDeg) + attach offset
    const camYawTotalDeg = wrap360(camCrossYawDeg + (cameraAttachedToGravity ? camAttachYawOffsetDeg : 0));
    const camYawTotalRad = degToRad(camYawTotalDeg);
    const cosCam = Math.cos(camYawTotalRad);
    const sinCam = Math.sin(camYawTotalRad);

    let camUpTarget = [
      camBaseUp[0] * cosCam + camBaseRight[0] * sinCam,
      camBaseUp[1] * cosCam + camBaseRight[1] * sinCam,
      camBaseUp[2] * cosCam + camBaseRight[2] * sinCam
    ];
    camUpTarget = projectOntoTangent(camUpTarget, cCenter) || camBaseUp;

    const camUp = ttStabilizeUp(cCenter, prevCamUp, camUpTarget);
    const camRight = normalize3(cross3(camUp, cCenter));
    lastCamUp = camUp.slice();

    gl.uniform3f(uCamCenterLoc, cCenter[0], cCenter[1], cCenter[2]);
    gl.uniform3f(uCamUpLoc,     camUp[0],   camUp[1],   camUp[2]);
    gl.uniform3f(uCamRightLoc,  camRight[0],camRight[1],camRight[2]);

    // Band passes (base + overlays)
    ensureBandsInitialized();
    commitActiveBandFromUI();

    const drawBands = [];
    for (let i = 0; i < bands.length; i++) {
      const b = bands[i];
      if (!b || b.enabled === false) continue;
      drawBands.push({
        index: i,
        color: (Array.isArray(b.color) && b.color.length === 3) ? b.color : BAND_COLOR_PALETTE[0],
        settings: getBandSettingsForBand(b),
      });
    }

    // Global In Range (union across enabled bands, computed in updateUI)
    gl.uniform1f(uGlobalInRangeLoc, globalInRange ? 1.0 : 0.0);
    if (uQualityLoc) gl.uniform1f(uQualityLoc, shaderQuality);

    // Scratch arrays for uploading ranges (re-used for every band this frame)
    const tmpMins = new Float32Array(MAX_RANGES);
    const tmpMaxs = new Float32Array(MAX_RANGES);

    function uploadBandUniforms(s) {
      // upload band & range parameters
      gl.uniform1f(uBandModeLoc, (s.modeIndex!=null ? s.modeIndex : 0));

      gl.uniform1f(uRectScalePitchLoc, (s.rectScalePitch != null ? s.rectScalePitch : 1));
      gl.uniform1f(uRectScaleRollLoc,  (s.rectScaleRoll  != null ? s.rectScaleRoll  : 1));
      gl.uniform1f(uEllipseScaleXLoc,  (s.ellipseScaleX  != null ? s.ellipseScaleX  : 1));
      gl.uniform1f(uEllipseScaleYLoc,  (s.ellipseScaleY  != null ? s.ellipseScaleY  : 1));

      const cd = s.centerDir || bandCenterDir;
      const fx = s.frameX   || bandFrameX;
      const fy = s.frameY   || bandFrameY;

      gl.uniform3f(uBandCenterDirLoc, cd[0], cd[1], cd[2]);
      gl.uniform3f(uBandFrameXLoc,    fx[0], fx[1], fx[2]);
      gl.uniform3f(uBandFrameYLoc,    fy[0], fy[1], fy[2]);

      gl.uniform1f(uBandRotationRadLoc, (s.rotationDeg || 0) * (Math.PI / 180));

      const ranges = s.ranges || [{ min: 0, max: 1 }];
      const count = Math.min(MAX_RANGES, ranges.length);

      for (let i = 0; i < MAX_RANGES; i++) { tmpMins[i] = 0; tmpMaxs[i] = 0; }
      for (let i = 0; i < count; i++) {
        tmpMins[i] = ranges[i].min;
        tmpMaxs[i] = ranges[i].max;
      }

      gl.uniform1i(uRangeCountLoc, count);
      gl.uniform1fv(uRangeMinsLoc, tmpMins);
      gl.uniform1fv(uRangeMaxsLoc, tmpMaxs);

      const polySides = Math.max(3, Math.min(MAX_POLY_SIDES_JS, (s.polySides | 0) || 3));
      gl.uniform1f(uBandPolySidesLoc, polySides);

      gl.uniform3fv(uPolyPlanesOuterLoc, s.polyPlanes || polyPlanes);
      gl.uniform3fv(uPolyPlanesInnerLoc, s.polyPlanesInner || polyPlanesInner);
      gl.uniform2fv(uPolyVertsOuterLoc, s.polyVerts || polyVerts);
      gl.uniform2fv(uPolyVertsInnerLoc, s.polyVertsInner || polyVertsInner);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.vertexAttribPointer(attribPosition, 2, gl.FLOAT, false, 0, 0);
    // --- Draw base pass (sphere + axes + crosses) -----------------------------
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.uniform1f(uPassLoc, 0.0);
    gl.uniform3f(uBandTintLoc, 0.16, 0.60, 1.0);

    // Keep uniforms sane (base pass ignores band output)
    uploadBandUniforms(getBandSettingsForBand(bands[activeBandIndex]));

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // --- Draw band overlays (additive, keep destination alpha) ----------------
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE);
    gl.uniform1f(uPassLoc, 1.0);

    for (const entry of drawBands) {
      const c = entry.color;
      gl.uniform3f(uBandTintLoc, c[0], c[1], c[2]);
      uploadBandUniforms(entry.settings);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }


    // Cache view state for handle picking/projection (CSS pixel space)
    lastViewState = {
      eye: eye.slice(),
      right: right.slice(),
      up: up.slice(),
      forward: forward.slice(),
      halfWidth,
      halfHeight,
      rect: canvas.getBoundingClientRect(),
      eyeDir: normalize3(eye)
    };
    // UI (DOM) updates can be surprisingly expensive on mobile. Throttle them.
    if (timestamp == null || (timestamp - lastUiUpdateMs) >= uiUpdateIntervalMs) {
      updateBandHandles();
      updateLabels(eye, right, up, forward, halfHeight, halfWidth, gCenter, camCenter);
      if (typeof timestamp === 'number') lastUiUpdateMs = timestamp;
    }

    if (timestamp == null || timestamp - lastUiUpdateTime >= UI_UPDATE_MS) {
      updateUI();
      lastUiUpdateTime = timestamp || 0;
    }
  }

  // === Init ================================================================
  const initPolySides = parseFloat(polySidesInput.value);
  resetPolyVerts(initPolySides, polyVerts, polyPlanes);
  resetPolyVerts(initPolySides, polyVertsInner, polyPlanesInner);
  loadSettings();
  updateSoundToggleUI();

  setMode(monitorSelect.value || 'pitch', { recenter: false, save: false });
  updateBandSizeUIFromState();
  updateBandRotationUIFromState();
  updateUI();
  setStatus('Tap anywhere to enable sensors and audio. Drag to rotate. Pinch to zoom. Double‑tap to lock/unlock View to Tilt. Long‑press to set band center to View.');
  requestAnimationFrame(render);
})();
</script>


<!-- TT_HELP_OVERLAY_v1 -->
<script>
(() => {
  'use strict';

  function ensureStyle() {
    if (document.getElementById("tthelp-style")) return;
    const style = document.createElement("style");
    style.id = "tthelp-style";
    style.textContent = `
      .tthelp-overlay{
        position:fixed; inset:0;
        background: rgba(0,0,0,0.55);
        display:flex; align-items:center; justify-content:center;
        padding: max(14px, env(safe-area-inset-top)) 14px max(14px, env(safe-area-inset-bottom)) 14px;
        z-index: 999999;
      }
      .tthelp-hidden{ display:none !important; }
      .tthelp-card{
        width: min(560px, 94vw);
        max-height: min(78vh, 560px);
        overflow:hidden;
        border-radius: 18px;
        background: rgba(18, 18, 22, 0.92);
        border: 1px solid rgba(255,255,255,0.10);
        box-shadow: 0 18px 60px rgba(0,0,0,0.55);
        display:flex; flex-direction:column;
      }
      .tthelp-head{
        display:flex; align-items:flex-start; justify-content:space-between;
        padding: 14px 14px 10px 14px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
        gap: 10px;
      }
      .tthelp-title{
        font: 900 14px/1.15 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: rgba(255,255,255,0.96);
        letter-spacing: 0.2px;
      }
      .tthelp-sub{
        margin-top: 6px;
        font: 600 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: rgba(255,255,255,0.70);
      }
      .tthelp-x{
        border: 0;
        background: rgba(255,255,255,0.10);
        color: rgba(255,255,255,0.92);
        border-radius: 12px;
        height: 34px; width: 44px;
        font: 900 16px/34px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      }
      .tthelp-body{
        padding: 12px 14px 14px 14px;
        overflow:auto;
      }
      .tthelp-body ul{ margin: 10px 0 0 18px; padding:0; }
      .tthelp-body li{
        font: 650 12.5px/1.42 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: rgba(255,255,255,0.82);
        margin: 8px 0;
      }
      .tthelp-callout{
        margin-top: 12px;
        padding: 10px 10px;
        border-radius: 14px;
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        font: 650 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: rgba(255,255,255,0.78);
      }
    `;
    document.head.appendChild(style);
  }

  function ensureOverlay() {
    let overlay = document.getElementById("ttHelpOverlay");
    if (overlay) return overlay;

    overlay = document.createElement("div");
    overlay.id = "ttHelpOverlay";
    overlay.className = "tthelp-overlay tthelp-hidden";
    overlay.innerHTML = `
      <div class="tthelp-card" role="dialog" aria-modal="true" aria-labelledby="tthelpTitle">
        <div class="tthelp-head">
          <div>
            <div id="tthelpTitle" class="tthelp-title">Help</div>
            <div class="tthelp-sub">Short cheatsheet. Nothing here opens your phone camera.</div>
          </div>
          <button class="tthelp-x" id="ttHelpClose" aria-label="Close help">✕</button>
        </div>

        <div class="tthelp-body">
          <ul>
            <li><b>Tilt crosshair</b> = device orientation (gravity).</li>
            <li><b>View crosshair</b> = virtual reference direction (not the phone camera).</li>
            <li><b>Tap a band</b> on the sphere to select it (tap again to cycle overlaps).</li>
            <li><b>Drag handles</b> to reshape. <b>Pinch</b> to zoom.</li>
            <li><b>Double‑tap</b> = lock/unlock View ↔ Tilt. <b>Long‑press</b> = set band center to View.</li>
          </ul>

          <div class="tthelp-callout">
            If motion doesn’t respond: enable motion permission in your browser and reload.
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    function hide(){ overlay.classList.add("tthelp-hidden"); }
    function show(){ overlay.classList.remove("tthelp-hidden"); }

    overlay.addEventListener("click", (e) => { if (e.target === overlay) hide(); });
    overlay.querySelector("#ttHelpClose").addEventListener("click", hide);

    window.ttHelp = { show, hide };
    return overlay;
  }

  function init() {
    ensureStyle();
    ensureOverlay();

    const helpBtn = document.getElementById("helpBtn");
    if (helpBtn) {
      helpBtn.addEventListener("click", () => window.ttHelp?.show?.(), { passive: true });
    }

    // Optional desktop shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.key === "?" || (e.shiftKey && e.key === "/")) window.ttHelp?.show?.();
      if (e.key === "Escape") window.ttHelp?.hide?.();
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
</script>
<!-- /TT_HELP_OVERLAY_v1 -->



<!-- TT_HIDE_REDUNDANT_TOP_CAMERA_NOTE_v1 -->
<script>
(() => {
  'use strict';

  // Only target the specific misunderstanding text, not general UI words.
  const KEYWORDS = [
    "phone camera",
    "device camera",
    "doesn't open your camera",
    "does not open your camera",
    "doesn't open the camera",
    "does not open the camera",
    "not the phone camera",
    "not your phone camera",
    "not the device camera",
  ];

  function hasKeyword(text) {
    const t = (text || "").toLowerCase();
    return KEYWORDS.some(k => t.includes(k));
  }

  function isLeaf(el) {
    return el && el.children && el.children.length === 0;
  }

  function hideTarget(el) {
    if (!el) return;
    // If it's an inline element that sits inside a container, hide the container when safe.
    let target = el;
    if ((target.tagName === "SPAN" || target.tagName === "B" || target.tagName === "I") &&
        target.parentElement && target.parentElement.children.length === 1) {
      target = target.parentElement;
    }
    target.style.display = "none";
  }

  function run() {
    // Never hide anything inside the ? help overlay
    const helpOverlay = document.getElementById("ttHelpOverlay");

    const all = Array.from(document.querySelectorAll("body *"));
    for (const el of all) {
      if (!isLeaf(el)) continue;
      if (helpOverlay && (el === helpOverlay || el.closest("#ttHelpOverlay"))) continue;

      const txt = (el.textContent || "").trim();
      if (!txt) continue;

      if (hasKeyword(txt)) {
        hideTarget(el);
      }
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", run, { once: true });
  } else {
    run();
  }
})();
</script>
<!-- /TT_HIDE_REDUNDANT_TOP_CAMERA_NOTE_v1 -->


<!-- TT_HIDE_TOP_GESTURE_HINT_v1 -->
<script>
(() => {
  'use strict';

  // Phrases that identify the top "how to use" bubble.
  // (We keep these instructions only in the ? Help overlay.)
  const KEYWORDS = [
    "drag to rotate",
    "pinch to zoom",
    "double-tap",
    "motion sensors available",
    "tap anywhere to enable",
    "attach/detach",
    "lock/unlock"
  ];

  function hasKW(text) {
    const t = (text || "").toLowerCase();
    return KEYWORDS.some(k => t.includes(k));
  }

  function bestCandidate() {
    const help = document.getElementById("ttHelpOverlay");

    // Scan all elements; pick the best match near the top.
    const all = Array.from(document.querySelectorAll("body *"));
    let best = null;
    let bestScore = -1;

    for (const el of all) {
      if (help && el.closest && el.closest("#ttHelpOverlay")) continue;

      const txt = (el.textContent || "").trim();
      if (!txt) continue;
      if (!hasKW(txt)) continue;

      const r = el.getBoundingClientRect?.();
      if (!r) continue;

      // Heuristic: the top bubble is near the top, relatively wide, and not huge.
      const nearTop = (r.top < 180) ? 1000 : 0;
      const wide = Math.min(r.width, 900);
      const notTooTall = Math.max(0, 240 - r.height);
      const score = nearTop + wide + notTooTall - (r.top * 2);

      if (score > bestScore) {
        bestScore = score;
        best = el;
      }
    }
    return best;
  }

  function hideBubble() {
    const leaf = bestCandidate();
    if (!leaf) return;

    // Climb to a reasonable container so we don't just hide one line of text.
    let target = leaf;
    for (let i = 0; i < 9; i++) {
      const parent = target.parentElement;
      if (!parent) break;

      const r = parent.getBoundingClientRect?.();
      if (!r) break;

      // Stop if parent is basically the whole page.
      if (r.height > 320 || r.width > window.innerWidth * 0.98) break;

      // Prefer parent if it still looks like the bubble.
      if (r.top < 220 && r.width > 240) target = parent;
      else break;
    }

    target.style.display = "none";
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", hideBubble, { once: true });
  } else {
    hideBubble();
  }
})();
</script>
<!-- /TT_HIDE_TOP_GESTURE_HINT_v1 -->

</body>
</html>